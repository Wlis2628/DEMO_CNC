/***************************************************
 * Automatically generated by Maple.
 * Created On: Tue Jan 05 12:56:15 2021.
***************************************************/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

/***************************************************
* Variable Definition for System:

* State variable(s):
*    S.w[ 1] = x[ 0] = `Main.CNC.P1.s`(t)
*    S.w[ 2] = x[ 1] = diff(`Main.CNC.P1.s`(t),t)
*    S.w[ 3] = x[ 2] = `Main.CNC.P2.s`(t)
*    S.w[ 4] = x[ 3] = diff(`Main.CNC.P2.s`(t),t)
*    S.w[ 5] = x[ 4] = `Main.CNC.R3.theta`(t)
*    S.w[ 6] = x[ 5] = diff(`Main.CNC.R3.theta`(t),t)
*    S.w[ 7] = x[ 6] = `Main.CNC.R5.theta`(t)
*    S.w[ 8] = x[ 7] = diff(`Main.CNC.R5.theta`(t),t)
*
* Output variable(s):
*    S.w[25] = y[ 0] = `Main.CNC.PositionX`(t)
*    S.w[26] = y[ 1] = `Main.CNC.PositionY`(t)
*    S.w[ 2] = y[ 2] = diff(`Main.CNC.P1.s`(t),t)
*    S.w[ 4] = y[ 3] = diff(`Main.CNC.P2.s`(t),t)
*    S.w[27] = y[ 4] = `Main.CNC.TorqueX`(t)
*    S.w[28] = y[ 5] = `Main.CNC.TorqueY`(t)
*
* Input variable(s):
*    S.w[31] = u[ 0] = `Main.CNC.X`(t)
*    S.w[32] = u[ 1] = `Main.CNC.Y`(t)
*
* Additional Parameter(s):
*    (vr = 185) ap[ 0] = `Main.CNC.minsamplestep` (default = 1/40)
*    (vr = 186) ap[ 1] = `Main.CNC.binfilename` (default = "DISABLED", type = string)
*
************************************************/

/* No scaling - no nominals */
double *nomfac=NULL;
/* Configurable parameters */
#define MAXERRSTRLENGTH 10000
#define MAXWARNSTRLENGTH 10000
#define WARNNUMDATPTS 100000
#define ERRTOL 1.000000e-06
#define MAXNEVT 0
#define MAXINTSTEP 0
#define EVTITER 100
#define EVTHYST 0.000000e+00
#define FMUHYST 1.000000e-10
#define INCONTOL 1e200

#define SSTO 0
/* Wordsize integer definition */
#ifndef M_INT
# if defined _MINGW64 || defined X86_64_WINDOWS
#  define M_INT long long
# elif defined __x86_64__ || defined __ppc64__
#  define M_INT long
# elif defined _M_X64
#  define M_INT long long
# else
#  define M_INT int
# endif
#endif

static int errorOccured = 0;
static char errorString[MAXERRSTRLENGTH+1];
static int warningOccured = 0;
static char warningString[MAXWARNSTRLENGTH+1];

static void SolverError(double t, int term, char *errmsg)
{
	if(term) {
		sprintf(errorString,"Simulation terminated at t=%20.16e: %s\n",t,errmsg);
		errorOccured = 2;
	}
	else {
		sprintf(errorString,"Error at t=%20.16e: %s\n",t,errmsg);
		errorOccured = 1;
	}
}


static void SolverWarning(double t, char *warnmsg)
{
	if(!warningOccured) {
		sprintf(warningString,"Warning at t=%20.16e: %s\n",t,warnmsg);
		warningOccured = 1;
	}
}

/* Fixed parameters */
#define NDIFF 8
#define NDFA 8
#define NEQ 72
#define NPAR 0
#define NINP 2
#define NINPD 2
#define NDISC 40
#define NIX1 24
#define NOUT 6
#define NCON 0
#define NEVT 22

#ifndef max
#define max(a,b) (((a)>(b))?(a):(b))
#endif
#ifndef min
#define min(a,b) (((a)<(b))?(a):(b))
#endif
static double nData[2] = {1.0*NEQ,1.0*NPAR};
static double minsamplestep = 2.50000000000000000e-02;

static void writeErrorToFile(FILE *fptr, char *errstr) {
	char *err, uerr[]="unknown error";
	int i;
	double d;

	if (errstr)
		err = errstr;
	else if (errorOccured)
		err = errorString;
	else
		err = uerr;

	d = -1e10; /*terminate value*/
	fwrite(&d,sizeof(double),1,fptr);
	for(i=0;;i++) {
		d = (double)err[i];
		fwrite(&d,sizeof(double),1,fptr);
		if (!err[i]) break;
	}

	fclose(fptr);
}

static int inputchange=0;

typedef struct {
	double *w;		/* Float workspace */
	M_INT *iw;		/* Integer workspace */
	double *wset;		/* Float workspace */
	double *psto;		/* Float projection workspace */
	double *ssto;		/* Solver storage (implicit) */
} SolverStruct;

static double dsn_zero=0.0;
static unsigned char dsn_undefC[8] = { 0, 0, 0, 0, 0, 0, 0xF8, 0x7F };
static double *dsn_undef = (double *)&dsn_undefC;
static unsigned char dsn_posinfC[8] = { 0, 0, 0, 0, 0, 0, 0xF0, 0x7F };
static double *dsn_posinf = (double *)&dsn_posinfC;
static unsigned char dsn_neginfC[8] = { 0, 0, 0, 0, 0, 0, 0xF0, 0xFF };
static double *dsn_neginf = (double *)&dsn_neginfC;
#define trunc(v) ( (v>0.0) ? floor(v) : ceil(v) )
#define IS_UNDEF(a) (a-a!=0. || (a!=0. && a-2.*a==0.))
#define UNUSED(a) ((void)(a))
static double avoidcompilerwarn() { return(dsn_zero+*dsn_undef+*dsn_posinf+*dsn_neginf); }

#ifdef MSVC
#pragma optimize( "gty", on)
#endif
#ifndef INCONTOL
#define INCONTOL 1e-14
#endif

static void LSQDecompSolve(M_INT n, double *A, M_INT Ainc, M_INT *ip, double *b)
{
	M_INT i,j,k,r,c,lsq,cp;
	double s,t;

	for(i=0;i<n;i++) {
		if(b[i]-b[i]!=0.0 || (b[i]!=0. && b[i]-2.*b[i]==0.)) { ip[n-1]=0; A[0]=1.; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
		t = fabs(A[i*Ainc]);
		for(j=1;j<n;j++) {
			s = fabs(A[i*Ainc+j]);
			if(s>t) t = s;
		}
		if( t==0.0 )
			A[i*Ainc+n] = 1.0;
		else {
			t = 1.0/t;
			for(j=0;j<n;j++) A[i*Ainc+j] *= t;
			b[i] *= t;
			A[i*Ainc+n] = t;
		}
	}

	for(j=0;j<n;j++) {
		t = fabs(A[j]);
		for(i=1;i<n;i++) {
			s = fabs(A[i*Ainc+j]);
			if(s>t) t = s;
		}
		if( t==0.0 )
			A[n*Ainc+j] = 1.0;
		else {
			t = 1.0/t;
			for(i=0;i<n;i++) A[i*Ainc+j] *= t;
			A[n*Ainc+j] = t;
		}
	}

	ip[n-1] = 0;
	lsq = 0;
	cp = 0;
	for(k=0;k<n;k++) {
		r = 0; c = 0; t = 0.0;
		if( cp<n ) {
			for(cp=cp+1;cp<n;cp++) {
				for(i=k;i<n;i++) {
					s = fabs(A[i*Ainc+cp]);
					if(s>t) { r = i; c = cp; t = s; }
				}
				if( t>0.5 ) break;
			}
		}
		if( cp>=n ) {
			for(i=k;i<n;i++)
				for(j=k;j<n;j++) {
					s = fabs(A[i*Ainc+j]);
					if(s>t) { r = i; c = j; t = s; }
				}
		}
		if( t<1e-10 ) {
			if( k==0 ) { ip[n-1]=0; A[0]=2.; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
			if( lsq ) { ip[n-1]=0; A[0]=3.; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
			lsq = 1;
			t = 1e-16;
			for(i=0;i<k;i++) {
				s = fabs(b[i]);
				if(s>t) t = s;
			}
			for(i=k;i<n;i++) {
				if( fabs(b[i])/t>INCONTOL*n ) { ip[n-1]=0; A[0]=4.; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
				b[i] = 0.0;
			}

			for(r=k;r<n;r++) {
				for(i=k;i<n;i++) A[i*Ainc+n+r] = 0.0;
				A[r*Ainc+n+r] = 1.0;
				A[(k-1)*Ainc+n+r] = -A[(k-1)*Ainc+r]/A[(k-1)*Ainc+k-1];
				for(i=k-1;i>=0;i--) {
					A[i*Ainc+n+r] = A[i*Ainc+r];
					for(j=i+1;j<k;j++)
						A[i*Ainc+n+r] += A[i*Ainc+j]*A[j*Ainc+n+r];
					A[i*Ainc+n+r] = -A[i*Ainc+n+r]/A[i*(Ainc+1)];
				}
			}
			for(r=0;r<k;r++) {
				s = -1.0/A[r*(Ainc+1)];
				for(i=k;i<n;i++)
					if( A[r*Ainc+n+i]!=0.0 ) {
						t = s*A[r*Ainc+n+i];
						A[i*Ainc+r] += t;
						for(j=r+1;j<n;j++)
							A[j*Ainc+n+i] += t*A[r*Ainc+j];
						b[i] += t*b[r];
					}
			}
			for(i=k;i<n;i++)
				for(j=k;j<n;j++)
					A[i*Ainc+j] = A[j*Ainc+n+i];
			r = 0; c = 0; t = 0.0;
			for(i=k;i<n;i++)
				for(j=k;j<n;j++) {
					s = fabs(A[i*Ainc+j]);
					if(s>t) { r = i; c = j; t = s; }
				}
			if( t<1e-10 ) { ip[n-1]=0; A[0]=3.; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
		}
		if( !lsq ) ip[n-1]++;
		if( k==n-1 ) break;
		ip[k] = r;
		ip[n+k] = c;
		if( r>k ) {
			for(j=0;j<n;j++) {
				t = A[r*Ainc+j]; A[r*Ainc+j] = A[k*Ainc+j]; A[k*Ainc+j] = t;
			}
			t = b[r]; b[r] = b[k]; b[k] = t;
		}
		if( c>k )
			for(i=0;i<n;i++) {
				t = A[i*Ainc+c]; A[i*Ainc+c] = A[i*Ainc+k]; A[i*Ainc+k] = t;
			}
		s = -1.0/A[k*(Ainc+1)];
		for(i=k+1;i<n;i++)
			if( A[i*Ainc+k]!=0.0 ) {
				t = s*A[i*Ainc+k];
				A[i*Ainc+k] = t;
				for(j=k+1;j<n;j++)
					A[i*Ainc+j] += t*A[k*Ainc+j];
				b[i] += t*b[k];
			}
	}
	for(j=n-1;j>0;j--) {
		b[j] = b[j]/A[j*(Ainc+1)];
		t = -b[j];
		for(i=0;i<j;i++)
			b[i] += t*A[i*Ainc+j];
	}
	b[0] = b[0]/A[0];
	for(j=n-2;j>=0;j--) {
		i = ip[n+j];
		if(i!=j) {
			t = b[i]; b[i] = b[j]; b[j] = t;
		}
	}
	for(j=0;j<n;j++) b[j] *= A[n*Ainc+j];
}
#ifdef MSVC
#pragma optimize( "", on)
#endif

#ifdef MSVC
#pragma optimize( "gty", on)
#endif
static void LSQMultiSolve(M_INT n, double *A, M_INT Ainc, M_INT *ip, M_INT nb,
	double *b, M_INT binc)
{
	M_INT i,j,k,m;
	double t,s;

	if( ip[n-1]==0 ) {
		for(i=0;i<n;i++) for(k=0;k<nb;k++) b[i*binc+k]=*dsn_undef;
		return;
	}
	for(i=0;i<n;i++) for(k=0;k<nb;k++) b[i*binc+k] *= A[i*Ainc+n];
	for(i=0;i<n-1;i++) {
		m = ip[i];
		if( m!=i )
			for(k=0;k<nb;k++) {
				t = b[m*binc+k]; b[m*binc+k] = b[i*binc+k]; b[i*binc+k] = t;
			}
	}
	for(j=0;j<n-1;j++)
		for(k=0;k<nb;k++) {
			t = b[j*binc+k];
			for(i=j+1;i<n;i++)
				b[i*binc+k] += t*A[i*Ainc+j];
		}
	for(j=n-1;j>0;j--) {
		s = 1.0/A[j*(Ainc+1)];
		for(k=0;k<nb;k++) {
			b[j*binc+k] = s*b[j*binc+k];
			t = -b[j*binc+k];
			for(i=0;i<j;i++)
				b[i*binc+k] += t*A[i*Ainc+j];
		}
	}
	for(k=0;k<nb;k++) b[k] = b[k]/A[0];
	for(j=n-2;j>=0;j--) {
		m = ip[n+j];
		if(m!=j)
			for(k=0;k<nb;k++) {
				t = b[m*binc+k]; b[m*binc+k] = b[j*binc+k]; b[j*binc+k] = t;
			}
	}
	for(j=0;j<n;j++) for(k=0;k<nb;k++) b[j*binc+k] *= A[n*Ainc+j];
}
#ifdef MSVC
#pragma optimize( "", on)
#endif

#ifdef MSVC
#pragma optimize( "gty", on)
#endif
static void DecompCInc(M_INT n, double *A, M_INT Ainc, M_INT *ip)
{
	M_INT i,j,k,m;
	double t;

	ip[n-1]=1;
	for(k=0;k<n-1;k++) {
		m=k;
		for(i=k+1;i<n;i++)
			if( fabs(A[i*Ainc+k])>fabs(A[m*Ainc+k]) ) m=i;
		ip[k]=m;
		if( m!=k ) ip[n-1]=-ip[n-1];
		t=A[m*Ainc+k]; A[m*Ainc+k]=A[(Ainc+1)*k]; A[(Ainc+1)*k]=t;
		if( t==0.0 ) { ip[n-1]=0; return; }
		t=-1.0/t;
		for(i=k+1;i<n;i++) A[i*Ainc+k]=A[i*Ainc+k]*t;
		for(j=k+1;j<n;j++) {
			t=A[m*Ainc+j]; A[m*Ainc+j]=A[k*Ainc+j]; A[k*Ainc+j]=t;
			if( t!=0.0 )
				for(i=k+1;i<n;i++) A[i*Ainc+j]+=A[i*Ainc+k]*t;
		}
	}
	if(A[(n-1)*(Ainc+1)]==0.0) ip[n-1]=0;
}
#ifdef MSVC
#pragma optimize( "", on)
#endif

#ifdef MSVC
#pragma optimize( "gty", on)
#endif
static void SolveCInc(M_INT n, double *A, M_INT Ainc, M_INT *ip, double *b)
{
	M_INT i,j,m;
	double t;

	if( n>1 ) {
		for(j=0;j<n-1;j++) {
			m=ip[j];
			t=b[m]; b[m]=b[j]; b[j]=t;
			for(i=j+1;i<n;i++) b[i]+=A[i*Ainc+j]*t;
		}
		for(j=n-1;j>0;j--) {
			b[j]=b[j]/A[(Ainc+1)*j];
			t=-b[j];
			for(i=0;i<=j-1;i++) b[i]+=A[i*Ainc+j]*t;
		}
	}
	b[0]=b[0]/A[0];
}
#ifdef MSVC
#pragma optimize( "", on)
#endif


void fp_sub1(int N, double T, double *Y, double *YP, double *Z)
{
	UNUSED(N);
	UNUSED(T);
	YP[0] = Y[1];
	YP[2] = Y[3];
	YP[4] = Y[5];
	YP[6] = Y[7];
	Z[0] = Y[1]-0.00073909830007390983*Y[5];
	Z[1] = -0.5;
	Y[16] = Z[1]*Y[1]-tanh(20.*Z[0])*(-2400.*exp(-fabs(Z[0]))+2500.)+0.000369549150036954915*Y[5];
	Z[0] = Y[3]-0.0002204328263378327563*Y[7];
	Y[17] = Y[3]*Z[1]-tanh(20.*Z[0])*(-2400.*exp(-fabs(Z[0]))+2500.)+0.0001102164131689163782*Y[7];
}

void fp_sub2(double *M, M_INT *P, double *V, double *Y, double *Z)
{
	Z[0] = cos(Y[4]);
	Z[1] = sin(Y[4]);
	Z[2] = 6.543907249766719158e-13;
	M[16] = Z[2]*(Z[0]*Z[0]+Z[1]*Z[1])+0.0007047288153878236176;
	M[20] = -1.;
	V[1] = -0.0001*Y[5];
	M[51] = 1.;
	M[53] = 1.;
	M[54] = -1.;
	V[3] = Y[30];
	Z[2] = -0.00002522860511691704896*Z[1]-0.00003411484968640632001*Z[0];
	Z[0] = -0.00002522860511691704896*Z[0]+0.00003411484968640632001*Z[1];
	M[96] = 0.1260862173534897399*(Z[2]*Z[2]+Z[0]*Z[0])+0.00001471871816576617;
	M[99] = -1.;
	V[6] = -0.0005*Y[5];
	LSQDecompSolve(7,M,16,P,V);
}

void fp_sub3(double *V, double *Y, double *YP)
{
	YP[5] = V[0];
	Y[8] = V[1];
	Y[9] = V[2];
	Y[18] = V[3];
	Y[19] = V[4];
	Y[12] = V[5];
	Y[14] = V[6];
}

void fp_sub4(double *M, double *V, double *Y, double *Z)
{
	M[0] = 26.15057414717343431;
	Z[0] = 0.2982456140350877193*Y[6];
	Z[1] = sin(Z[0]);
	Z[0] = cos(Z[0]);
	Z[2] = sin(Y[6]);
	Z[3] = cos(Y[6]);
	Z[4] = 4.858637589235128027e-06*Z[2];
	Z[5] = -2.238832939393877887e-06*Z[3];
	M[1] = Z[4]+Z[5]-2.043066232965894124e-06*Z[1]+4.190849202485267875e-06*Z[0];
	Z[6] = -4.840045108533975192e-06;
	Z[7] = Z[0]*Z[6]-9.999970063317986742e-06*Z[1];
	Z[8] = -4.430588537718271921e-07*Z[0]-1.149810619910374036e-06*Z[1];
	Z[2] = 0.00001775636314077511021*Z[2]+0.00003853424339345102039*Z[3];
	Z[3] = 0.03856404559058056833;
	Z[9] = Y[7]*Y[7];
	Z[10] = -0.129424761743837072*Z[7];
	Z[11] = Z[3]*Z[8];
	Z[12] = 0.1260862329545794117*Z[2];
	V[0] = (Z[10]+Z[11]-Z[12])*Z[9]+Y[16]-0.001*Y[1];
	Z[13] = -6.850280898767997944e-06*Z[1]+0.00001405167085539178052*Z[0];
	M[32] = Z[13];
	Z[14] = -4.430588537718271921e-07*Z[1]+1.149810619910374036e-06*Z[0];
	Z[6] = Z[1]*Z[6]+9.999970063317986742e-06*Z[0];
	M[33] = Z[7]*(-2.043066232965894124e-06*Z[0]-4.190849202485267875e-06*Z[1])+Z[8]*(5.685434098952237717e-07*Z[0]+1.144351957575897909e-06*Z[1])-Z[14]*(-5.685434098952237717e-07*Z[1]+1.144351957575897909e-06*Z[0])+0.2982456140350877193*Z[6]*Z[13]+0.0002096821176339954068;
}

void fp_sub5(double *M, M_INT *P, double *V, double *Y, double *Z)
{
	M[36] = -1.;
	V[2] = Z[6]*Z[9]*(Z[10]+Z[11])-Z[3]*(Z[8]*Z[9]*(Z[6]-Z[14])-Z[14]*Z[9]*(Z[7]-Z[8]))-Z[7]*Z[9]*(Z[3]*Z[14]-0.129424761743837072*Z[6])-0.00002982456140350877193*Y[7];
	M[53] = 1.;
	M[54] = 1.;
	M[55] = -0.2982456140350877193;
	V[3] = Y[31];
	Z[0] = Z[5]+Z[4];
	M[112] = Z[0];
	M[113] = Z[2]*Z[12]+7.931079996340554635*Z[0]*Z[0]+0.00001471871671053671071;
	M[117] = -1.;
	V[7] = -0.0005*Y[7];
	LSQDecompSolve(8,M,16,P,V);
}

void fp_sub6(double *M, double *V, double *Y, double *YP)
{
	YP[1] = V[0];
	YP[7] = V[1];
	Y[10] = V[2];
	Y[11] = V[3];
	Y[20] = V[4];
	Y[21] = V[5];
	Y[13] = V[6];
	Y[15] = V[7];
	M[0] = 2.186147044774565811;
	V[0] = Y[17]-0.001*Y[3];
}

void fp_sub7(double *M, double *V, double *Y, double *YP)
{
	YP[3] = V[0]/M[0];
	Y[22] = YP[5];
	Y[23] = YP[7];
}
static void fp(int N, double T, double *Y, double *YP)
{
	double M[144], V[8], Z[15];
	int ti1, ti2;
	M_INT P[15];

	fp_sub1(N,T,Y,YP,Z);
	for(ti1=0;ti1<=6;ti1++)
		for(ti2=0;ti2<=6;ti2++)
			M[ti1*16+ti2] = 0.;
	for(ti1=0;ti1<=6;ti1++)
		V[ti1] = 0.;
	M[65] = -1.;
	M[82] = -1.;
	if( Y[32]==1. ) {
		M[0] = 0.0001;
		M[37] = 1.;
		if( Y[43]==1. )
			V[2] = 0.01;
		else if( Y[42]==1. )
			V[2] = -0.01;
		else if( Y[35]==1. )
			V[2] = 0.01;
		else
			V[2] = -0.01;
		M[68] = -1.;
		M[70] = -1.;
		V[4] = 0.00073909830007390983*Y[16];
		M[80] = 0.0001;
	}
	else {
		M[4] = -1.;
		M[6] = -1.;
		M[64] = 0.0001;
		if( Y[41]==1. ) {
			V[0] = 0.01+0.00073909830007390983*Y[16];
			V[4] = -0.05;
		}
		else if( Y[40]==1. ) {
			V[0] = -0.01+0.00073909830007390983*Y[16];
			V[4] = 0.05;
		}
		else if( Y[33]==1. ) {
			V[0] = 0.01+0.00073909830007390983*Y[16];
			V[4] = -0.05;
		}
		else {
			V[0] = -0.01+0.00073909830007390983*Y[16];
			V[4] = 0.05;
		}
		if( Y[34]==1. ) {
			M[32] = 0.0001;
			M[85] = 1.;
		}
		else {
			M[37] = 1.;
			if( Y[43]==1. )
				V[2] = 0.01;
			else if( Y[42]==1. )
				V[2] = -0.01;
			else if( Y[35]==1. )
				V[2] = 0.01;
			else
				V[2] = -0.01;
			M[80] = 0.0001;
		}
	}
	fp_sub2(M,P,V,Y,Z);
	if( P[6]==0 ) {
		YP[0] = (*dsn_undef);
		return;
	}
	fp_sub3(V,Y,YP);
	for(ti1=0;ti1<=7;ti1++)
		for(ti2=0;ti2<=7;ti2++)
			M[ti1*16+ti2] = 0.;
	for(ti1=0;ti1<=7;ti1++)
		V[ti1] = 0.;
	M[99] = -1.;
	M[82] = -1.;
	if( Y[36]==1. ) {
		M[17] = 0.0001;
		M[68] = -1.;
		M[71] = -1.;
		M[97] = 0.00002982456140350877193;
		if( Y[47]==1. ) {
			V[4] = 0.01+0.00073909830007390983*Y[17];
			V[6] = -0.05;
		}
		else if( Y[46]==1. ) {
			V[4] = -0.01+0.00073909830007390983*Y[17];
			V[6] = 0.05;
		}
		else if( Y[39]==1. ) {
			V[4] = 0.01+0.00073909830007390983*Y[17];
			V[6] = -0.05;
		}
		else {
			V[4] = -0.01+0.00073909830007390983*Y[17];
			V[6] = 0.05;
		}
		M[86] = 1.;
	}
	else {
		M[22] = 1.;
		if( Y[45]==1. )
			V[1] = 0.01;
		else if( Y[44]==1. )
			V[1] = -0.01;
		else if( Y[37]==1. )
			V[1] = 0.01;
		else
			V[1] = -0.01;
		if( Y[38]==1. ) {
			M[65] = 0.00002982456140350877193;
			M[100] = -1.;
			M[103] = -1.;
			V[6] = 0.00073909830007390983*Y[17];
		}
		else {
			M[68] = -1.;
			M[71] = -1.;
			M[97] = 0.00002982456140350877193;
			if( Y[47]==1. ) {
				V[4] = 0.01+0.00073909830007390983*Y[17];
				V[6] = -0.05;
			}
			else if( Y[46]==1. ) {
				V[4] = -0.01+0.00073909830007390983*Y[17];
				V[6] = 0.05;
			}
			else if( Y[39]==1. ) {
				V[4] = 0.01+0.00073909830007390983*Y[17];
				V[6] = -0.05;
			}
			else {
				V[4] = -0.01+0.00073909830007390983*Y[17];
				V[6] = 0.05;
			}
		}
		M[81] = 0.0001;
	}
	fp_sub4(M,V,Y,Z);
	fp_sub5(M,P,V,Y,Z);
	if( P[7]==0 ) {
		YP[0] = (*dsn_undef);
		return;
	}
	fp_sub6(M,V,Y,YP);
	if( M[0]==0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	fp_sub7(M,V,Y,YP);
}

static void otp(double T, double *Y, double *YP)
{
	UNUSED(T);
	UNUSED(YP);
	Y[24] = 1000.*Y[0];
	Y[25] = 1000.*Y[2];
	Y[26] = Y[30];
	Y[27] = -Y[31];
}


void auxp_sub1(double *R, double T, double *Y, double *YP, double *Z)
{
	UNUSED(T);
	UNUSED(YP);
	Z[0] = cos(Y[6]);
	Z[1] = sin(Y[6]);
	Z[2] = -0.03853424339345102039;
	Z[3] = 1000.*Y[0];
	R[0] = Z[0]*Z[2]+Z[3]-0.01775636314077511021*Z[1]+217.504500985827413;
	R[1] = Z[1]*Z[2]+0.01775636314077511021*Z[0]+284.6346609707052722;
	Z[2] = atan2(0.,Z[0]);
	R[2] = 57.2957795130823208*Z[2];
	Z[4] = cos(Z[2]);
	R[3] = 57.2957795130823208*atan2(-Z[1],Z[0]*Z[4]);
	R[4] = 57.2957795130823208*atan2(-Z[1]*sin(Z[2]),Z[4]);
	R[5] = Z[3]+217.5417779031954501;
	R[6] = 1000.*Y[2]-495.0964543967238207;
	R[7] = Z[3]+175.8053150814549715;
	Z[0] = cos(Y[4]);
	Z[1] = sin(Y[4]);
	Z[2] = 57.2957795130823208*atan2(0.,Z[0]*Z[0]+Z[1]*Z[1]);
	R[8] = Z[2];
	Z[4] = 57.2957795130823208*atan2(-Z[1],Z[0]);
	R[9] = Z[4];
	Z[5] = 0.2982456140350877193*Y[6];
	Z[6] = cos(Z[5]);
	Z[5] = sin(Z[5]);
	R[10] = Z[3]+0.004840045108533975192*Z[6]+0.009999970063317986742*Z[5]+217.499999999999975;
	R[11] = 0.004840045108533975192*Z[5]-0.009999970063317986742*Z[6]+144.0000000000000047;
	Z[3] = atan2(0.,Z[6]);
}

void auxp_sub2(double *R, double *Z)
{
	R[12] = 57.2957795130823208*Z[3];
	Z[7] = cos(Z[3]);
	R[13] = 57.2957795130823208*atan2(-Z[5],Z[6]*Z[7]);
	R[14] = 57.2957795130823208*atan2(-Z[5]*sin(Z[3]),Z[7]);
	R[15] = 0.02522860511691704896*Z[1]+0.03411484968640632001*Z[0]-638.0003390593296302;
	R[16] = 0.02522860511691704896*Z[0]-0.03411484968640632001*Z[1]-109.6446609406748598;
	R[17] = Z[2];
	R[18] = Z[4];
}
static void auxp(double T, double *Y, double *YP, double *R)
{
	double Z[8];

	auxp_sub1(R,T,Y,YP,Z);
	auxp_sub2(R,Z);
}


void Dfp_sub1(double T)
{
	UNUSED(T);
}

void Dfp_sub2(double *FY, double *Y, double *Z)
{
	FY[1] = 1.;
	FY[19] = 1.;
	FY[37] = 1.;
	FY[55] = 1.;
	Z[0] = Y[1]-0.00073909830007390983*Y[5];
	Z[1] = tanh(20.*Z[0]);
	Z[0] = -2400.*exp(-fabs(Z[0]));
	Z[2] = Z[0]+2500.;
	Z[3] = -0.5;
	Z[4] = 0.000369549150036954915;
	Y[16] = Z[3]*Y[1]+Z[4]*Y[5]-Z[1]*Z[2];
}

void Dfp_sub3(double *Y, double *Z)
{
	Z[27] = Z[0];
	Z[28] = -0.00073909830007390983*Z[0];
	Z[0] = Y[3]-0.0002204328263378327563*Y[7];
	Z[1] = tanh(20.*Z[0]);
	Z[0] = -2400.*exp(-fabs(Z[0]));
	Z[2] = Z[0]+2500.;
	Z[4] = 0.0001102164131689163782;
	Y[17] = Z[3]*Y[3]+Z[4]*Y[7]-Z[1]*Z[2];
}

void Dfp_sub4(double *M, M_INT *P, double *V, double *Y, double *Z)
{
	Z[0] = cos(Y[4]);
	Z[1] = sin(Y[4]);
	Z[2] = 6.543907249766719158e-13;
	M[16] = Z[2]*(Z[0]*Z[0]+Z[1]*Z[1])+0.0007047288153878236176;
	M[20] = -1.;
	V[1] = -0.0001*Y[5];
	M[51] = 1.;
	M[53] = 1.;
	M[54] = -1.;
	V[3] = Y[30];
	Z[2] = -0.00002522860511691704896*Z[1]-0.00003411484968640632001*Z[0];
	Z[0] = -0.00002522860511691704896*Z[0]+0.00003411484968640632001*Z[1];
	M[96] = 0.1260862173534897399*(Z[2]*Z[2]+Z[0]*Z[0])+0.00001471871816576617;
	M[99] = -1.;
	V[6] = -0.0005*Y[5];
	LSQDecompSolve(7,M,16,P,V);
}

void Dfp_sub5(double *V, double *Y, double *YP)
{
	YP[5] = V[0];
	Y[8] = V[1];
	Y[9] = V[2];
	Y[18] = V[3];
	Y[19] = V[4];
	Y[12] = V[5];
	Y[14] = V[6];
}

void Dfp_sub6(double *B, double *FX, double *FY, double *M, M_INT *P, double *Y, double *YP, double *Z)
{
	B[0] = -Z[5];
	B[24] = -Z[7];
	Z[0] = cos(Y[4]);
	Z[1] = sin(Y[4]);
	Z[2] = Y[5]*Y[5];
	B[7] = 0.;
	Z[3] = -0.00002522860511691704896*Z[0]+0.00003411484968640632001*Z[1];
	Z[0] = -0.00002522860511691704896*Z[1]-0.00003411484968640632001*Z[0];
	Z[1] = Z[2]*Z[3];
	Z[4] = YP[5]*Z[3];
	B[37] = 0.;
	B[2] = -Z[6];
	B[8] = -0.0001;
	B[26] = -Z[8];
	B[38] = -0.0005;
	B[21] = Y[28];
	LSQMultiSolve(7,M,16,P,4,B,6);
	FY[41] = B[0];
	Z[31] = B[6];
	Z[32] = B[12];
	Z[33] = B[18];
	Z[34] = B[24];
	Z[35] = B[30];
	Z[36] = B[36];
	FY[44] = B[1];
	Z[37] = B[7];
	Z[38] = B[13];
	Z[39] = B[19];
	Z[40] = B[25];
	Z[41] = B[31];
	Z[42] = B[37];
	FY[45] = B[2];
	Z[43] = B[8];
	Z[44] = B[14];
	Z[45] = B[20];
	Z[46] = B[26];
	Z[47] = B[32];
	Z[48] = B[38];
	FX[5] = B[3];
	Z[49] = B[9];
	Z[50] = B[15];
	Z[51] = B[21];
	Z[52] = B[27];
	Z[53] = B[33];
	Z[54] = B[39];
}

void Dfp_sub7(double *M, double *V, double *Y, double *Z)
{
	M[0] = 26.15057414717343431;
	Z[0] = 0.2982456140350877193*Y[6];
	Z[1] = sin(Z[0]);
	Z[0] = cos(Z[0]);
	Z[2] = sin(Y[6]);
	Z[3] = cos(Y[6]);
	Z[4] = 4.858637589235128027e-06*Z[2];
	Z[5] = -2.238832939393877887e-06*Z[3];
	M[1] = Z[4]+Z[5]-2.043066232965894124e-06*Z[1]+4.190849202485267875e-06*Z[0];
	Z[6] = -4.840045108533975192e-06;
	Z[7] = Z[0]*Z[6]-9.999970063317986742e-06*Z[1];
	Z[8] = -4.430588537718271921e-07*Z[0]-1.149810619910374036e-06*Z[1];
	Z[2] = 0.00001775636314077511021*Z[2]+0.00003853424339345102039*Z[3];
	Z[3] = 0.03856404559058056833;
	Z[9] = Y[7]*Y[7];
	Z[10] = -0.129424761743837072*Z[7];
	Z[11] = Z[3]*Z[8];
	Z[12] = 0.1260862329545794117*Z[2];
	V[0] = (Z[10]+Z[11]-Z[12])*Z[9]+Y[16]-0.001*Y[1];
	Z[13] = -6.850280898767997944e-06*Z[1]+0.00001405167085539178052*Z[0];
	M[32] = Z[13];
	Z[14] = -4.430588537718271921e-07*Z[1]+1.149810619910374036e-06*Z[0];
	Z[6] = Z[1]*Z[6]+9.999970063317986742e-06*Z[0];
	M[33] = Z[7]*(-2.043066232965894124e-06*Z[0]-4.190849202485267875e-06*Z[1])+Z[8]*(5.685434098952237717e-07*Z[0]+1.144351957575897909e-06*Z[1])-Z[14]*(-5.685434098952237717e-07*Z[1]+1.144351957575897909e-06*Z[0])+0.2982456140350877193*Z[6]*Z[13]+0.0002096821176339954068;
}

void Dfp_sub8(double *M, M_INT *P, double *V, double *Y, double *Z)
{
	M[36] = -1.;
	V[2] = Z[6]*Z[9]*(Z[10]+Z[11])-Z[3]*(Z[8]*Z[9]*(Z[6]-Z[14])-Z[14]*Z[9]*(Z[7]-Z[8]))-Z[7]*Z[9]*(Z[3]*Z[14]-0.129424761743837072*Z[6])-0.00002982456140350877193*Y[7];
	M[53] = 1.;
	M[54] = 1.;
	M[55] = -0.2982456140350877193;
	V[3] = Y[31];
	Z[0] = Z[5]+Z[4];
	M[112] = Z[0];
	M[113] = Z[2]*Z[12]+7.931079996340554635*Z[0]*Z[0]+0.00001471871671053671071;
	M[117] = -1.;
	V[7] = -0.0005*Y[7];
	LSQDecompSolve(8,M,16,P,V);
}

void Dfp_sub9(double *V, double *Y, double *YP)
{
	YP[1] = V[0];
	YP[7] = V[1];
	Y[10] = V[2];
	Y[11] = V[3];
	Y[20] = V[4];
	Y[21] = V[5];
	Y[13] = V[6];
	Y[15] = V[7];
}

void Dfp_sub10(double *B, double *Y, double *YP, double *Z)
{
	B[0] = Z[27]-0.001;
	B[25] = -Z[25];
	B[37] = -Z[23];
	B[2] = Z[28];
	Z[0] = 0.2982456140350877193*Y[6];
	Z[1] = cos(Z[0]);
	Z[0] = sin(Z[0]);
	Z[2] = -1.443522225352238215e-06*Z[1]-2.982447211866767976e-06*Z[0];
	Z[3] = 1.443522225352238215e-06*Z[0]-2.982447211866767976e-06*Z[1];
	Z[4] = -3.429259743592343615e-07;
	Z[5] = Z[0]*Z[4]-1.321403598968607415e-07*Z[1];
	Z[0] = Z[1]*Z[4]+1.321403598968607415e-07*Z[0];
	Z[1] = cos(Y[6]);
	Z[4] = sin(Y[6]);
	Z[6] = 0.00001775636314077511021*Z[4]+0.00003853424339345102039*Z[1];
	Z[1] = 0.00001775636314077511021*Z[1]-0.00003853424339345102039*Z[4];
	Z[4] = Y[7]*Y[7];
	Z[7] = YP[7]*Z[6];
	Z[8] = Z[1]*Z[4]+Z[7];
	Z[9] = 0.4339536129058066533;
	Z[10] = 0.1293029763919466115;
	Z[11] = 0.03856404559058056833;
	Z[12] = (Z[5]*Z[10]-Z[2]*Z[9])*YP[7];
	Z[13] = (Z[0]*Z[11]-0.129424761743837072*Z[3])*Z[4];
	B[3] = Z[12]+Z[13]-0.1260862329545794117*Z[8];
	Z[14] = 3.352941176470588235*Z[2];
	Z[15] = -3.352941176470588235*Z[3];
	Z[16] = 3.352941176470588235*Z[5];
}

void Dfp_sub11(double *B, double *Y, double *YP, double *Z)
{
	Z[17] = -3.352941176470588235*Z[0];
	Z[18] = Z[14]-Z[16];
	Z[19] = Z[15]-Z[17];
	Z[20] = Z[3]-Z[0];
	Z[21] = Z[2]-Z[5];
	Z[22] = (Z[10]*Z[17]-Z[9]*Z[15])*YP[7]+Z[4]*(Z[16]*Z[11]-0.129424761743837072*Z[14])-1.455020937390057602*YP[1];
	B[15] = Z[2]*Z[22]+Z[5]*(YP[7]*Z[10]*Z[19]+Z[4]*Z[11]*Z[18]+0.4335452737847621679*YP[1])+Z[15]*(Z[13]+Z[12])+Z[17]*(YP[7]*Z[10]*Z[21]+Z[4]*Z[11]*Z[20])-Z[0]*(Z[4]*Z[11]*Z[19]-YP[7]*Z[10]*Z[18])-Z[3]*((Z[9]*Z[14]-Z[10]*Z[16])*YP[7]+Z[4]*(Z[17]*Z[11]-0.129424761743837072*Z[15]))-Z[14]*((Z[3]*Z[9]-Z[0]*Z[10])*YP[7]+Z[4]*(Z[5]*Z[11]-0.129424761743837072*Z[2]))-Z[16]*(Z[4]*Z[11]*Z[21]-YP[7]*Z[10]*Z[20]);
	Z[0] = Z[4]*Z[6];
	B[45] = 0.1260862329545794117*(Z[1]*Z[8]+Z[1]*(-(Z[1]*Z[4]+Z[7]))-Z[6]*YP[1]);
	Z[0] = 0.07712809118116113666;
	Z[1] = -0.2588495234876741441*Z[14];
	Z[2] = Z[0]*Z[16];
	B[4] = (Z[1]+Z[2]-0.2521724659091588235*Z[6])*Y[7];
	B[16] = Z[15]*Y[7]*(Z[1]+Z[2])-Z[0]*(Z[16]*Z[19]*Y[7]-Z[17]*Z[18]*Y[7])-Z[14]*Y[7]*(Z[17]*Z[0]-0.2588495234876741441*Z[15])-0.00002982456140350877193;
}

void Dfp_sub12(double *B, double *FX, double *FY, double *M, M_INT *P, double *V, double *Y, double *Z)
{
	B[28] = -Z[26];
	B[40] = -Z[24];
	B[46] = -0.0005;
	B[23] = Y[29];
	LSQMultiSolve(8,M,16,P,6,B,6);
	FY[9] = B[0];
	FY[57] = B[6];
	Z[55] = B[12];
	Z[56] = B[18];
	Z[57] = B[24];
	Z[58] = B[30];
	Z[59] = B[36];
	Z[60] = B[42];
	FY[11] = B[1];
	FY[59] = B[7];
	Z[61] = B[13];
	Z[62] = B[19];
	Z[63] = B[25];
	Z[64] = B[31];
	Z[65] = B[37];
	Z[66] = B[43];
	FY[13] = B[2];
	FY[61] = B[8];
	Z[67] = B[14];
	Z[68] = B[20];
	Z[69] = B[26];
	Z[70] = B[32];
	Z[71] = B[38];
	Z[72] = B[44];
	FY[14] = B[3];
	FY[62] = B[9];
	Z[73] = B[15];
	Z[74] = B[21];
	Z[75] = B[27];
	Z[76] = B[33];
	Z[77] = B[39];
	Z[78] = B[45];
	FY[15] = B[4];
	FY[63] = B[10];
	Z[79] = B[16];
	Z[80] = B[22];
	Z[81] = B[28];
	Z[82] = B[34];
	Z[83] = B[40];
	Z[84] = B[46];
	FX[1] = B[5];
	FX[7] = B[11];
	Z[85] = B[17];
	Z[86] = B[23];
	Z[87] = B[29];
	Z[88] = B[35];
	Z[89] = B[41];
	Z[90] = B[47];
	M[0] = 2.186147044774565811;
	V[0] = Y[17]-0.001*Y[3];
}

void Dfp_sub13(double *FX, double *FY, double *M, double *V, double *Y, double *YP, double *Z)
{
	YP[3] = V[0]/M[0];
	Z[0] = 1.0/M[0];
	FY[27] = 1.*(Z[29]-0.001)*Z[0];
	FY[31] = Z[30]*Z[0];
	Y[22] = YP[5];
	Z[91] = FY[41];
	Z[92] = FY[44];
	Z[93] = FY[45];
	Z[94] = FX[5];
	Y[23] = YP[7];
	Z[95] = FY[57];
	Z[96] = FY[59];
	Z[97] = FY[61];
	Z[98] = FY[62];
	Z[99] = FY[63];
	Z[100] = FX[7];
}
static void Dfp(double T, double *Y, double *FX, double *FY)
{
	double B[48], M[144], V[8], YP[8], Z[109];
	int ti1, ti2, ti3;
	M_INT P[15];

	Dfp_sub1(T);
	for(ti2=0;ti2<=7;ti2++)
		for(ti3=0;ti3<=7;ti3++)
			FY[ti2*8+ti3] = 0.;
	for(ti2=0;ti2<=7;ti2++)
		FX[ti2] = 0.;
	Dfp_sub2(FY,Y,Z);
	if( Y[1]-0.00073909830007390983*Y[5]>0. )
		ti1 = 1;
	else if( Y[1]-0.00073909830007390983*Y[5]<0. )
		ti1 = -1;
	else
		ti1 = 0;
	Z[0] = Z[0]*Z[1]*((double)ti1)+Z[3]-(20.*(1.-Z[1]*Z[1]))*Z[2];
	Dfp_sub3(Y,Z);
	if( Y[3]-0.0002204328263378327563*Y[7]>0. )
		ti1 = 1;
	else if( Y[3]-0.0002204328263378327563*Y[7]<0. )
		ti1 = -1;
	else
		ti1 = 0;
	Z[0] = Z[0]*Z[1]*((double)ti1)+Z[3]-(20.*(1.-Z[1]*Z[1]))*Z[2];
	Z[29] = Z[0];
	Z[30] = -0.0002204328263378327563*Z[0];
	for(ti2=0;ti2<=6;ti2++)
		for(ti3=0;ti3<=6;ti3++)
			M[ti2*16+ti3] = 0.;
	for(ti2=0;ti2<=6;ti2++)
		V[ti2] = 0.;
	M[65] = -1.;
	M[82] = -1.;
	if( Y[32]==1. ) {
		M[0] = 0.0001;
		M[37] = 1.;
		if( Y[43]==1. )
			V[2] = 0.01;
		else if( Y[42]==1. )
			V[2] = -0.01;
		else if( Y[35]==1. )
			V[2] = 0.01;
		else
			V[2] = -0.01;
		M[68] = -1.;
		M[70] = -1.;
		V[4] = 0.00073909830007390983*Y[16];
		M[80] = 0.0001;
	}
	else {
		M[4] = -1.;
		M[6] = -1.;
		M[64] = 0.0001;
		if( Y[41]==1. ) {
			V[0] = 0.01+0.00073909830007390983*Y[16];
			V[4] = -0.05;
		}
		else if( Y[40]==1. ) {
			V[0] = -0.01+0.00073909830007390983*Y[16];
			V[4] = 0.05;
		}
		else if( Y[33]==1. ) {
			V[0] = 0.01+0.00073909830007390983*Y[16];
			V[4] = -0.05;
		}
		else {
			V[0] = -0.01+0.00073909830007390983*Y[16];
			V[4] = 0.05;
		}
		if( Y[34]==1. ) {
			M[32] = 0.0001;
			M[85] = 1.;
		}
		else {
			M[37] = 1.;
			if( Y[43]==1. )
				V[2] = 0.01;
			else if( Y[42]==1. )
				V[2] = -0.01;
			else if( Y[35]==1. )
				V[2] = 0.01;
			else
				V[2] = -0.01;
			M[80] = 0.0001;
		}
	}
	Dfp_sub4(M,P,V,Y,Z);
	if( P[6]==0 ) {
		FX[0] = (*dsn_undef);
		return;
	}
	Dfp_sub5(V,Y,YP);
	if( Y[32]==1. ) {
		Z[5] = 0.;
		Z[6] = 0.;
		Z[7] = -0.00073909830007390983*Z[27];
		Z[8] = -0.00073909830007390983*Z[28];
	}
	else {
		Z[5] = -0.00073909830007390983*Z[27];
		Z[6] = -0.00073909830007390983*Z[28];
		Z[7] = 0.;
		Z[8] = 0.;
	}
	for(ti2=0;ti2<=6;ti2++)
		for(ti3=0;ti3<=3;ti3++)
			B[ti2*6+ti3] = 0.;
	Dfp_sub6(B,FX,FY,M,P,Y,YP,Z);
	for(ti2=0;ti2<=7;ti2++)
		for(ti3=0;ti3<=7;ti3++)
			M[ti2*16+ti3] = 0.;
	for(ti2=0;ti2<=7;ti2++)
		V[ti2] = 0.;
	M[99] = -1.;
	M[82] = -1.;
	if( Y[36]==1. ) {
		M[17] = 0.0001;
		M[68] = -1.;
		M[71] = -1.;
		M[97] = 0.00002982456140350877193;
		if( Y[47]==1. ) {
			V[4] = 0.01+0.00073909830007390983*Y[17];
			V[6] = -0.05;
		}
		else if( Y[46]==1. ) {
			V[4] = -0.01+0.00073909830007390983*Y[17];
			V[6] = 0.05;
		}
		else if( Y[39]==1. ) {
			V[4] = 0.01+0.00073909830007390983*Y[17];
			V[6] = -0.05;
		}
		else {
			V[4] = -0.01+0.00073909830007390983*Y[17];
			V[6] = 0.05;
		}
		M[86] = 1.;
	}
	else {
		M[22] = 1.;
		if( Y[45]==1. )
			V[1] = 0.01;
		else if( Y[44]==1. )
			V[1] = -0.01;
		else if( Y[37]==1. )
			V[1] = 0.01;
		else
			V[1] = -0.01;
		if( Y[38]==1. ) {
			M[65] = 0.00002982456140350877193;
			M[100] = -1.;
			M[103] = -1.;
			V[6] = 0.00073909830007390983*Y[17];
		}
		else {
			M[68] = -1.;
			M[71] = -1.;
			M[97] = 0.00002982456140350877193;
			if( Y[47]==1. ) {
				V[4] = 0.01+0.00073909830007390983*Y[17];
				V[6] = -0.05;
			}
			else if( Y[46]==1. ) {
				V[4] = -0.01+0.00073909830007390983*Y[17];
				V[6] = 0.05;
			}
			else if( Y[39]==1. ) {
				V[4] = 0.01+0.00073909830007390983*Y[17];
				V[6] = -0.05;
			}
			else {
				V[4] = -0.01+0.00073909830007390983*Y[17];
				V[6] = 0.05;
			}
		}
		M[81] = 0.0001;
	}
	Dfp_sub7(M,V,Y,Z);
	Dfp_sub8(M,P,V,Y,Z);
	if( P[7]==0 ) {
		FX[0] = (*dsn_undef);
		return;
	}
	Dfp_sub9(V,Y,YP);
	if( Y[36]==1. ) {
		Z[23] = 0.;
		Z[24] = 0.;
		Z[25] = -0.00073909830007390983*Z[29];
		Z[26] = -0.00073909830007390983*Z[30];
	}
	else {
		if( Y[38]==1. ) {
			Z[23] = -0.00073909830007390983*Z[29];
			Z[24] = -0.00073909830007390983*Z[30];
			Z[25] = 0.;
			Z[26] = 0.;
		}
		else {
			Z[23] = 0.;
			Z[24] = 0.;
			Z[25] = -0.00073909830007390983*Z[29];
			Z[26] = -0.00073909830007390983*Z[30];
		}
	}
	for(ti2=0;ti2<=7;ti2++)
		for(ti3=0;ti3<=5;ti3++)
			B[ti2*6+ti3] = 0.;
	Dfp_sub10(B,Y,YP,Z);
	Dfp_sub11(B,Y,YP,Z);
	Dfp_sub12(B,FX,FY,M,P,V,Y,Z);
	if( M[0]==0. ) {
		FX[0] = (*dsn_undef);
		return;
	}
	Dfp_sub13(FX,FY,M,V,Y,YP,Z);
}

static void eev(double T, double *Y, double *Ypre, double *EA)
{
	double Z[3];

	UNUSED(T);
	UNUSED(Ypre);
	EA[0] = Y[7];
	EA[1] = Y[5];
	EA[2] = Y[9];
	EA[3] = Y[10];
	Z[0] = 2.982456140350877193e-11*Y[7];
	EA[4] = Z[0]-1.;
	Z[1] = 1e-10*Y[5];
	EA[5] = Z[1]-1.;
	Z[2] = 1e-10*Y[7];
	EA[6] = Z[2]-1.;
	EA[7] = Y[8]-0.05;
	EA[8] = Y[11]-0.05;
	EA[9] = Y[8]-0.01;
	EA[10] = Y[9]-0.01;
	EA[11] = Y[10]-0.01;
	EA[12] = Y[11]-0.01;
	EA[13] = -(1.+Z[0]);
	EA[14] = -(1.+Z[1]);
	EA[15] = -(1.+Z[2]);
	EA[16] = -Y[8]-0.05;
	EA[17] = -Y[8]-0.01;
	EA[18] = -Y[9]-0.01;
	EA[19] = -Y[10]-0.01;
	EA[20] = -Y[11]-0.05;
	EA[21] = -Y[11]-0.01;
}

static int eex(int N, double T, double *Y, double *Ypre)
{
	UNUSED(T);
	if( N<17 ) {
		if( N==1 )
			Y[50] = 1.-Y[50];
		else if( N==2 )
			Y[51] = 1.-Y[51];
		else if( N==3 )
			Y[52] = 1.-Y[52];
		else if( N==4 )
			Y[53] = 1.-Y[53];
		else if( N==5 )
			Y[54] = 1.-Y[54];
		else if( N==6 )
			Y[55] = 1.-Y[55];
		else if( N==7 )
			Y[56] = 1.-Y[56];
		else if( N==8 )
			Y[57] = 1.-Y[57];
		else if( N==9 )
			Y[58] = 1.-Y[58];
		else if( N==10 )
			Y[59] = 1.-Y[59];
		else if( N==11 )
			Y[60] = 1.-Y[60];
		else if( N==12 )
			Y[61] = 1.-Y[61];
		else if( N==13 )
			Y[62] = 1.-Y[62];
		else if( N==14 )
			Y[63] = 1.-Y[63];
		else if( N==15 )
			Y[64] = 1.-Y[64];
		else if( N==16 )
			Y[65] = 1.-Y[65];
	}
	else if( N<23 ) {
		if( N==17 )
			Y[66] = 1.-Y[66];
		else if( N==18 )
			Y[67] = 1.-Y[67];
		else if( N==19 )
			Y[68] = 1.-Y[68];
		else if( N==20 )
			Y[69] = 1.-Y[69];
		else if( N==21 )
			Y[70] = 1.-Y[70];
		else if( N==22 )
			Y[71] = 1.-Y[71];
	}
	else if( N==23 ) {
		if( ( ( (Ypre[33]==0.) && ( (Y[66]==1.) || ( (Ypre[40]==1.) && (Y[67]==1.) ) ) ) || ( (Ypre[33]==1.) && (Y[64]==1.) ) ) || ( (Y[48]==1.) && (Y[5]<0.) ) )
			Y[40] = 1.;
		else
			Y[40] = 0.;
		if( ( ( (Ypre[33]==0.) && ( (Y[57]==1.) || ( (Ypre[41]==1.) && (Y[59]==1.) ) ) ) || ( (Ypre[33]==-1.) && (Y[55]==1.) ) ) || ( (Y[48]==1.) && (Y[5]>0.) ) )
			Y[41] = 1.;
		else
			Y[41] = 0.;
		if( ( ( (Ypre[35]==0.) && ( (Y[52]==0.) || ( (Ypre[42]==1.) && (Y[68]==1.) ) ) ) || ( (Ypre[35]==1.) && (Y[64]==1.) ) ) || ( (Y[48]==1.) && (Y[5]<0.) ) )
			Y[42] = 1.;
		else
			Y[42] = 0.;
		if( ( ( (Ypre[35]==0.) && ( (Y[52]==1.) || ( (Ypre[43]==1.) && (Y[60]==1.) ) ) ) || ( (Ypre[35]==-1.) && (Y[55]==1.) ) ) || ( (Y[48]==1.) && (Y[5]>0.) ) )
			Y[43] = 1.;
		else
			Y[43] = 0.;
		if( ( ( (Ypre[37]==0.) && ( (Y[53]==0.) || ( (Ypre[44]==1.) && (Y[69]==1.) ) ) ) || ( (Ypre[37]==1.) && (Y[65]==1.) ) ) || ( (Y[48]==1.) && (Y[7]<0.) ) )
			Y[44] = 1.;
		else
			Y[44] = 0.;
		if( ( ( (Ypre[37]==0.) && ( (Y[53]==1.) || ( (Ypre[45]==1.) && (Y[61]==1.) ) ) ) || ( (Ypre[37]==-1.) && (Y[56]==1.) ) ) || ( (Y[48]==1.) && (Y[7]>0.) ) )
			Y[45] = 1.;
		else
			Y[45] = 0.;
		if( ( ( (Ypre[39]==0.) && ( (Y[70]==1.) || ( (Ypre[46]==1.) && (Y[71]==1.) ) ) ) || ( (Ypre[39]==1.) && (Y[63]==1.) ) ) || ( (Y[48]==1.) && (0.2982456140350877193*Y[7]<0.) ) )
			Y[46] = 1.;
		else
			Y[46] = 0.;
		if( ( ( (Ypre[39]==0.) && ( (Y[58]==1.) || ( (Ypre[47]==1.) && (Y[62]==1.) ) ) ) || ( (Ypre[39]==-1.) && (Y[54]==1.) ) ) || ( (Y[48]==1.) && (0.2982456140350877193*Y[7]>0.) ) )
			Y[47] = 1.;
		else
			Y[47] = 0.;
		if( ( ( (Ypre[33]==1.) || (Ypre[33]==2.) ) || (Y[41]==1.) ) && (Y[51]==1.) )
			Y[33] = 1.;
		else {
			if( ( ( (Ypre[33]==-1.) || (Ypre[33]==2.) ) || (Y[40]==1.) ) && (Y[51]==0.) )
				Y[33] = -1.;
			else
				Y[33] = 0.;
		}
		if( ( ( (Ypre[35]==1.) || (Ypre[35]==2.) ) || (Y[43]==1.) ) && (Y[51]==1.) )
			Y[35] = 1.;
		else {
			if( ( ( (Ypre[35]==-1.) || (Ypre[35]==2.) ) || (Y[42]==1.) ) && (Y[51]==0.) )
				Y[35] = -1.;
			else
				Y[35] = 0.;
		}
		if( ( ( (Ypre[37]==1.) || (Ypre[37]==2.) ) || (Y[45]==1.) ) && (Y[50]==1.) )
			Y[37] = 1.;
		else {
			if( ( ( (Ypre[37]==-1.) || (Ypre[37]==2.) ) || (Y[44]==1.) ) && (Y[50]==0.) )
				Y[37] = -1.;
			else
				Y[37] = 0.;
		}
		if( ( ( (Ypre[39]==1.) || (Ypre[39]==2.) ) || (Y[47]==1.) ) && (Y[50]==1.) )
			Y[39] = 1.;
		else {
			if( ( ( (Ypre[39]==-1.) || (Ypre[39]==2.) ) || (Y[46]==1.) ) && (Y[50]==0.) )
				Y[39] = -1.;
			else
				Y[39] = 0.;
		}
		if( ( !( ( ( ( (Ypre[33]==2.) || (Ypre[33]==1.) ) || (Y[41]==1.) ) || (Ypre[33]==-1.) ) || (Y[40]==1.) ) ) || ( ( ( ( (Y[33]==0.) && ( !(Y[41]==1.) ) ) && ( !(Y[40]==1.) ) ) && ( !(Ypre[41]==1.) ) ) && ( !(Ypre[40]==1.) ) ) )
			Y[32] = 1.;
		else
			Y[32] = 0.;
		if( ( !( ( ( ( (Ypre[35]==2.) || (Ypre[35]==1.) ) || (Y[43]==1.) ) || (Ypre[35]==-1.) ) || (Y[42]==1.) ) ) || ( ( ( ( (Y[35]==0.) && ( !(Y[43]==1.) ) ) && ( !(Y[42]==1.) ) ) && ( !(Ypre[43]==1.) ) ) && ( !(Ypre[42]==1.) ) ) )
			Y[34] = 1.;
		else
			Y[34] = 0.;
		if( ( !( ( ( ( (Ypre[37]==2.) || (Ypre[37]==1.) ) || (Y[45]==1.) ) || (Ypre[37]==-1.) ) || (Y[44]==1.) ) ) || ( ( ( ( (Y[37]==0.) && ( !(Y[45]==1.) ) ) && ( !(Y[44]==1.) ) ) && ( !(Ypre[45]==1.) ) ) && ( !(Ypre[44]==1.) ) ) )
			Y[36] = 1.;
		else
			Y[36] = 0.;
		if( ( !( ( ( ( (Ypre[39]==2.) || (Ypre[39]==1.) ) || (Y[47]==1.) ) || (Ypre[39]==-1.) ) || (Y[46]==1.) ) ) || ( ( ( ( (Y[39]==0.) && ( !(Y[47]==1.) ) ) && ( !(Y[46]==1.) ) ) && ( !(Ypre[47]==1.) ) ) && ( !(Ypre[46]==1.) ) ) )
			Y[38] = 1.;
		else
			Y[38] = 0.;
		if( !( (Y[32]==0.) || (Y[32]==1.) ) ) {
			Y[49] = 1.;
			return(1);
		}
		if( !( (Y[34]==0.) || (Y[34]==1.) ) ) {
			Y[49] = 5.;
			return(1);
		}
		if( !( (Y[36]==0.) || (Y[36]==1.) ) ) {
			Y[49] = 9.;
			return(1);
		}
		if( !( (Y[38]==0.) || (Y[38]==1.) ) ) {
			Y[49] = 13.;
			return(1);
		}
		if( !( (Y[40]==0.) || (Y[40]==1.) ) ) {
			Y[49] = 3.;
			return(1);
		}
		if( !( (Y[41]==0.) || (Y[41]==1.) ) ) {
			Y[49] = 4.;
			return(1);
		}
		if( !( (Y[42]==0.) || (Y[42]==1.) ) ) {
			Y[49] = 7.;
			return(1);
		}
		if( !( (Y[43]==0.) || (Y[43]==1.) ) ) {
			Y[49] = 8.;
			return(1);
		}
		if( !( (Y[44]==0.) || (Y[44]==1.) ) ) {
			Y[49] = 11.;
			return(1);
		}
		if( !( (Y[45]==0.) || (Y[45]==1.) ) ) {
			Y[49] = 12.;
			return(1);
		}
		if( !( (Y[46]==0.) || (Y[46]==1.) ) ) {
			Y[49] = 15.;
			return(1);
		}
		if( !( (Y[47]==0.) || (Y[47]==1.) ) ) {
			Y[49] = 16.;
			return(1);
		}
		if( !(floor(Y[33]+0.5)==Y[33]) ) {
			Y[49] = 2.;
			return(1);
		}
		if( !(floor(Y[35]+0.5)==Y[35]) ) {
			Y[49] = 6.;
			return(1);
		}
		if( !(floor(Y[37]+0.5)==Y[37]) ) {
			Y[49] = 10.;
			return(1);
		}
		if( !(floor(Y[39]+0.5)==Y[39]) ) {
			Y[49] = 14.;
			return(1);
		}
		if( Y[48]==1. )
			Y[48] = 0.;
	}
	return(0);
}

static int cpr(double T, double *Y)
{
	double v;
	int k;

	UNUSED(T);
	k = 0;
	if( 0.2982456140350877193*Y[7]>0. )
		v = 1.;
	else
		v = 0.;
	if( Y[50]!=v ) {
		Y[50] = v;
		k = 1;
	}
	if( Y[5]>0. )
		v = 1.;
	else
		v = 0.;
	if( Y[51]!=v ) {
		Y[51] = v;
		k = 1;
	}
	if( Y[9]>0. )
		v = 1.;
	else
		v = 0.;
	if( Y[52]!=v ) {
		Y[52] = v;
		k = 1;
	}
	if( Y[10]>0. )
		v = 1.;
	else
		v = 0.;
	if( Y[53]!=v ) {
		Y[53] = v;
		k = 1;
	}
	if( 0.2982456140350877193*Y[7]>1e10 )
		v = 1.;
	else
		v = 0.;
	if( Y[54]!=v ) {
		Y[54] = v;
		k = 1;
	}
	if( Y[5]>1e10 )
		v = 1.;
	else
		v = 0.;
	if( Y[55]!=v ) {
		Y[55] = v;
		k = 1;
	}
	if( Y[7]>1e10 )
		v = 1.;
	else
		v = 0.;
	if( Y[56]!=v ) {
		Y[56] = v;
		k = 1;
	}
	if( Y[8]>0.05 )
		v = 1.;
	else
		v = 0.;
	if( Y[57]!=v ) {
		Y[57] = v;
		k = 1;
	}
	if( Y[11]>0.05 )
		v = 1.;
	else
		v = 0.;
	if( Y[58]!=v ) {
		Y[58] = v;
		k = 1;
	}
	if( Y[8]>0.01 )
		v = 1.;
	else
		v = 0.;
	if( Y[59]!=v ) {
		Y[59] = v;
		k = 1;
	}
	if( Y[9]>0.01 )
		v = 1.;
	else
		v = 0.;
	if( Y[60]!=v ) {
		Y[60] = v;
		k = 1;
	}
	if( Y[10]>0.01 )
		v = 1.;
	else
		v = 0.;
	if( Y[61]!=v ) {
		Y[61] = v;
		k = 1;
	}
	if( Y[11]>0.01 )
		v = 1.;
	else
		v = 0.;
	if( Y[62]!=v ) {
		Y[62] = v;
		k = 1;
	}
	if( 0.2982456140350877193*Y[7]<-1e10 )
		v = 1.;
	else
		v = 0.;
	if( Y[63]!=v ) {
		Y[63] = v;
		k = 1;
	}
	if( Y[5]<-1e10 )
		v = 1.;
	else
		v = 0.;
	if( Y[64]!=v ) {
		Y[64] = v;
		k = 1;
	}
	if( Y[7]<-1e10 )
		v = 1.;
	else
		v = 0.;
	if( Y[65]!=v ) {
		Y[65] = v;
		k = 1;
	}
	if( Y[8]<-0.05 )
		v = 1.;
	else
		v = 0.;
	if( Y[66]!=v ) {
		Y[66] = v;
		k = 1;
	}
	if( Y[8]<-0.01 )
		v = 1.;
	else
		v = 0.;
	if( Y[67]!=v ) {
		Y[67] = v;
		k = 1;
	}
	if( Y[9]<-0.01 )
		v = 1.;
	else
		v = 0.;
	if( Y[68]!=v ) {
		Y[68] = v;
		k = 1;
	}
	if( Y[10]<-0.01 )
		v = 1.;
	else
		v = 0.;
	if( Y[69]!=v ) {
		Y[69] = v;
		k = 1;
	}
	if( Y[11]<-0.05 )
		v = 1.;
	else
		v = 0.;
	if( Y[70]!=v ) {
		Y[70] = v;
		k = 1;
	}
	if( Y[11]<-0.01 )
		v = 1.;
	else
		v = 0.;
	if( Y[71]!=v ) {
		Y[71] = v;
		k = 1;
	}
	return(k);
}

static void terminate(double T, double *Y, int j)
{
	UNUSED(Y);
	if(j==1) SolverError(T,1,"variable `Main.CNC.BF2.locked`(t) must be boolean valued");
	if(j==2) SolverError(T,1,"variable `Main.CNC.BF2.mode`(t) must be integer valued");
	if(j==3) SolverError(T,1,"variable `Main.CNC.BF2.startBackward`(t) must be boolean valued");
	if(j==4) SolverError(T,1,"variable `Main.CNC.BF2.startForward`(t) must be boolean valued");
	if(j==5) SolverError(T,1,"variable `Main.CNC.BF3.locked`(t) must be boolean valued");
	if(j==6) SolverError(T,1,"variable `Main.CNC.BF3.mode`(t) must be integer valued");
	if(j==7) SolverError(T,1,"variable `Main.CNC.BF3.startBackward`(t) must be boolean valued");
	if(j==8) SolverError(T,1,"variable `Main.CNC.BF3.startForward`(t) must be boolean valued");
	if(j==9) SolverError(T,1,"variable `Main.CNC.BF4.locked`(t) must be boolean valued");
	if(j==10) SolverError(T,1,"variable `Main.CNC.BF4.mode`(t) must be integer valued");
	if(j==11) SolverError(T,1,"variable `Main.CNC.BF4.startBackward`(t) must be boolean valued");
	if(j==12) SolverError(T,1,"variable `Main.CNC.BF4.startForward`(t) must be boolean valued");
	if(j==13) SolverError(T,1,"variable `Main.CNC.BF5.locked`(t) must be boolean valued");
	if(j==14) SolverError(T,1,"variable `Main.CNC.BF5.mode`(t) must be integer valued");
	if(j==15) SolverError(T,1,"variable `Main.CNC.BF5.startBackward`(t) must be boolean valued");
	if(j==16) SolverError(T,1,"variable `Main.CNC.BF5.startForward`(t) must be boolean valued");
}

static void InitEventModes(double *tval, double *y,
	M_INT *modes, M_INT *req, M_INT *inc)
{
	int i;

	for(i=0;i<NEVT;i++) {
		if(tval[i]>0.0)
			modes[i]=1;
		else if(tval[i]<0.0)
			modes[i]=0;
		else if(req[i]>0) {
			if(y[req[i]-1]==1.0)
				modes[i]=1;
			else
				modes[i]=0;
		}
		else if(inc[i])
			modes[i]=0;
		else
			modes[i]=1;
	}
}

static int ComputeEventIndicators(double *tval, double *y,
	M_INT *modes, M_INT *req, M_INT *inc, M_INT *ivl)
{
	int i;

	for(i=0;i<NEVT;i++) {
		if(req[i]>0) {
			/* Requires triggers - have an assoc. state variable, so we
				know the expected state */
			if(y[req[i]-1]==1.0)
				tval[i]+=FMUHYST;
			else
				tval[i]-=FMUHYST;
		}
		else if(inc[i]) {
			/* Increase-only trigger */
			if(modes[i]==0)
				tval[i]-=FMUHYST;
			else
				tval[i]+=FMUHYST;
		}
		else if(ivl[i]>0) {
			/* Integer-shift trigger */
			tval[i]-=FMUHYST;
		}
		else return(-1); /* Bad event */
	}
	return(0);
}

static int CheckEvents(double *tval, double *yt, M_INT *modes,
	M_INT *oldmodes, M_INT *req, M_INT *inc, M_INT *ivl)
{
	int i,flag;

	flag=0;
	for(i=0;i<NEVT;i++) {
		if(req[i]>0) {
			/* Requires triggers - have an assoc. state variable, so we
				do not need to rely on 'oldmodes' */
			if(yt[req[i]]==1.0) {
				/* Switch orig in '+' state */
				if( tval[i]<-EVTHYST ) {
					oldmodes[i]=1; modes[i]=0; flag=1;
				}
				else {
					oldmodes[i]=1; modes[i]=1;
				}
			}
			else {
				/* Switch orig in '-' state */
				if( tval[i]>EVTHYST ) {
					oldmodes[i]=0; modes[i]=1; flag=1;
				}
				else {
					oldmodes[i]=0; modes[i]=0;
				}
			}
		}
		else if(inc[i]) {
			/* Increase-only triggers */
			if(oldmodes[i]==0 && tval[i]>EVTHYST) {
				modes[i]=1; flag=1;
			}
			else if(oldmodes[i]==1 && tval[i]<-EVTHYST ) {
				oldmodes[i]=0; modes[i]=0;
			}
		}
		else if(ivl[i]>0) {
			/* Integer-shift trigger */
			if(tval[i]<-EVTHYST) {
				oldmodes[i]=1; modes[i]=0; flag=1;
			}
			else {
				oldmodes[i]=1; modes[i]=1;
			}
		}
		else return(-1); /* Bad event */
	}
	return(flag);
}

static int RunEvents(double *w, M_INT *modes, int first,
	int termvar, int maxiter, double *psto)
{
	double t,*y,*yp,*ypre,*tval;
	M_INT *m=NULL,*oldmodes,*inc,*req,*ivl;
	int i,flag,iter,evt,rc,failskip;

	/* Transfer data to approp. named arrays */
	t=w[0]; y=&w[1]; yp=&y[NEQ+NPAR]; ypre=&yp[NDFA]; tval=&ypre[NEQ];
	oldmodes=&modes[NEVT]; inc=&oldmodes[NEVT]; req=&inc[NEVT], ivl=&req[NEVT];
	/* Verify that no y values are undefined */
	for(i=0;i<NEQ;i++)
		if(IS_UNDEF(y[i])) {
			if (errorOccured<=0) {
				errorOccured = 1;
				sprintf(errorString,"undefined value encountered on entry into RunEvents at t=%f",t);
			}
			return(-3);
		}
	/* Set the old modes to the new and ypre to y */
	for(i=0;i<NEVT;i++) oldmodes[i]=modes[i];
	for(i=0;i<NEQ;i++) ypre[i]=y[i];

	if(first!=1) {
		/* Check for events */
		eev(t,y,ypre,tval);
		flag=CheckEvents(tval,y-1,modes,oldmodes,req,inc,ivl);
		if(flag<0) {
			if (errorOccured<=0) {
				errorOccured = 1;
				sprintf(errorString,"internal error: bad event at t=%f",t);

			}	
			return(-5);
		}
		/* If no events, return, but still need to update modes as we may
			have a sign change for a decrease on an increase-only trigger */
		if(!first && !flag) {
			if(m) for(i=0;i<NEVT;i++) m[i]=modes[i];
			return(0);
		}
	}

	/* Iteration loop */
	failskip=0;
	for(iter=0;;iter++) {
		if( first!=1 || iter>0 )
			/* Event loop */
			for(evt=0;evt<NEVT;evt++)
				if(modes[evt]!=oldmodes[evt]) {
					rc=eex(evt+1,t,y,ypre);
					if(termvar>=0 && y[termvar]>0.0) {
						i=(int)y[termvar];
						terminate(t,y,i);
						return(i);
					}
					/* Handle RC */
					oldmodes[evt]=modes[evt];
				}

		/* Discrete equations */
		rc=eex(NEVT+1,t,y,ypre);
		/* Fail skip */
		if(rc==8 && !failskip) {
			failskip=1;
			iter--;
			if(termvar>=0) y[termvar]=0.0;
		}
		else
			failskip=0;
		if(termvar>=0 && y[termvar]>0.0) {
			i=(int)y[termvar];
			terminate(t,y,i);
			return(i);
		}
		/* Handle RC */

		/* Check for termination */
		for(i=0;i<NEQ;i++) if(y[i]!=ypre[i]) break;
		if( !failskip && i==NEQ ) {
			/* Update modes and return */
			if(m) for(i=0;i<NEVT;i++) m[i]=modes[i];
			return(0);
		}

		/* Check iter limit */
		if( iter>=maxiter ) {
			if (errorOccured<=0) {
				errorOccured = 1;
				sprintf(errorString,"maximum number of event iterations reached (%li) at t=%f",(long)iter,t);
			}
			return(-1);
		}

		/* Update index-1 equations */
		if(!failskip && NIX1>0) {
			fp(NEQ,t,y,yp);
			if( IS_UNDEF(yp[0]) ) {
				if (errorOccured<=0) {
					errorOccured = 1;
					sprintf(errorString,"index-1 and derivative evaluation failure on event at t=%f",t);
				}
				return(-2);
			}
		}
		/* Verify that no y values are undefined */
		for(i=0;i<NEQ;i++)
			if(IS_UNDEF(y[i])) {
				if (errorOccured<=0) {
					errorOccured = 1;
					sprintf(errorString,"undefined value encountered during execution of RunEvents at t=%f",t);
				}
				return(-4);
			}

		/* Update pre */
		for(i=0;i<NEQ;i++) ypre[i]=y[i];
		if(failskip) continue;

		/* Evaluate event triggers, and update modes */
		eev(t,y,ypre,tval);
		flag=CheckEvents(tval,y-1,modes,oldmodes,req,inc,ivl);
		if(flag<0) {
			if (errorOccured<=0) {
				errorOccured = 1;
				sprintf(errorString,"internal error: bad event at t=%f",t);
			}
			return(-5);
		}
	}
	return(0);
}

static void numdiffinp(double *w, int initial, int commit)
{
	double dt1,dt2,idt1,idt2,idt12,*nd1,*nd2;

	if(!initial && !inputchange && !commit) return;
	inputchange=0;
	nd1=w+1+2*NEQ+NPAR+NDFA+NEVT;
	nd2=nd1+3;
	if(!initial && w[0]-nd1[0]>0.0) {
		dt1=w[0]-nd1[0]; idt1=1.0/dt1;
		if(nd1[0]-nd2[0]>0.0) {
			dt2=w[0]-nd2[0]; idt2=1.0/dt2;
			idt12=1.0/(nd2[0]-nd1[0]);
			w[29]=(idt1+idt2)*w[31]+idt12*(dt2*idt1*nd1[1]-dt1*idt2*nd2[1]);
			w[30]=(idt1+idt2)*w[32]+idt12*(dt2*idt1*nd1[2]-dt1*idt2*nd2[2]);
		}
		else {
			w[29]=idt1*(w[31]-nd1[1]);
			w[30]=idt1*(w[32]-nd1[2]);
		}
	}
	if(initial || (w[0]-nd1[0]>1e-10 && commit)) {
		nd2[0]=nd1[0]; nd1[0]=w[0];
		nd2[1]=nd1[1]; nd1[1]=w[31];
		nd2[2]=nd1[2]; nd1[2]=w[32];
	}
}

static void SolverUpdate(SolverStruct *S, int synced, int commit)
{
	numdiffinp(S->w,0,commit);
	if( synced ) return;
	fp(NEQ,S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
	if(IS_UNDEF(S->w[NEQ+NPAR+1])) {
		SolverError(S->w[0],0,"index-1 and derivative evaluation failure");
		return;
	}
	otp(S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
}

static int SolverProject(SolverStruct *S)
{
	int i;

	UNUSED(S);
	i=RunEvents(S->w,S->iw,0,49,EVTITER,S->psto);
	if(i) return(i);
	return(0);
}

static void SolverOutputs(SolverStruct *S)
{
	otp(S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
}

#define FMI_NUMJAC 0
#define MAXSTEP 10000
#define ABSTOLRAT 1e-4
#define ULP1 4.4e-16

void roscoeffs(
	double *a,
	double *b,
	double *dc,
	double *g
)
{
	b[0] = 193./125.;
	b[1] = 7168425121045566./7572185180509375.;
	b[2] = 3097946574948./12115496288815.;
	b[3] = 2826704902490126224060961974025706134278939822747197./852746296702892422902705641239753103493301898406250.;
	b[4] = 57296089482370846432889978335326559773356060131707./19783714083507104211342770876762272001044604043025.;
	b[5] = 1630708773901227845715117694694610159./1632926428426327554843233667421766335.;
	b[6] = 814403109013690485727600608739703696611830559180142744096971114136963./666874192960365525484569235055073332195209132046064560700547254000225.;
	b[7] = 517360702383696351268835737157978999421308136820625660070245244447100./85952673759336001062455590295987229482938065908159432268070534960029.;
	b[8] = 444717990749401371925669682937362301156074218629594826000./35472205062985048242866098360031149328289484499096833983.;
	b[9] = -353713672087343206323912170187500./514203884832009464116168657901409.;
	b[10] = 814403109013690485727600608739703696611830559180142744096971114136963./666874192960365525484569235055073332195209132046064560700547254000225.;
	b[11] = 517360702383696351268835737157978999421308136820625660070245244447100./85952673759336001062455590295987229482938065908159432268070534960029.;
	b[12] = 444717990749401371925669682937362301156074218629594826000./35472205062985048242866098360031149328289484499096833983.;
	b[13] = -353713672087343206323912170187500./514203884832009464116168657901409.;
	b[14] = 1.;

	a[0]=0.; a[1]=0.386; a[2]=0.210; a[3]=0.630; a[4]=1.; a[5]=1.;

	g[0] = -3543./625.;
	g[1] = -723173046876686234349347289976667./297590643932680090481699146996875.;
	g[2] = -687800738214338315711261460832./3333015212046017013395030446365.;
	g[3] = -1153126888946409153417335603042837049239764793762836586673587425263./10741459490054868792861199849460087291602908952180185181081415234375.;
	g[4] = -33473758646503600303986603626434107233995870479788111666577025378242./3488826042369821383921317711104636352312624827668124146815243668125.;
	g[5] = -64281675478222269454130753055939704322./3140243131589091451621603206580319875.;
	g[6] = 14997553755227844543543150024173215317574103841319656969970323038020016./2000622578881096576453707705165219996585627396138193682101641762000675.;
	g[7] = -2642220684996339487145744502497054137181455056198100387865532626277800./257858021278008003187366770887961688448814197724478296804211604880087.;
	g[8] = -3618154650221958075706015474724009821447904985805072193000./106416615188955144728598295080093447984868453497290501949.;
	g[9] = 18062299380030862642435769243500000./1542611654496028392348505973704227.;
	g[10] = 102419664987074146556446667468938413461391691717980726384311142453568012./12670609666246944984206815466046393311708973508875226653310397826004275.;
	g[11] = -13033994679103867104983584478310602279733501163170450847744495886824600./1633100801427384020186656215623757360175823252255029213093340164240551.;
	g[12] = -21244668700887057690455171227449340373200363552514151901000./673971896196715916614455868840591837237500205482839845677.;
	g[13] = 159437554759486277336225915561750000./9769873811808179818207204500126771.;
	g[14] = -70987236165144./11716350180329.;

	dc[0]=0.25; dc[1]=-0.1043; dc[2]=0.1035; dc[3]=-0.0362; dc[4]=0.; dc[5]=0.;
}

/* Degree 3 interpolant */
void interp(
	double xi,		/* Interpolation time */
	double xold,	/* Interval start time */
	double x,		/* Interval end time */
	double *yold,	/* Old solution */
	double *y,		/* Current solution */
	double *dyold,	/* Old derivative values */
	double *dy,	/* Current derivative values */
	double *yinterp/* Computed interp. values */
)
{
	int i;
	double h,tau1,tau2,t1,t2,t3,t4,t5,t6,t7,t8,t9;

	h=x-xold;
	tau1=xi-xold;
	tau2=x-xi;

	t1=h*h*h;
	t1=1.0/t1;
	t2=h*t1;
	t3=tau1*tau1;
	t4=tau2*tau2;
	t5=t3*(3*tau2+tau1)*t1;
	t6=t4*(tau2+3*tau1)*t1;
	t7=-t3*tau2*t2;
	t8=t4*tau1*t2;
	t9=tau1*h*t2;

	for(i=0;i<NDIFF;i++)
		yinterp[i]=t5*y[i]+t6*yold[i]+t7*dy[i]+t8*dyold[i];
	/* Linear approx. for ix1 vars */
	for(i=NDIFF;i<NDIFF+NIX1;i++)
		yinterp[i]=y[i]+t9*(y[i]-yold[i]);
	/* Copy old values for discretes */
	for(i=NDIFF+NIX1;i<NEQ+NPAR;i++)
		yinterp[i]=yold[i];
}

#if NEVT>0
/* Modified bisection root-finder for event detection */
double findroot(
	double x0,			/* Interval start time */
	double x1,			/* Interval end time */
	double *y0,		/* Old solution */
	double *y1,		/* Current solution */
	double *dy0,		/* Old derivative values */
	double *dy1,		/* Current derivative values */
	double ye0,		/* Old event value */
	double ye1,		/* Current event value */
	int evti,		/* Event index */
	double *yinterp,	/* Interpol. storage */
	double *yevtst,	/* Event eval. storage */
	double *ytemp		/* Temp. storage */
)
{
	int i;
	double eps,fac,sl,xh,xl,xm,yem;

	/* Bisection loop */
	xl=x0; xh=x1;
	fac=1.0;
	for(i=0;i<100;i++) {
		sl=ye0-ye1;
		xm=(xh*ye0-xl*ye1)/sl;
		eps=1e-6*(xh-xl);
		if( eps<1.5*fac*ULP1*fabs(xm) ) eps=1.5*fac*ULP1*fabs(xm);
		if( xh-xm < xm-xl ) xm-=eps;
		else xm+=eps;
		interp(xm,x0,x1,y0,y1,dy0,dy1,yinterp);
#if NIX1>0
		fp(NEQ,xm,yinterp,ytemp);
		if(IS_UNDEF(ytemp[0])) {
			SolverError(x0,1,"index-1 and derivative evaluation failure");
			return(-1);
		}
#endif
		eev(xm,yinterp,yinterp,yevtst);
		yem=yevtst[evti];
		if( yem*ye0==0.0 ) {
			fac=fac*2.0;
		}
		else if( yem*ye0>0.0 ) {
			/* We're on the left */
			fac=1.0;
			xl=xm;
			ye0=yem;
		}
		else {
			fac=1.0;
			xh=xm;
			ye1=yem;
		}
		/* Termination criteria */
		if( xh-xl<4.00001*fac*ULP1*fabs(xh) ) return(xh);
	}
	SolverError(x0,1,"event detection error");
	return(*dsn_undef);
}
#endif

/* Main integration routine */
int Integrate(
	double *w,		/* Initial solution */
	M_INT *iw,	/* Event modes */
	double xend,	/* End time */
	double tol,	/* Tolerance limit for iteration */
	double *hinit,/* Initial stepsize */
	double *psto  /* Projection storage */
)
{
	int i,j,nstep,numstep,halfnsteps,fixedstep,last;
	M_INT ip[NDFA];
	double *y,yold[NEQ+NPAR],dy[NDFA],yerr[NEQ+NPAR],yscal[NDFA],ytemp[NEQ+NPAR],
			a[6],b[15],dc[6],g[15],
			ak0[NDIFF],ak1[NDIFF],ak2[NDIFF],ak3[NDIFF],ak4[NDIFF],ak5[NDIFF],
			dytemp[NDFA],ft[NDFA],fy[NDFA*NDFA],Jc[NDFA*NDFA],mfac,
			eps,errmax,h,hnext,htemp,x,xnew,xstart,xhalf,
			SAFETY,PGROW,PSHRNK,SHRNK,ERRCON;
#if NEVT>0
  #if NCON>0
	int change;
  #endif
	double dyold[NDFA],yevt[NEVT],yevtold[NEVT],yevtst[NEVT],yinterp[NEQ+NPAR];
	double evtpt,pt,xold;
	int evti,numevt=0;
#else
  #if NCON>0
	int change;
  #endif
#endif
	double delta,jtol=1e-7;
	int numjac;

	/* Transfer data */
	xstart=w[0];
	y=&w[1];
	xhalf=(xend+xstart)/2;
	numstep=0;
	fixedstep=0;
	last=0;
	halfnsteps=(MAXINTSTEP>0) ? (MAXINTSTEP+1)/2 : 0;
	/* Don't allow for backward integration */
	if( (xend-xstart)<0. || *hinit<0. ) {
		SolverError(xstart,1,"backward integration is not supported");
		return(-1);
	}
	x=xstart;
	h=*hinit;
	/* Get the method coefficients */
	roscoeffs(a,b,dc,g);
	SAFETY=0.9;
	PGROW=-0.25;
	PSHRNK=-1./3.;
	SHRNK=0.2;
	ERRCON=0.1296;

	for(nstep=0;nstep<MAXSTEP;nstep++) {
		/* Populate derivative vector */
		fp(NEQ,x,y,dy);
		if(IS_UNDEF(dy[0])) {
			SolverError(x,1,"index-1 and derivative evaluation failure");
			return(-1);
		}
		/* Make copies at start of integration step */
#if NEVT>0
		xold=x;
		for(i=0;i<NDIFF;i++) dyold[i]=dy[i];
#endif
		for(i=0;i<NEQ+NPAR;i++) yold[i]=y[i];
		for(i=NDIFF;i<NEQ+NPAR;i++) ytemp[i]=y[i];
		for(i=0;i<NDIFF;i++) dytemp[i]=dy[i];
		/* Get a Jacobian for stiff solver */
		numjac=FMI_NUMJAC;
#if FMI_NUMJAC==0
		if( !numjac ) {
			Dfp(x,y,ft,fy);
			if(IS_UNDEF(ft[0])) numjac=1;
		}
#endif
		if(numjac) {
			/* If numeric jacobian is requested, or symbolic failed, go numeric */
			for(i=0;i<NEQ+NPAR;i++) ytemp[i]=y[i];
			for(i=0;i<NDIFF;i++) {
				delta=jtol*(1.0+fabs(ytemp[i]));
				delta=(dy[i]<0.0 ? -delta : delta);
				ytemp[i]+=delta;
				fp(NEQ,x,ytemp,ft);
				if(IS_UNDEF(ft[0])) {
					SolverError(x,1,"index-1 and derivative evaluation failure");
					return(-1);
				}
				ytemp[i]=y[i];
				for(j=0;j<NDIFF;j++) fy[j*NDIFF+i]=(ft[j]-dy[j])/delta;
			}
			delta=jtol*(1.0+fabs(x));
			fp(NEQ,x+delta,ytemp,ft);
			if(IS_UNDEF(ft[0])) {
				SolverError(x,1,"index-1 and derivative evaluation failure");
				return(-1);
			}
			for(i=0;i<NDIFF;i++) ft[i]=(ft[i]-dy[i])/delta;
		}
		/* Decrease stepsize if it overshoots */
		if( x+h>xend ) {
			last=1;
			h=xend-x;
			if( x+h<xend ) {
				if(h>0.) {
					eps=1e-16*h;
					while( x+h<xend ) {
						h += eps;
						eps *= 2.;
					}
				}
				else h=ULP1*xend;
			}
		}
		else if( xend-x-h < h/1000. ) {
			h=xend-x+ULP1;
		}
		for(i=0;i<NDIFF;i++)
			yscal[i] = fabs(y[i])+fabs(dy[i]*h)+ABSTOLRAT;
		/* Take a step */
		while(1) {
			/* Compute the stages */
			/* Invert the Jacobian matrix */
			mfac=4./h;
			for(i=0;i<NDIFF;i++) {
				for(j=0;j<NDIFF;j++)
					Jc[i*NDIFF+j] = -fy[i*NDIFF+j];
				Jc[i*(NDIFF+1)] += mfac;
			}
			DecompCInc(NDIFF,Jc,NDIFF,ip);
			if( ip[NDIFF-1]==0 ) {
				SolverError(x,1,"Jacobian computation failure");
				return(-1);
			}
			/* Stage 1 */
			for(i=0;i<NDIFF;i++) y[i] = yold[i];
			fp(NEQ, x+a[0]*h, y, dytemp);
			if(IS_UNDEF(dytemp[0])) {
				SolverError(x,1,"index-1 and derivative evaluation failure");
				return(-1);
			}
			for(i=0;i<NDIFF;i++)
				ak0[i] = dytemp[i] + dc[0]*h*ft[i];
			SolveCInc(NDIFF,Jc,NDIFF,ip,ak0);
			/* Stage 2 */
			for(i=0;i<NDIFF;i++) y[i] = yold[i]+b[0]*ak0[i];
			fp(NEQ, x+a[1]*h, y, dytemp);
			if(IS_UNDEF(dytemp[0])) {
				SolverError(x,1,"index-1 and derivative evaluation failure");
				return(-1);
			}
			for(i=0;i<NDIFF;i++)
				ak1[i] = dytemp[i] + dc[1]*h*ft[i] + g[0]*ak0[i]/h;
			SolveCInc(NDIFF,Jc,NDIFF,ip,ak1);
			/* Stage 3 */
			for(i=0;i<NDIFF;i++) y[i] = yold[i]+b[1]*ak0[i]+b[2]*ak1[i];
			fp(NEQ, x+a[2]*h, y, dytemp);
			if(IS_UNDEF(dytemp[0])) {
				SolverError(x,1,"index-1 and derivative evaluation failure");
				return(-1);
			}
			for(i=0;i<NDIFF;i++)
				ak2[i] = dytemp[i] + dc[2]*h*ft[i] + (g[1]*ak0[i]+g[2]*ak1[i])/h;
			SolveCInc(NDIFF,Jc,NDIFF,ip,ak2);
			/* Stage 4 */
			for(i=0;i<NDIFF;i++) y[i] = yold[i]+b[3]*ak0[i]+b[4]*ak1[i]+b[5]*ak2[i];
			fp(NEQ, x+a[3]*h, y, dytemp);
			if(IS_UNDEF(dytemp[0])) {
				SolverError(x,1,"index-1 and derivative evaluation failure");
				return(-1);
			}
			for(i=0;i<NDIFF;i++)
				ak3[i] = dytemp[i] + dc[3]*h*ft[i] + (g[3]*ak0[i]+g[4]*ak1[i]+g[5]*ak2[i])/h;
			SolveCInc(NDIFF,Jc,NDIFF,ip,ak3);
			/* Stage 5 */
			for(i=0;i<NDIFF;i++) y[i] = yold[i]+b[6]*ak0[i]+b[7]*ak1[i]+b[8]*ak2[i]+b[9]*ak3[i];
			fp(NEQ, x+a[4]*h, y, dytemp);
			if(IS_UNDEF(dytemp[0])) {
				SolverError(x,1,"index-1 and derivative evaluation failure");
				return(-1);
			}
			for(i=0;i<NDIFF;i++)
				ak4[i] = dytemp[i] + dc[4]*h*ft[i] + (g[6]*ak0[i]+g[7]*ak1[i]+g[8]*ak2[i]+g[9]*ak3[i])/h;
			SolveCInc(NDIFF,Jc,NDIFF,ip,ak4);
			/* Stage 6 */
			for(i=0;i<NDIFF;i++) y[i] = yold[i]+b[10]*ak0[i]+b[11]*ak1[i]+b[12]*ak2[i]+b[13]*ak3[i]+b[14]*ak4[i];
			fp(NEQ, x+a[5]*h, y, dytemp);
			if(IS_UNDEF(dytemp[0])) {
				SolverError(x,1,"index-1 and derivative evaluation failure");
				return(-1);
			}
			for(i=0;i<NDIFF;i++)
				ak5[i] = dytemp[i] + dc[5]*h*ft[i] + (g[10]*ak0[i]+g[11]*ak1[i]+g[12]*ak2[i]+g[13]*ak3[i]+g[14]*ak4[i])/h;
			SolveCInc(NDIFF,Jc,NDIFF,ip,ak5);
			/* Update y and compute error estimate */
			for(i=0;i<NDIFF;i++) y[i] += ak5[i];
			fp(NEQ, x+h, y, dy);
			if(IS_UNDEF(dy[0])) {
				SolverError(x,1,"index-1 and derivative evaluation failure");
				return(-1);
			}
			/* Error estimate */
			for(i=0;i<NDIFF;i++) yerr[i] = ak5[i];

			numstep++;
			if( MAXINTSTEP>0 && !fixedstep ) {
				if(numstep>halfnsteps && x<xhalf) {
					/* We're not half-way through integration but have used up
					more than half of the allowed integration points, go fixed-step */
					h=(xend-x)/halfnsteps;
					hnext=h;
					fixedstep=1;
					SolverWarning(x,"Integrator has reached the specified integration step limit");
				}
			}
			if(fixedstep) break;
			errmax=0.0;
			for(i=0;i<NDIFF;i++) errmax=max(errmax,fabs(yerr[i]/yscal[i]));
			errmax /= tol;
			if( errmax<=1.0 ) break;
			htemp=SAFETY*h*pow(errmax,PSHRNK);
			/* Truncation error too large, reduce stepsize */
			h=max(htemp,SHRNK*h);
			xnew=x+h;
			if( xnew==x ) {
				SolverError(x,1,"stepsize underflow in integrate");
				return(-1);
			}
		}
		if(!fixedstep) {
			if( errmax>ERRCON ) hnext=SAFETY*h*pow(errmax,PGROW);
			else hnext=2.0*h;
			if(!last) *hinit=hnext;
		}
		x += h;
		w[0]=x;
#if NEVT>0
		if( MAXNEVT==0 || numevt<MAXNEVT ) {
			fp(NEQ,x,y,dy);
			if(IS_UNDEF(dy[0])) {
				SolverError(x,1,"index-1 and derivative evaluation failure");
				return(-1);
			}
			/* Do event detection with interpolation */
			eev(xold,yold,yold,yevtold);
			eev(x,y,y,yevt);
			evtpt=x+0.1;
			evti=NEVT+1;
			for(i=0;i<NEVT;i++) {
				if( yevt[i]*yevtold[i]<0.0 ||
					(yevtold[i]==0.0 && yevt[i]!=0.0) ) {
					/* Root is bracketed between xold and x */
					pt=findroot(xold,x,yold,y,dyold,dy,yevtold[i],yevt[i],i,yinterp,yevtst,ytemp);
					if(IS_UNDEF(pt)) {
						SolverError(x,1,"event point detection failure");
						return(-1);
					}
					if( pt<evtpt ) {
						evtpt=pt;
						evti=i;
					}
				}
			}
			if( evti<=NEVT ) {
				x=evtpt;
				w[0]=x;
				interp(x,xold,x,yold,y,dyold,dy,yinterp);
				for(i=0;i<NEQ+NPAR;i++) y[i]=yinterp[i];
				fp(NEQ,x,y,dy);
				if(IS_UNDEF(dy[0])) {
					SolverError(x,1,"index-1 and derivative evaluation failure");
					return(-1);
				}
				i=RunEvents(w,iw,0,49,EVTITER,psto);
				if(i>0 || i<0) {
					SolverError(x,1,"event failure");
					return(-1);
				}
				numevt++;
			}
		}
		if( MAXNEVT>0 && MAXNEVT <= numevt)
			SolverWarning(x,"Integrator has reached the specified event limit");
#endif
#if NCON>0
		/* Perform projection step */
		for(i=0;i<NDIFF+NIX1;i++) ytemp[i]=y[i];
		i=Projection(x,y,CONTOL,CONITER,NULL,psto);
		if(i>0 && i!=3) {
			SolverError(x,1,"constraint projection failure");
			return(-1);
		}
#endif
		/* Are we done? */
		if( x>=xend ) {
			fp(NEQ,x,y,dy);
			if(IS_UNDEF(dy[0])) {
				SolverError(x,1,"index-1 and derivative evaluation failure");
				return(-1);
			}
			return(1);
		}
		h=hnext;
	}
	SolverError(x,1,"too many steps in integrate");
	return(-1);
}

static void SolverSetup(SolverStruct *S)
{
	int i;

	S->w[0] =  0.00000000000000000e+00;
	S->w[1] =  0.00000000000000000e+00;
	S->w[2] =  0.00000000000000000e+00;
	S->w[3] =  0.00000000000000000e+00;
	S->w[4] =  0.00000000000000000e+00;
	S->w[5] =  0.00000000000000000e+00;
	S->w[6] =  0.00000000000000000e+00;
	S->w[7] =  0.00000000000000000e+00;
	S->w[8] =  0.00000000000000000e+00;
	S->w[9] =  1.01000000000000000e+00;
	S->w[10] = -0.00000000000000000e+00;
	S->w[11] =  1.00298245614035090e+00;
	S->w[12] = -5.00000000000000030e-02;
	S->w[13] = -1.00000000000000000e-02;
	S->w[14] =  1.00298245614035090e+00;
	S->w[15] = -1.01000000000000000e+00;
	S->w[16] =  1.00000000000000000e-02;
	S->w[17] =  0.00000000000000000e+00;
	S->w[18] =  0.00000000000000000e+00;
	S->w[19] = -8.67361737988403550e-18;
	S->w[20] = -0.00000000000000000e+00;
	S->w[21] = -0.00000000000000000e+00;
	S->w[22] =  0.00000000000000000e+00;
	S->w[23] =  0.00000000000000000e+00;
	S->w[24] =  0.00000000000000000e+00;
	S->w[25] =  0.00000000000000000e+00;
	S->w[26] =  0.00000000000000000e+00;
	S->w[27] =  1.00000000000000000e+00;
	S->w[28] = -1.00000000000000000e+00;
	S->w[29] =  0.00000000000000000e+00;
	S->w[30] =  0.00000000000000000e+00;
	S->w[31] =  1.00000000000000000e+00;
	S->w[32] =  1.00000000000000000e+00;
	S->w[33] =  1.00000000000000000e+00;
	S->w[34] =  3.00000000000000000e+00;
	S->w[35] =  1.00000000000000000e+00;
	S->w[36] =  3.00000000000000000e+00;
	S->w[37] =  1.00000000000000000e+00;
	S->w[38] =  3.00000000000000000e+00;
	S->w[39] =  1.00000000000000000e+00;
	S->w[40] =  3.00000000000000000e+00;
	S->w[41] =  0.00000000000000000e+00;
	S->w[42] =  0.00000000000000000e+00;
	S->w[43] =  0.00000000000000000e+00;
	S->w[44] =  0.00000000000000000e+00;
	S->w[45] =  0.00000000000000000e+00;
	S->w[46] =  0.00000000000000000e+00;
	S->w[47] =  0.00000000000000000e+00;
	S->w[48] =  0.00000000000000000e+00;
	S->w[49] =  1.00000000000000000e+00;
	S->w[50] =  0.00000000000000000e+00;
	S->w[51] =  0.00000000000000000e+00;
	S->w[52] =  0.00000000000000000e+00;
	S->w[53] =  0.00000000000000000e+00;
	S->w[54] =  1.00000000000000000e+00;
	S->w[55] =  0.00000000000000000e+00;
	S->w[56] =  0.00000000000000000e+00;
	S->w[57] =  0.00000000000000000e+00;
	S->w[58] =  1.00000000000000000e+00;
	S->w[59] =  0.00000000000000000e+00;
	S->w[60] =  1.00000000000000000e+00;
	S->w[61] =  0.00000000000000000e+00;
	S->w[62] =  1.00000000000000000e+00;
	S->w[63] =  0.00000000000000000e+00;
	S->w[64] =  0.00000000000000000e+00;
	S->w[65] =  0.00000000000000000e+00;
	S->w[66] =  0.00000000000000000e+00;
	S->w[67] =  0.00000000000000000e+00;
	S->w[68] =  0.00000000000000000e+00;
	S->w[69] =  0.00000000000000000e+00;
	S->w[70] =  0.00000000000000000e+00;
	S->w[71] =  0.00000000000000000e+00;
	S->w[72] =  1.00000000000000000e+00;
	for(i=0;i<NDIFF;i++) S->w[i+NEQ+NPAR+1]=0.0;
	S->iw[2*NEVT+0] = 0; S->iw[3*NEVT+0] = 51; S->iw[4*NEVT+0] = 0;
	S->iw[2*NEVT+1] = 0; S->iw[3*NEVT+1] = 52; S->iw[4*NEVT+1] = 0;
	S->iw[2*NEVT+2] = 0; S->iw[3*NEVT+2] = 53; S->iw[4*NEVT+2] = 0;
	S->iw[2*NEVT+3] = 0; S->iw[3*NEVT+3] = 54; S->iw[4*NEVT+3] = 0;
	S->iw[2*NEVT+4] = 0; S->iw[3*NEVT+4] = 55; S->iw[4*NEVT+4] = 0;
	S->iw[2*NEVT+5] = 0; S->iw[3*NEVT+5] = 56; S->iw[4*NEVT+5] = 0;
	S->iw[2*NEVT+6] = 0; S->iw[3*NEVT+6] = 57; S->iw[4*NEVT+6] = 0;
	S->iw[2*NEVT+7] = 0; S->iw[3*NEVT+7] = 58; S->iw[4*NEVT+7] = 0;
	S->iw[2*NEVT+8] = 0; S->iw[3*NEVT+8] = 59; S->iw[4*NEVT+8] = 0;
	S->iw[2*NEVT+9] = 0; S->iw[3*NEVT+9] = 60; S->iw[4*NEVT+9] = 0;
	S->iw[2*NEVT+10] = 0; S->iw[3*NEVT+10] = 61; S->iw[4*NEVT+10] = 0;
	S->iw[2*NEVT+11] = 0; S->iw[3*NEVT+11] = 62; S->iw[4*NEVT+11] = 0;
	S->iw[2*NEVT+12] = 0; S->iw[3*NEVT+12] = 63; S->iw[4*NEVT+12] = 0;
	S->iw[2*NEVT+13] = 0; S->iw[3*NEVT+13] = 64; S->iw[4*NEVT+13] = 0;
	S->iw[2*NEVT+14] = 0; S->iw[3*NEVT+14] = 65; S->iw[4*NEVT+14] = 0;
	S->iw[2*NEVT+15] = 0; S->iw[3*NEVT+15] = 66; S->iw[4*NEVT+15] = 0;
	S->iw[2*NEVT+16] = 0; S->iw[3*NEVT+16] = 67; S->iw[4*NEVT+16] = 0;
	S->iw[2*NEVT+17] = 0; S->iw[3*NEVT+17] = 68; S->iw[4*NEVT+17] = 0;
	S->iw[2*NEVT+18] = 0; S->iw[3*NEVT+18] = 69; S->iw[4*NEVT+18] = 0;
	S->iw[2*NEVT+19] = 0; S->iw[3*NEVT+19] = 70; S->iw[4*NEVT+19] = 0;
	S->iw[2*NEVT+20] = 0; S->iw[3*NEVT+20] = 71; S->iw[4*NEVT+20] = 0;
	S->iw[2*NEVT+21] = 0; S->iw[3*NEVT+21] = 72; S->iw[4*NEVT+21] = 0;
	eev(S->w[0],&S->w[1],&S->w[1],&S->w[2*NEQ+NPAR+NDFA+1]);
	InitEventModes(&S->w[2*NEQ+NPAR+NDFA+1],&S->w[1],S->iw,&S->iw[3*NEVT],&S->iw[2*NEVT]);
}

static void SolverInitialize(SolverStruct *S)
{
	int i;

	UNUSED(i);
	numdiffinp(S->w,1,1);
	numdiffinp(S->w,1,1);

	eev(S->w[0],&S->w[1],&S->w[1],&S->w[2*NEQ+NPAR+NDFA+1]);
	i=RunEvents(S->w,S->iw,2,49,EVTITER,S->psto);
	if (i<0) {
		SolverError(S->w[0],0,"error running events");
		return;
	}
	else if (i>0) {
		SolverError(S->w[0],1,"error running events");
		return;
	}
	i=cpr(S->w[0],&S->w[1]);
	S->w[NEQ+NPAR+1]=0.0;
	fp(NEQ,S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
	if(IS_UNDEF(S->w[NEQ+NPAR+1])) {
		SolverError(S->w[0],0,"index-1 and derivative evaluation failure");
		return;
	}
	i=RunEvents(S->w,S->iw,0,49,EVTITER,S->psto);
	if (i<0) {
		SolverError(S->w[0],0,"error running events");
		return;
	}
	else if (i>0) {
		SolverError(S->w[0],1,"error running events");
		return;
	}
	SolverOutputs(S);
}

/*****************************************************************************/
/* FILE fmuTemplate.c */
/*****************************************************************************/


#define FMI2_COSIMULATION
#define MODEL_GUID "{0f3398f8-206d-0d3a-c8cf-c7c7b11e43f1}"
#ifndef DISABLE_PREFIX
    #define FMI2_FUNCTION_PREFIX CNC_FMU_
#endif



/* define model size */
#define NUMBER_OF_REALS 184
#define NUMBER_OF_INTEGERS 5*NEVT
#define NUMBER_OF_BOOLEANS 0
#define NUMBER_OF_STRINGS 1

/* include FMU header files, typedefs and macros */
#include "fmuTemplate.h"

/* define initial state vector and derivative vector as vectors of value references */
#define STATES {1, 2, 3, 4, 5, 6, 7, 8}
#define DERS   {73, 74, 75, 76, 77, 78, 79, 80}
#define OUTS   {25, 26, 2, 4, 27, 28}

#ifdef FMI2_PROVIDES_DERIVATIVES
#define NIKNO 0
#define NIUNK 0
#define IKNOS { }
#define IUNKS { }
#endif

/*****************************************************************************/

#if NDIFF>0
fmi2ValueReference vrStates[NDIFF] = STATES;
fmi2ValueReference   vrDers[NDIFF] = DERS;
#else
fmi2ValueReference *vrStates = NULL;
fmi2ValueReference   *vrDers = NULL;
#endif

#if NOUT>0
fmi2ValueReference   vrOuts[NOUT] = OUTS;
#else
fmi2ValueReference   *vrOuts = NULL;
#endif

#ifdef FMI2_PROVIDES_DERIVATIVES
#if NIKNO>0
fmi2ValueReference   vrIknowns[NIKNO] = IKNOS;
#else
fmi2ValueReference   *vrIknowns = NULL;
#endif
#if NIUNK>0
fmi2ValueReference   vrIunknowns[NIUNK] = IUNKS;
#else
fmi2ValueReference   *vrIunknowns = NULL;
#endif
#endif

/*****************************************************************************
 * BEGIN: Private functions
 *****************************************************************************/
/*****************************************************************************/
static fmi2Boolean invalidNumber(ModelInstance*	comp,
								 const char*	f,
								 const char*	arg,
								 int			n,
								 int			nExpected) {
	if (n != nExpected) {
		comp->state = modelError;
		compLog(compEnv, comp->instanceName, fmi2Error,
			"error", "[%s]: Invalid argument %s = %d. Expected %d.",
			f, arg, n, nExpected);
		return fmi2True;
	}
	return fmi2False;
}
/*****************************************************************************/
static fmi2Boolean invalidState(ModelInstance*	comp,
								const char*		f,
								int				statesExpected) {
	if (!comp) return fmi2True;
	if (!(comp->state && statesExpected)) {
		comp->state = modelError;
		compLog(compEnv, comp->instanceName, fmi2Error,
			"error", "[%s]: Illegal call sequence.", f);
		return fmi2True;
	}
	return fmi2False;
}
/*****************************************************************************/
static fmi2Boolean nullPointer(	ModelInstance*	comp,
								const char*		f,
								const char*		arg,
								const void*		p) {
	if (!p) {
		comp->state = modelError;
		compLog(compEnv, comp->instanceName, fmi2Error,
			"error", "[%s]: Invalid argument %s = NULL.", f, arg);
		return fmi2True;
	}
	return fmi2False;
}
/*****************************************************************************/
static fmi2Boolean vrOutOfRange(ModelInstance*		comp,
								const char*			f,
								fmi2ValueReference	vr,
								int					end) {
	if ((int)vr >= end) {
		comp->state = modelError;
		compLog(compEnv, comp->instanceName, fmi2Error,
			"error", "[%s]: Illegal value reference %u.", f, vr);
		return fmi2True;
	}
	return fmi2False;
}
/*****************************************************************************/
void logMessage(ModelInstance*	comp,
				const char*		f,
				const char*		e,
				fmi2Status		value) {
	compLog(compEnv, comp->instanceName, value,
			e, "[%s]: %s", f, errorString);
}
/*****************************************************************************/
void logWarning(ModelInstance*	comp,
				const char*		f,
				const char*		e,
				fmi2Status		value) {
	compLog(compEnv, comp->instanceName, value,
			e, "[%s]: %s", f, warningString);
}
/*****************************************************************************/
static void setVidError(ModelInstance *comp, char *errstr)
{
	if (errstr)
		strcpy(comp->viderror,errstr);
	else if (errorOccured)
		strcpy(comp->viderror,errorString);
	else
		strcpy(comp->viderror,"unknown error");
	comp->vidsts = -1;
}
/*****************************************************************************/
fmi2Status syncModel(ModelInstance *c, const char *f)
{
	ModelInstance* comp = (ModelInstance *)c;
	int i;

	if (comp->state==modelInitialized && !comp->synced) {
		if(comp->initializeMode) {
			if(comp->S.wset) {
				SolverSetup(&(comp->S));
				for(i=0;i<NUMBER_OF_REALS;i++)
					if(!IS_UNDEF(comp->S.wset[i]))
						comp->S.w[i]=comp->S.wset[i];
			}
			SolverInitialize(&(comp->S));
			if (errorOccured>0) {
				setVidError(comp,NULL);
				if (comp->fptr) {
					writeErrorToFile(comp->fptr, NULL);
					comp->fptr = NULL;
				}
				comp->state = modelTerminated;
				logMessage(comp, f, "error", fmi2Error);
				return fmi2Error;
			}
			else if(errorOccured<0) {
				logMessage(comp, f, "warning", fmi2Warning);
				errorOccured=0;
			}
		}
		else {
			if(comp->fmuType==fmi2ModelExchange && comp->S.wset)
				for(i=NDIFF+1;i<=NDIFF+NIX1-NINP-NINPD;i++)
					comp->S.w[i]=comp->S.wset[i];
			SolverUpdate(&(comp->S),0,0);
			if(errorOccured>0) {
				setVidError(comp,NULL);
				if (comp->fptr) {
					writeErrorToFile(comp->fptr,NULL);
					comp->fptr = NULL;
				}
				errorOccured=0;
				logMessage(comp, f, "error", fmi2Error);
				return fmi2Discard;
			}
			else if(errorOccured<0) {
				logMessage(comp, f, "warning", fmi2Warning);
				errorOccured=0;
			}
		}
		if(inputchange) inputchange=0;
		comp->synced = fmi2True;
		comp->jsynced = fmi2False;
	}
	return fmi2OK;
}

/*****************************************************************************
 * END: Private functions
 *****************************************************************************/
/*****************************************************************************
 * Common functions: for FMI Model Exchange 2.0 and for FMI Co-Simulation 2.0
 *****************************************************************************/
/*****************************************************************************/
/* BEGIN: fmi2GetTypesPlatform */
const char* fmi2GetTypesPlatform() {
	return fmi2TypesPlatform;
}
/* END: fmi2GetTypesPlatform */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetVersion */
const char* fmi2GetVersion() {
	return fmi2Version;
}
/* END: fmi2GetVersion */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetDebugLogging */
fmi2Status fmi2SetDebugLogging(	fmi2Component	c,
								fmi2Boolean		loggingOn,
								size_t			nCategories,
								const fmi2String categories[]) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2SetDebugLogging", not_modelError))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK,
			"log", "fmi2SetDebugLogging: loggingOn = %d", loggingOn);
	if(nCategories>0 && categories!=NULL)
		/* No support for separate logging categories at this time */
		comp->loggingOn = fmi2True;
	else
		comp->loggingOn = loggingOn;
	return fmi2OK;
}
/* END: fmi2SetDebugLogging */
/*****************************************************************************/

static char nameME[] = "ModelExchange";
static char nameCS[] = "CoSimulation";
static char binfile[] = "DISABLED";

/*****************************************************************************/
/* BEGIN: fmi2Instantiate */
fmi2Component fmi2Instantiate(	fmi2String					instanceName,
								fmi2Type					fmuType,
								fmi2String					GUID,
								fmi2String					fmuLocation,
								const fmi2CallbackFunctions* functions,
								fmi2Boolean					visible,
								fmi2Boolean					loggingOn) {
	ModelInstance* comp;
	char * fname;
	fmi2String iname;
	int i;

	UNUSED(fmuLocation);
	UNUSED(visible);
	if (fmuType==fmi2ModelExchange)
		fname = nameME;
	else
		fname = nameCS;

	if (!functions->logger)
		return NULL;
	if (!functions->allocateMemory || !functions->freeMemory) {
		functions->logger(NULL, instanceName, fmi2Error,
				"error", "[%s]: Callback function is not found.", fname);
		return NULL;
	}
	if (!instanceName || strlen(instanceName)==0) {
		functions->logger(NULL, instanceName, fmi2Error,
				"error", "[%s]: Instance name is not found.", fname);
		return NULL;
	}
	if (strcmp(GUID, MODEL_GUID)) {
		functions->logger(NULL, instanceName, fmi2Error,
				"error", "[%s]: Inconsistent GUID %s. Expected %s.",
				fname, GUID, MODEL_GUID);
		return NULL;
	}

	comp = (ModelInstance *)functions->allocateMemory(1,sizeof(ModelInstance));

	iname = functions->allocateMemory(strlen((char*)instanceName) + 1,sizeof(char));
	if (!iname)
		functions->logger(NULL, instanceName, fmi2Error,
				"error", "[%s]: Cannot allocate memory.", fname);
	strcpy((char*)iname, (char*)instanceName);

	if (comp) {
		comp->S.w = functions->allocateMemory(NUMBER_OF_REALS,sizeof(fmi2Real));
		if (fmuType==fmi2ModelExchange)
			comp->S.wset = functions->allocateMemory(NUMBER_OF_REALS,sizeof(fmi2Real));
		else
			comp->S.wset = NULL;
		if(NCON>0)
			comp->S.psto = functions->allocateMemory(NDIFF*(1+NCON+2*NDIFF),sizeof(fmi2Real));
		else
			comp->S.psto = NULL;
		if(SSTO>0)
			comp->S.ssto = functions->allocateMemory(NDFA*(NDFA+1),sizeof(fmi2Real));
		else
			comp->S.ssto = NULL;
#ifdef FMI2_PROVIDES_DERIVATIVES
		if( (1+NDIFF+NINP)*(NDIFF+NOUT)>0 ) {
			comp->Jacobian = functions->allocateMemory((1+NDIFF+NINP)*(NDIFF+NOUT),sizeof(fmi2Real));
			if (!comp->Jacobian) {
				functions->logger(NULL, instanceName, fmi2Error,
						"error", "[%s]: Cannot allocate memory.", fname);
				return NULL;
			}
		}
		else
			comp->Jacobian = NULL;

		if( NIUNK*NIKNO>0 ) {
			comp->initJacobian = functions->allocateMemory(NIUNK*NIKNO,sizeof(fmi2Real));
			if (!comp->initJacobian) {
				functions->logger(NULL, instanceName, fmi2Error,
						"error", "[%s]: Cannot allocate memory.", fname);
				return NULL;
			}
		}
		else
			comp->initJacobian = NULL;

		if( NIUNK>0 ) {
			comp->initRes = functions->allocateMemory(NIUNK,sizeof(fmi2Real));
			if (!comp->initRes) {
				functions->logger(NULL, instanceName, fmi2Error,
						"error", "[%s]: Cannot allocate memory.", fname);
				return NULL;
			}
		}
		else
			comp->initRes = NULL;

#else
		comp->Jacobian = NULL;
		comp->initJacobian = NULL;
		comp->initRes = NULL;
#endif
		if (NUMBER_OF_INTEGERS > 0)
			comp->S.iw = functions->allocateMemory(NUMBER_OF_INTEGERS,sizeof(M_INT));
		else
			comp->S.iw = NULL;
		if (NUMBER_OF_BOOLEANS > 0)
			comp->b = functions->allocateMemory(NUMBER_OF_BOOLEANS,sizeof(fmi2Boolean));
		else
			comp->b = NULL;
		if (NUMBER_OF_STRINGS > 0) {
			comp->s = functions->allocateMemory(NUMBER_OF_STRINGS,sizeof(fmi2String));
			for (i=0; i<NUMBER_OF_STRINGS; i++)
				comp->s[i] = NULL;
		}
		else
			comp->s = NULL;
	}

	if (!comp || !comp->S.w ||	(NUMBER_OF_INTEGERS>0 && !comp->S.iw ) ||
								(NUMBER_OF_BOOLEANS>0 && !comp->b) ||
								(NUMBER_OF_STRINGS>0  && !comp->s)) {
		functions->logger(NULL, instanceName, fmi2Error,
				"error", "[%s]: Cannot allocate memory.", fname);
		return NULL;
	}

	comp->instanceName	= iname;
	comp->GUID			= MODEL_GUID;
	comp->fmuType		= fmuType;
	memcpy(&comp->functions,functions,sizeof(fmi2CallbackFunctions));
	comp->loggingOn		= loggingOn;

	if(comp->S.wset) {
		for(i=0;i<NUMBER_OF_REALS;i++)
			comp->S.wset[i]=1.0/dsn_zero;
		comp->synced			= fmi2False;
		comp->jsynced			= fmi2False;
	}
	else {
		SolverSetup(&(comp->S));
		comp->synced			= fmi2True;
		comp->jsynced			= fmi2True;
	}

	comp->initializeMode	= fmi2False;
	comp->state				= modelInstantiated;
	comp->vidsts			= 0;
	comp->minSampleStep	= minsamplestep;
	comp->fptr				= NULL;
	if (strcmp(binfile,"DISABLED") == 0)
		comp->fstr = NULL;
	else {
		comp->fstr = binfile;
		comp->s[0] = comp->functions.allocateMemory(1+strlen(binfile),sizeof(char));
		strcpy((char*)comp->s[0],(char*)binfile);
	}

	if (comp->loggingOn)
		compLog(compEnv, instanceName, fmi2OK,
			"log", "[%s]: GUID = %s", fname, GUID);

	return comp;
}
/* END: fmi2Instantiate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2FreeInstance */
/*****************************************************************************/
void fmi2FreeInstance(fmi2Component c) {
	int i;
	ModelInstance* comp = (ModelInstance *)c;

	if (!comp) return;

	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK,
			"log", "fmi2FreeInstance");

	if (comp->instanceName)	comp->functions.freeMemory((char*)comp->instanceName);
	if (comp->S.w)			comp->functions.freeMemory(comp->S.w);
	if (comp->S.iw)			comp->functions.freeMemory(comp->S.iw);
	if (comp->S.wset)			comp->functions.freeMemory(comp->S.wset);
	if (comp->S.psto)			comp->functions.freeMemory(comp->S.psto);
	if (comp->S.ssto)			comp->functions.freeMemory(comp->S.ssto);
	if (comp->b)			comp->functions.freeMemory(comp->b);
	if (comp->Jacobian)		comp->functions.freeMemory(comp->Jacobian);
	if (comp->initRes)		comp->functions.freeMemory(comp->initRes);
	if (comp->initJacobian)		comp->functions.freeMemory(comp->initJacobian);
	if (comp->s) {
		for (i=0; i<NUMBER_OF_STRINGS; i++)
			if (comp->s[i]) comp->functions.freeMemory((char*)comp->s[i]);
		comp->functions.freeMemory((char*)comp->s);
	}

	comp->functions.freeMemory(comp);
}
/* END: fmi2FreeInstance */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetupExperiment */
/*****************************************************************************/
fmi2Status fmi2SetupExperiment(	fmi2Component	c,
								fmi2Boolean		toleranceDefined,
								fmi2Real		tolerance,
								fmi2Real		startTime,
								fmi2Boolean		stopTimeDefined,
								fmi2Real		stopTime) {
	ModelInstance* comp = (ModelInstance *)c;

	UNUSED(toleranceDefined);
	UNUSED(tolerance);
	comp->S.w[0]	= startTime;
	comp->startTime	= startTime;

	if (stopTimeDefined)
		comp->stopTime = stopTime;
	else
		comp->stopTime = 0.0;

	comp->stopTimeDefined = stopTimeDefined;

	if (comp->fptr) {
		fclose(comp->fptr);
		comp->fptr = NULL;
	}
	if (comp->fstr && strcmp(comp->fstr,"DISABLED")!=0
						&& strcmp(comp->fstr,"'DISABLED'")!=0 )
		comp->fptr = fopen(comp->fstr,"wb");

	comp->lastsampletime = -1e10;
	comp->lastStepSize = -1.0;
	comp->lastSuccessfulTime = startTime;
	comp->numpts = 0;
	comp->vidsts = 0;
	comp->vidlasttime = -1e10;

	return fmi2OK;
}
/* END: fmi2SetupExperiment */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2EnterInitializationMode */
fmi2Status fmi2EnterInitializationMode(fmi2Component c) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2EnterInitializationMode", modelInstantiated))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK,
			"log", "fmi2EnterInitializationMode");

	/* Do not sync here - delay the sync until the first FMU query */
	comp->synced			= fmi2False;
	comp->jsynced			= fmi2False;

	comp->initializeMode	= fmi2True;
	comp->state				= modelInitialized;
	comp->vidsts			= 1;
	if (comp->fptr) {
		fwrite(nData,sizeof(fmi2Real),2,comp->fptr);
		if(NPAR>0) {
			syncModel(c,"fmi2EnterInitializationMode");
			fwrite(&comp->S.w[NEQ+1],sizeof(fmi2Real),NPAR,comp->fptr);
		}
	}

	return fmi2OK;
}
/* END: fmi2EnterInitializationMode */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2ExitInitializationMode */
fmi2Status fmi2ExitInitializationMode(fmi2Component c) {
	ModelInstance* comp = (ModelInstance *)c;
	fmi2Status sts;
	int i;

	if (comp) {
		sts = syncModel(c,"fmi2ExitInitializationMode");
		if ( sts!=fmi2OK ) return(sts);
		comp->initializeMode = fmi2False;
		if(comp->fmuType==fmi2ModelExchange && comp->S.wset)
			for(i=NDIFF+1;i<=NDIFF+NIX1-NINP;i++)
				comp->S.wset[i]=comp->S.w[i];
		comp->jsynced =fmi2False;
		comp->vidsts = 2;
		if (comp->fptr)
			fwrite(comp->S.w,sizeof(fmi2Real),NEQ+1,comp->fptr);
		return fmi2OK;
	}
	else
		return fmi2Error;
}
/* END: fmi2ExitInitializationMode */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2Terminate */
fmi2Status fmi2Terminate(fmi2Component c) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2Terminate", modelInitialized)) return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK,
			"log", "fmi2Terminate");
	if (comp->fptr) {
		fclose(comp->fptr);
		comp->fptr = NULL;
	}

	comp->state = modelTerminated;

	return fmi2OK;
}
/* END: fmi2Terminate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2Reset */
fmi2Status fmi2Reset(fmi2Component c) {
	ModelInstance* comp = (ModelInstance *)c;
	int i;

	if (invalidState(comp, "fmi2Reset", modelInitialized)) return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK,
			"log", "fmi2Reset");

	comp->state = modelInstantiated;
	comp->synced = fmi2False;
	comp->jsynced = fmi2False;

	if(comp->S.wset)
		for(i=0;i<NUMBER_OF_REALS;i++)
			comp->S.wset[i]=1.0/dsn_zero;
	else
		SolverSetup(&(comp->S));

	return fmi2OK;
}
/* END: fmi2Reset */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetReal */
fmi2Status fmi2GetReal(	fmi2Component			c,
						const fmi2ValueReference vr[],
						size_t					nvr,
						fmi2Real				value[]) {
	int i;
	fmi2Status sts;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetReal", validGet))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetReal", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetReal", "value[]", value))
		return fmi2Error;

#if NUMBER_OF_REALS+1>0
	/*for (i=0; i<(int)nvr; i++)
		if (vrOutOfRange(comp, "fmi2GetReal", vr[i], NUMBER_OF_REALS))
		return fmi2Error;*/

	if(comp->state != modelTerminated) {
		sts = syncModel(comp,"fmi2GetReal");
		if ( sts!=fmi2OK ) return sts;
	}

	for (i=0; i<(int)nvr; i++) {
		if( nomfac && vr[i]>=vrStates[0] && vr[i]<vrStates[0]+NDIFF )
			value[i] = comp->S.w[vr[i]]/nomfac[vr[i]-vrStates[0]];
		else if( nomfac && vr[i]>=vrDers[0] && vr[i]<vrDers[0]+NDIFF )
			value[i] = comp->S.w[vr[i]]/nomfac[vr[i]-vrDers[0]];
		else if (vr[i] == 184)
			value[i] = comp->minSampleStep;
		else if (vr[i] > NUMBER_OF_REALS) {
			comp->state = modelError;
            compLog(compEnv, comp->instanceName, fmi2Error,
					"error", "[%s]: Illegal value reference %u.", "fmi2GetReal", vr[i]);
            return fmi2Error;
		}
		else
			value[i] = comp->S.w[vr[i]];
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK,
				"log", "fmi2GetReal: #r%u# = %.16g", vr[i], value[i]);
	}
#endif
	return fmi2OK;
}
/* END: fmi2GetReal */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetInteger */
fmi2Status fmi2GetInteger(	fmi2Component			c,
							const fmi2ValueReference vr[],
							size_t					nvr,
							fmi2Integer				value[]) {
	int i;
	fmi2Status sts;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetInteger", validGet))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetInteger", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetInteger", "value[]", value))
		return fmi2Error;

	if(comp->state != modelTerminated) {
		sts = syncModel(comp,"fmi2GetInteger");
		if ( sts!=fmi2OK ) return sts;
	}

	for (i=0; i<(int)nvr; i++) {
		if (vrOutOfRange(comp, "fmi2GetInteger", vr[i], NUMBER_OF_INTEGERS))
			return fmi2Error;
		value[i] = (fmi2Integer)comp->S.iw[vr[i]];
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK,
				"log", "fmi2GetInteger: #i%u# = %d", vr[i], value[i]);
	}
	return fmi2OK;
}
/* END: fmi2GetInteger */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetBoolean */
fmi2Status fmi2GetBoolean(	fmi2Component			c,
							const fmi2ValueReference vr[],
							size_t					nvr,
							fmi2Boolean				value[]) {
	int i;
	fmi2Status sts;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetBoolean", validGet))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetBoolean", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetBoolean", "value[]", value))
		return fmi2Error;

	if(comp->state != modelTerminated) {
		sts = syncModel(comp,"fmi2GetBoolean");
		if ( sts!=fmi2OK ) return sts;
	}

	for (i=0; i<(int)nvr; i++) {
		if (vrOutOfRange(comp, "fmi2GetBoolean", vr[i], NUMBER_OF_BOOLEANS))
			return fmi2Error;
		value[i] = comp->b[vr[i]];
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK,
				"log", "fmi2GetBoolean: #b%u# = %s",vr[i], value[i]? "true":"false");
	}
	return fmi2OK;
}
/* END: fmi2GetBoolean */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetString */
fmi2Status fmi2GetString(fmi2Component			c,
						const fmi2ValueReference vr[],
						size_t					nvr,
						fmi2String				value[]) {
	int i;
	fmi2Status sts;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetString", validGet))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetString", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetString", "value[]", value))
		return fmi2Error;

	if(comp->state != modelTerminated) {
		sts = syncModel(comp,"fmi2GetString");
		if ( sts!=fmi2OK ) return sts;
	}

	for (i=0; i<(int)nvr; i++) {
		if (vr[i] == 185)
			value[i] = comp->s[0];
		else {
			comp->state = modelError;
			compLog(compEnv, comp->instanceName, fmi2Error,
					"error", "[%s]: Illegal value reference %u.", "fmi2GetString", vr[i]);
			return fmi2Error;
		}
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2GetString: #s%u# = '%s'", vr[i], value[i]);
	}
	return fmi2OK;
}
/* END: fmi2GetString */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetReal */
fmi2Status fmi2SetReal(	fmi2Component			c,
						const fmi2ValueReference vr[],
						size_t					nvr,
						const fmi2Real			value[]) {
	int i;
	ModelInstance* comp = (ModelInstance *)c;
	double scalev;

	if (invalidState(comp, "fmi2SetReal", modelInstantiated|modelInitialized))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetReal", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetReal", "value[]", value))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName,
				fmi2OK, "log",
				"fmi2SetReal: nvr = %d",
				nvr);

	for (i=0; i<(int)nvr; i++) {
		if (vrOutOfRange(comp, "fmi2SetReal", vr[i], NUMBER_OF_REALS+1))
			return fmi2Error;
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName,
					fmi2OK, "log",
					"fmi2SetReal: #r%d# = %.16g", vr[i], value[i]);
		if( nomfac && vr[i]>=vrStates[0] && vr[i]<vrStates[0]+NDIFF )
			scalev = nomfac[vr[i]-vrStates[0]]*value[i];
		else if( nomfac && vr[i]>=vrDers[0] && vr[i]<vrDers[0]+NDIFF )
			scalev = nomfac[vr[i]-vrDers[0]]*value[i];
		else if (vr[i] == 184) {
			comp->minSampleStep = value[i];
			continue;
		}
		else
			scalev = value[i];
		if (comp->S.w[vr[i]]!=scalev) {
#if NINP>0
			if(vr[i]>=1+NDIFF+NIX1-NINP && vr[i]<1+NDIFF+NIX1)
				inputchange=1;
#endif
#if NPAR>0
			if(comp->state==modelInitialized && comp->initializeMode==fmi2False
				&& vr[i]>=1+NEQ && vr[i]<=1+NEQ+NPAR) {
				if(pflags[vr[i]-1-NEQ])
					pchange=1;
				else {
					compLog(NULL, comp->instanceName, fmi2Error, "error",
						"fmi2SetReal: attempt to change fixed parameter after initialization.");
					return fmi2Error;
				}
			}
#endif
			comp->S.w[vr[i]] = scalev;
			if(comp->fmuType==fmi2ModelExchange && comp->S.wset)
				comp->S.wset[vr[i]] = scalev;
			comp->synced = fmi2False;
			comp->jsynced = fmi2False;
		}
	}

	return fmi2OK;
}
/* END: fmi2SetReal */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetInteger */
fmi2Status fmi2SetInteger(fmi2Component			c,
						const fmi2ValueReference vr[],
						size_t					nvr,
						const fmi2Integer		value[]) {
	int i;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2SetInteger", modelInstantiated|modelInitialized))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetInteger", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetInteger", "value[]", value))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName,
				fmi2OK, "log", "fmi2SetInteger: nvr = %d",
				nvr);

	for (i=0; i<(int)nvr; i++) {
		if (vrOutOfRange(comp, "fmi2SetInteger", vr[i], NUMBER_OF_INTEGERS))
			return fmi2Error;
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName,
					fmi2OK, "log", "fmi2SetInteger: #i%d# = %d", vr[i], value[i]);
		if (comp->S.iw[vr[i]]!=(M_INT)value[i]) {
			comp->S.iw[vr[i]] = (M_INT)value[i];
			comp->synced = fmi2False;
			comp->jsynced = fmi2False;
		}
	}

	return fmi2OK;
}
/* END: fmi2SetInteger */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetBoolean */
fmi2Status fmi2SetBoolean(fmi2Component			c,
						const fmi2ValueReference vr[],
						size_t					nvr,
						const fmi2Boolean		value[]) {
	int i;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2SetBoolean", modelInstantiated|modelInitialized))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetBoolean", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetBoolean", "value[]", value))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName,
				fmi2OK, "log", "fmi2SetBoolean: nvr = %d", nvr);
	for (i=0; i<(int)nvr; i++) {
		if (vrOutOfRange(comp, "fmi2SetBoolean", vr[i], NUMBER_OF_BOOLEANS))
			return fmi2Error;
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName,
					fmi2OK, "log",
					"fmi2SetBoolean: #b%d# = %s",
					vr[i], value[i] ? "true" : "false");
		if (comp->b[vr[i]]!=value[i]) {
			comp->b[vr[i]] = value[i];
			comp->synced = fmi2False;
			comp->jsynced = fmi2False;
		}
	}

	return fmi2OK;
}
/* END: fmi2SetBoolean */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetString */
fmi2Status fmi2SetString(fmi2Component			c,
						const fmi2ValueReference vr[],
						size_t					nvr,
						const fmi2String		value[]) {
	int i;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2SetString", modelInstantiated|modelInitialized))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetString", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetString", "value[]", value))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName,
				fmi2OK, "log", "fmi2SetString: nvr = %d",	nvr);

	for (i=0; i<(int)nvr; i++) {
		char* string = (char*)comp->s[0];
		if (vr[i] != 185) {
			comp->state = modelError;
			compLog(compEnv, comp->instanceName, fmi2Error,
					"error", "[%s]: Illegal value reference %u.", "fmi2SetString", vr);
			return fmi2Error;
		}
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName,
					fmi2OK, "log",
					"fmi2SetString: #s%d# = '%s'",
					vr[i], value[i]);
		if (nullPointer(comp, "fmi2SetString", "value[i]", value[i]))
			return fmi2Error;
		if (string==NULL || strlen(string) < strlen(value[i])) {
			if (string) comp->functions.freeMemory(string);
			comp->s[0] = comp->functions.allocateMemory(1+strlen(value[i]),
															sizeof(char));
			if (!comp->s[0]) {
				comp->state = modelError;
				compLog(NULL, comp->instanceName,
						fmi2Error, "error", "fmi2SetString: Out of memory.");
				return fmi2Error;
			}
		}
		strcpy((char*)comp->s[0], (char*)value[i]);
		/*comp->synced = fmi2False;*/
		if (vr[i] == 185)
			comp->fstr = comp->s[0];
	}

	return fmi2OK;
}
/* END: fmi2SetString */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetFMUstate */
/*****************************************************************************/
/* Storage structure:
		State id (hard coded value)
		Data length (bytes)
		ModelInstance
		Real data storage
		Integer data storage
		Real backup data storage (only for ME)
		Jacobian storage
		Error code
		String storage
*/
#define FMUStateID 983472598

fmi2Status fmi2GetFMUstate (
	fmi2Component	c,
	fmi2FMUstate*	FMUstate
)
{
	ModelInstance* comp = (ModelInstance *)c;
	char *cur;
	fmi2Real *rcur;
	M_INT i,j,*icur,wsto,ssto,jsto,totsto;

	if (invalidState(comp, "fmi2GetFMUstate", modelInitialized))
		return fmi2Error;

	if(comp->fmuType==fmi2ModelExchange)
		wsto = NUMBER_OF_REALS*sizeof(fmi2Real);
	else
		wsto = 0;

#ifdef FMI2_PROVIDES_DERIVATIVES
	jsto=( (1+NDIFF+NINP)*(NDIFF+NOUT) + NIUNK*(NIKNO+1) )*sizeof(fmi2Real);
#else
	jsto=0;
#endif

	ssto=0;
	for(i=0;i<NUMBER_OF_STRINGS;i++)
		if(comp->s[i])
			ssto+=strlen(comp->s[i])+1;
		else
			ssto++;

	totsto = 2*sizeof(M_INT) +
				sizeof(ModelInstance) +
				NUMBER_OF_REALS*sizeof(fmi2Real) +
				NUMBER_OF_INTEGERS*sizeof(M_INT) +
				wsto +
				jsto +
				sizeof(M_INT) +
				ssto;

	/* Verify that previously allocated FMU state is of sufficient size */
	if(*FMUstate) {
		icur=(M_INT *)(*FMUstate);
		if(icur[0]!=FMUStateID) {
			/* FMUstate pointer is not previously allocated in this routine
				so no way to verify the size */
			compLog(compEnv, comp->instanceName, fmi2Warning, "warning",
				"fmi2GetFMUstate: called with non-NULL state pointer of unknown size. Assuming sufficiently large.");
		}
		else if(icur[1]<totsto) {
			comp->functions.freeMemory(*FMUstate);
			*FMUstate=NULL;
		}
	}

	if(*FMUstate==NULL)
		FMUstate[0] = (fmi2FMUstate)comp->functions.allocateMemory(1,totsto);

	cur = (char *)(*FMUstate);

	icur = (M_INT *)cur;
	icur[0] = FMUStateID;
	icur[1] = totsto;
	cur += 2*sizeof(M_INT);

	memcpy(cur,comp,sizeof(ModelInstance));
	cur += sizeof(ModelInstance);

	rcur = (fmi2Real*)cur;
	for (i=0;i<NUMBER_OF_REALS;i++)	rcur[i] = comp->S.w[i];
	cur += NUMBER_OF_REALS*sizeof(fmi2Real);

	icur = (M_INT *)cur;
	for (i=0;i<NUMBER_OF_INTEGERS;i++) icur[i] = comp->S.iw[i];
	cur += NUMBER_OF_INTEGERS*sizeof(M_INT);

	if(comp->fmuType==fmi2ModelExchange) {
		rcur = (fmi2Real*)cur;
		for (i=0;i<NUMBER_OF_REALS;i++)	rcur[i] = comp->S.wset[i];
		cur += NUMBER_OF_REALS*sizeof(fmi2Real);
	}

#ifdef FMI2_PROVIDES_DERIVATIVES
	rcur = (fmi2Real*)cur;
	for (i=0;i<(1+NDIFF+NINP)*(NDIFF+NOUT);i++)	rcur[i] = comp->Jacobian[i];
	cur += (1+NDIFF+NINP)*(NDIFF+NOUT)*sizeof(fmi2Real);

	rcur = (fmi2Real*)cur;
	for (i=0;i<NIUNK*NIKNO;i++)	rcur[i] = comp->initJacobian[i];
	cur += NIUNK*NIKNO*sizeof(fmi2Real);

	rcur = (fmi2Real*)cur;
	for (i=0;i<NIUNK;i++)	rcur[i] = comp->initRes[i];
	cur += NIUNK*sizeof(fmi2Real);
#endif

	icur = (M_INT *)cur;
	icur[0] = errorOccured;
	cur += sizeof(M_INT);

	for(i=0;i<NUMBER_OF_STRINGS;i++) {
		if(comp->s[i]) {
			for(j=0;comp->s[i][j]!='\0';j++)
				*(cur++)=comp->s[i][j];
		}
		*(cur++)='\0';
	}

	return fmi2OK;
}
/* END: fmi2GetFMUstate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetFMUstate */
/*****************************************************************************/
fmi2Status fmi2SetFMUstate (fmi2Component	c,
							fmi2FMUstate	FMUstate) {
	ModelInstance* comp = (ModelInstance *)c;
	char *cur;
	fmi2String *scur;
	fmi2Real *rcur,*wcur,*jcur1,*jcur2,*jcur3;
	M_INT i,j,l,*icur;

	if (invalidState(comp, "fmi2SetFMUstate", modelInitialized))
		return fmi2Error;

	cur = (char *)FMUstate;
	icur = (M_INT *)cur;
	if(icur[0]!=FMUStateID) {
		compLog(compEnv, comp->instanceName, fmi2Error, "error",
			"fmi2SetFMUstate: called with invalid FMUstate");
		return(fmi2Error);
	}
	cur += 2*sizeof(M_INT);

	rcur = comp->S.w;
	icur = comp->S.iw;
	wcur = comp->S.wset;
	jcur1 = comp->Jacobian;
	jcur2 = comp->initJacobian;
	jcur3 = comp->initRes;
	scur = comp->s;
	memcpy(comp,cur,sizeof(ModelInstance));
	comp->S.w  = rcur;
	comp->S.iw = icur;
	comp->S.wset = wcur;
	comp->Jacobian = jcur1;
	comp->initJacobian = jcur2;
	comp->initRes = jcur3;
	comp->s = scur;
	cur += sizeof(ModelInstance);

	rcur = (fmi2Real *)cur;
	for(i=0;i<NUMBER_OF_REALS;i++) comp->S.w[i] = rcur[i];
	cur += NUMBER_OF_REALS*sizeof(fmi2Real);

	icur = (M_INT *)cur;
	for (i=0;i<NUMBER_OF_INTEGERS;i++) comp->S.iw[i] = icur[i];
	cur += NUMBER_OF_INTEGERS*sizeof(M_INT);

	if(comp->fmuType==fmi2ModelExchange) {
		rcur = (fmi2Real *)cur;
		for(i=0;i<NUMBER_OF_REALS;i++) comp->S.wset[i] = rcur[i];
		cur += NUMBER_OF_REALS*sizeof(fmi2Real);
	}
	else
		comp->S.wset = NULL;

#ifdef FMI2_PROVIDES_DERIVATIVES
	rcur = (fmi2Real*)cur;
	for (i=0;i<(1+NDIFF+NINP)*(NDIFF+NOUT);i++)	comp->Jacobian[i] = rcur[i];
	cur += (1+NDIFF+NINP)*(NDIFF+NOUT)*sizeof(fmi2Real);

	rcur = (fmi2Real*)cur;
	for (i=0;i<NIUNK*NIKNO;i++)	comp->initJacobian[i] = rcur[i];
	cur += NIUNK*NIKNO*sizeof(fmi2Real);

	rcur = (fmi2Real*)cur;
	for (i=0;i<NIUNK;i++)	comp->initRes[i] = rcur[i];
	cur += NIUNK*sizeof(fmi2Real);
#else
	comp->Jacobian = NULL;
	comp->initJacobian = NULL;
	comp->initRes = NULL;
#endif

	icur = (M_INT *)cur;
	errorOccured = icur[0];
	cur += sizeof(M_INT);

	for(i=0;i<NUMBER_OF_STRINGS;i++) {
		l=(comp->s[i]) ? strlen(comp->s[i]) : 0;
		j=strlen(cur);
		if(j>l) {
			if(comp->s[i]) comp->functions.freeMemory((char *)comp->s[i]);
			comp->s[i]=(fmi2String)comp->functions.allocateMemory(1,j+1);
		}
		strcpy((char *)comp->s[i],cur);
		cur += j+1;
	}

	return fmi2OK;
}
/* END: fmi2SetFMUstate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2FreeFMUstate */
/*****************************************************************************/
fmi2Status fmi2FreeFMUstate(fmi2Component c,
							fmi2FMUstate* FMUstate) {
	ModelInstance* comp = (ModelInstance *)c;
	M_INT *icur;

	if (invalidState(comp, "fmi2FreeFMUstate",
		modelInstantiated|modelInitialized|modelTerminated|modelError))
		return fmi2Error;

	if( *FMUstate ) {
		icur = (M_INT *)(*FMUstate);
		if(icur[0]!=FMUStateID)
			compLog(compEnv, comp->instanceName, fmi2Warning, "warning",
				"fmi2FreeFMUstate: called with invalid FMUstate");
		comp->functions.freeMemory(*FMUstate);
	}

	*FMUstate = NULL;

	return fmi2OK;
}
/* END: fmi2FreeFMUstate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SerializedFMUstateSize */
/*****************************************************************************/
fmi2Status fmi2SerializedFMUstateSize(	fmi2Component	c,
										fmi2FMUstate	FMUstate,
										size_t			*size) {
	ModelInstance* comp = (ModelInstance *)c;
	M_INT *icur;

	if (invalidState(comp, "fmi2SerializedFMUstateSize", modelInitialized))
		return fmi2Error;

	icur = (M_INT *)FMUstate;
	if(icur[0]!=FMUStateID) {
		compLog(compEnv, comp->instanceName, fmi2Error, "error",
			"fmi2SerializedFMUstateSize: called with invalid FMUstate");
		return(fmi2Error);
	}
	*size = (size_t)icur[1];

	return fmi2OK;
}
/* END: fmi2SerializedFMUstateSize */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SerializeFMUstate */
/*****************************************************************************/
fmi2Status fmi2SerializeFMUstate(fmi2Component		c,
								fmi2FMUstate		FMUstate,
								fmi2Byte 			serializedState[],
								size_t				size) {
	ModelInstance* comp = (ModelInstance *)c;
	M_INT *icur;

	if (invalidState(comp, "fmi2SerializeFMUstate", modelInitialized))
		return fmi2Error;

	icur = (M_INT *)FMUstate;
	if(icur[0]!=FMUStateID) {
		compLog(compEnv, comp->instanceName, fmi2Error, "error",
			"fmi2SerializedFMUstate: called with invalid FMUstate");
		return fmi2Error;
	}
	if(icur[1]>(M_INT)size) {
		compLog(compEnv, comp->instanceName, fmi2Error, "error",
			"fmi2SerializedFMUstate: called with size not sufficient to contain FMUstate");
		return fmi2Error;
	}
	memcpy(serializedState, FMUstate, size);

	return fmi2OK;
}
/* END: fmi2SerializeFMUstate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2DeSerializeFMUstate */
/*****************************************************************************/
fmi2Status fmi2DeSerializeFMUstate(	fmi2Component	c,
									const fmi2Byte	serializedState[],
									size_t			size,
									fmi2FMUstate	*FMUstate) {
	ModelInstance* comp = (ModelInstance *)c;
	M_INT *icur;

	if (invalidState(comp, "fmi2DeSerializeFMUstate", modelInitialized))
		return fmi2Error;

	icur = (M_INT *)serializedState;
	if(icur[0]!=FMUStateID) {
		compLog(compEnv, comp->instanceName, fmi2Error, "error",
			"fmi2DeSerializedFMUstate: called with serializedState not containing valid FMUstate");
		return fmi2Error;
	}
	if(icur[1]>(M_INT)size) {
		compLog(compEnv, comp->instanceName, fmi2Error, "error",
			"fmi2SerializedFMUstate: called with size not sufficient to contain serializedState");
		return fmi2Error;
	}
	FMUstate[0] = (fmi2FMUstate)comp->functions.allocateMemory(1,size);
	memcpy(*FMUstate, serializedState, size);

	return fmi2OK;
}
/* END: fmi2DeSerializeFMUstate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetDirectionalDerivative */
/*****************************************************************************/
fmi2Status fmi2GetDirectionalDerivative(	fmi2Component			c,
										const fmi2ValueReference	vUnknown_ref[],
										size_t						nUnknown,
										const fmi2ValueReference	vKnown_ref[],
										size_t						nKnown,
										const fmi2Real				dvKnown[],
										fmi2Real					dvUnknown[]) {
#ifdef FMI2_PROVIDES_DERIVATIVES
	int i, j, k, row, col, offset;
	fmi2Status sts;
	fmi2ValueReference vrs, vrd;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetDirectionalDerivatives", modelInstantiated|modelInitialized))
		return fmi2Error;
	if (nKnown>0 && nullPointer(comp, "fmi2GetDirectionalDerivative", "vKnown_ref[]", vKnown_ref))
		return fmi2Error;
	if (nUnknown>0 && nullPointer(comp, "fmi2GetDirectionalDerivative", "vUnknown_ref[]", vUnknown_ref))
		return fmi2Error;
	if (nKnown>0 && nullPointer(comp, "fmi2GetDirectionalDerivative", "dvKnown[]", dvKnown))
		return fmi2Error;

	sts = syncModel(comp,"fmi2GetDirectionalDerivative");
	if ( sts!=fmi2OK ) return sts;

	/* Initialize unknown vector */
	for (i=0; i<nUnknown; i++) dvUnknown[i] = 0.;

	/* Get Jacobian information, dimensions, data, etc? */
	if(!comp->jsynced) {
		if(comp->initializeMode)
			initjac(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[NEQ+NPAR+1]),comp->initRes,comp->initJacobian);
		else
			intjac(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[NEQ+NPAR+1]),comp->Jacobian);
		comp->jsynced = fmi2True;
	}

	/* Order of value references :
	t, #states, #index-1(inps), #discrete, #params, #derivs, #events */

	/* Start the computation loop */
	if (comp->initializeMode) {
		offset = NIKNO;
		for (i=0; i<nKnown; i++) {
			/* Check the seed */
			if (dvKnown[i]!=0) {
				vrs = vKnown_ref[i];
				/* assert(vr>=0 && vr<NUMBER_OF_REALS); */
				col = -1;
				for (k=0; k<NIKNO; k++)
					if (vrs==vrIknowns[k]) {
						col = k;
						break;
					}
				/* Compute column i */
				for (j=0; j<nUnknown; j++) {
					vrd = vUnknown_ref[j];
					/* assert(vrd>=0 && vrd<NUMBER_OF_REALS); */
					if ( vrd==vrs ) {
						dvUnknown[j] += 1.0;
					}
					else if(col!=-1) {
						for (k=0; k<NIUNK; k++)
							if (vrd==vrIunknowns[k]) {
								dvUnknown[j] += dvKnown[i]*comp->initJacobian[k*offset+col];
								break;
							}
					}
				}
			}
		}
	}
	else {
		offset = 1+NDIFF+NINP;
		for (i=0; i<nKnown; i++) {
			/* Check the seed */
			if (dvKnown[i]!=0) {
				vrs = vKnown_ref[i];
				/* assert(vr>=0 && vr<NUMBER_OF_REALS); */
				/* Check that vKnown_ref[i] is a state or input */
				if ( vrs==0 || (vrs>=vrStates[0] && vrs<vrStates[0]+NDIFF) )
					col = vrs;
				else if(vrs>=1+NDIFF+NIX1-NINP && vrs<1+NDIFF+NIX1)
					col = vrs-(NIX1-NINP);
				else
					return fmi2Error;
				/* Compute column i */
				for (j=0; j<nUnknown; j++) {
					vrd = vUnknown_ref[j];
					/* assert(vrd>=0 && vrd<NUMBER_OF_REALS); */
					/* Check if vrd is a derivative or an output,
					it could also be an output that's a state */
					if ( vrd>=vrDers[0] && vrd<vrDers[0]+NDIFF ) {
						row = vrd-vrDers[0];
						dvUnknown[j] += dvKnown[i]*comp->Jacobian[row*offset+col];
					}
					else if( vrd>=vrStates[0] && vrd<vrStates[0]+NDIFF ) {
						if ( vrd==vrs ) dvUnknown[j] += 1.0;
					}
					else {
						for (k=0; k<NOUT; k++)
							if (vrd==vrOuts[k]) {
								/* refval-t-states+derivs: vrd-1-NDIFF+NDIFF */
								row = vrd-1;
								dvUnknown[j] += dvKnown[i]*comp->Jacobian[row*offset+col];
								break;
							}
						if (k==NOUT) return fmi2Error;
					}
				}
			}
		}
	}
	return fmi2OK;
#else
	/* Compiler warning fix */
	int i=nUnknown+nKnown;
	void *tmp;
	tmp=(void *)vUnknown_ref;
	tmp=(void *)vKnown_ref;
	tmp=(void *)dvKnown;
	tmp=(void *)dvUnknown;
	if(i>0) tmp=(void *)c;
	i=((int *)tmp)[0];
	/* End compiler warning fix */
	return fmi2Error;
#endif
}
/* END: fmi2GetDirectionalDerivative */
/*****************************************************************************/

#if NCON>0 && defined(WMI_PROJECTION)
/*****************************************************************************/
/* BEGIN: fmi2Projection */
/*****************************************************************************/
fmi2Status fmi2Projection(	fmi2Component	c,
								fmi2Real	P[],
								fmi2Real	projectionTolerance,
								size_t	iterationLimit,
								fmi2Boolean	apply) {
	int i;
	fmi2Status sts;
	fmi2Real S2[NDIFF];

	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2Projection", modelInstantiated|modelInitialized))
		return fmi2Error;

	sts = syncModel(comp,"fmi2Projection");
	if ( sts!=fmi2OK ) return sts;

	for(i=0;i<NDIFF;i++) S2[i] = comp->S.w[i+1];
	i=Projection(comp->S.w[0], &comp->S.w[1], projectionTolerance,
		iterationLimit, NULL, comp->S.psto);
	if( i!=0 ){
		/* Restore state */
		for(i=0;i<NDIFF;i++) comp->S.w[i+1]=S2[i];
		return fmi2Discard;
	}
	for(i=0;i<NDIFF;i++) P[i] = comp->S.w[i+1]-S2[i];

	if( !apply ){
		for(i=0;i<NDIFF;i++) comp->S.w[i+1]=S2[i];
	}

	return fmi2OK;
}
/* END: fmi2Projection */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2ProjectionStep: No longer supported */
/*****************************************************************************/
fmi2Status fmi2ProjectionStep(  fmi2Component	c,
								fmi2Real	S[]) {
	UNUSED(c);
	UNUSED(S);
	return fmi2Error;
}
/* END: fmi2ProjectionStep */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2Constraint */
/*****************************************************************************/
fmi2Status fmi2Constraint(	fmi2Component	c,
								fmi2Real	C[]) {
	int cb, cr, nblk;
	fmi2Real blkdata[2];
	fmi2Status sts;

	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2Constraint", modelInstantiated|modelInitialized))
		return fmi2Error;

	sts = syncModel(comp,"fmi2Constraint");
	if ( sts!=fmi2OK ) return sts;

	/* Iterate over Residual blocks */
	Rblkp(comp->S.w[0], &comp->S.w[1], blkdata, 0, 0);
	nblk = (int)(blkdata[0]);
	cr = 0;
	for(cb=1;cb<=nblk;cb++) {
		Rblkp(comp->S.w[0], &comp->S.w[1], &C[cr], cb, 3);
		Rblkp(comp->S.w[0], &comp->S.w[1], blkdata, cb, 1);
		cr += (int)(blkdata[0]);
	}

	return fmi2OK;
}
/* END: fmi2Constraint */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2ConstraintJacobian: No longer supported */
/*****************************************************************************/
fmi2Status fmi2ConstraintJacobian(	fmi2Component	c,
										fmi2Real	J[]) {

	/* If this function is required at some point, the code will need to be
	modified to fill in the ncon x ndiff Matrix using a sequence of calls to
	the block-based Jacobian. It is known that this will provide 0 entries
	for block dependencies on vars from a prior block, but this will only
	slow convergence of a newton approach, and be irrelevant when sufficiently
	close to the solution manifold */
	UNUSED(c);
	UNUSED(J);
	return fmi2Error;
}
/* END: fmi2ConstraintJacobian */
/*****************************************************************************/
#endif

#ifdef FMI2_COSIMULATION
/*****************************************************************************
 * FMI functions: only for FMI Co-Simulation 2.0
 *****************************************************************************/
/*****************************************************************************/
/* BEGIN: fmi2SetRealInputDerivatives */
fmi2Status fmi2SetRealInputDerivatives(	fmi2Component			c,
										const fmi2ValueReference vr[],
										size_t					nvr,
										const fmi2Integer		order[],
										const fmi2Real			value[]) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2SetRealInputDerivatives", modelInitialized))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2SetRealInputDerivatives: nvr= %d", nvr);

	UNUSED(vr);
	UNUSED(order);
	UNUSED(value);
	compLog(NULL, comp->instanceName, fmi2Error, "warning",
			"fmi2SetRealInputDerivatives: ignoring function call."
			" This model cannot interpolate inputs: canInterpolateInputs = \"fmi2False\"");

	return fmi2Warning;
}
/* END: fmi2SetRealInputDerivatives */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetRealOutputDerivatives */
fmi2Status fmi2GetRealOutputDerivatives(fmi2Component			c,
										const fmi2ValueReference vr[],
										size_t					nvr,
										const fmi2Integer		order[],
										fmi2Real				value[]) {
	int i;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetRealOutputDerivatives", modelInitialized))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2GetRealOutputDerivatives: nvr= %d",	nvr);

	UNUSED(vr);
	UNUSED(order);
	compLog(NULL, comp->instanceName, fmi2Error, "warning",
			"fmi2GetRealOutputDerivatives: ignoring function call."
			" This model cannot compute derivatives of outputs: MaxOutputDerivativeOrder=\"0\"");

	for (i=0; i<(int)nvr; i++) value[i] = 0;

	return fmi2Warning;
}
/* END: fmi2GetRealOutputDerivatives */
/*****************************************************************************/

#define MAX_STEP  1.00000000000000000e-04

/*****************************************************************************/
/* BEGIN: fmi2DoStep */
fmi2Status fmi2DoStep(  fmi2Component	c,
						fmi2Real		currentCommunicationPoint,
						fmi2Real		communicationStepSize,
						fmi2Boolean		newStep) {

	ModelInstance* comp	= (ModelInstance *)c;
	int		i;
	double	h;
#if NEVT>0
	M_INT *modes;
	double	prevEventIndicators[max(NEVT, 1)];
#endif

	if (invalidState(comp, "fmi2DoStep", modelInitialized)) return fmi2Error;

	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log", "fmi2DoStep: "
				"currentCommunicationPoint = %g, "
				"communicationStepSize = %g, "
				"newStep = fmi2%s",
				currentCommunicationPoint, communicationStepSize, newStep ? "True" : "False");

	if (comp->stopTimeDefined && currentCommunicationPoint+communicationStepSize > comp->stopTime) {
		comp->state = modelError;
		return fmi2Error;
	}

#if NPAR>0
	if(pchange) {
		SolverInitialize(&(comp->S));
		pchange=0;
		if (errorOccured>0) {
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			comp->state = modelTerminated;
			logMessage(comp, "fmi2DoStep", "error", fmi2Error);
			return fmi2Error;
		}
		else if(errorOccured<0) {
			logMessage(comp, "fmi2DoStep", "warning", fmi2Warning);
			errorOccured=0;
		}
	}
#endif

#if NEVT>0
	/* Run to get initial event indicators */
	eev(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[1]),prevEventIndicators);
	modes=comp->S.iw;
	ComputeEventIndicators(prevEventIndicators,&(comp->S.w[1]),modes,
		&modes[3*NEVT],&modes[2*NEVT],&modes[4*NEVT]);
#endif

	comp->S.w[0] = currentCommunicationPoint;
	if( currentCommunicationPoint < (comp->lastSuccessfulTime-10.*ULP1) )
		comp->lastStepSize = -1.;
	h = ( comp->lastStepSize<0. ) ? communicationStepSize/100. : comp->lastStepSize;
	warningOccured=0;
	/* Call the variable step integrator */
	i = Integrate(comp->S.w,comp->S.iw,currentCommunicationPoint+communicationStepSize,
				ERRTOL,&h,comp->S.psto);
	if(warningOccured) {
		logWarning(comp, "Integrate", "warning", fmi2Warning);
		warningOccured=0;
	}
	if(i!=1) {
		if (errorOccured>0) {
			comp->state = modelTerminated;
			logMessage(comp, "fmi2DoStep", "error", fmi2Error);
			return fmi2Error;
		}
	}
	comp->lastStepSize = (fmi2Real)h;
	comp->synced = fmi2True;
	comp->jsynced = fmi2False;
	SolverOutputs(&(comp->S));

	comp->lastSuccessfulTime = currentCommunicationPoint + communicationStepSize;
	comp->vidsts = 2;
 	if (comp->fptr)
		fwrite(comp->S.w,sizeof(fmi2Real),NEQ+1,comp->fptr);

	return fmi2OK;
}
/* END: fmi2DoStep */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2CancelStep */
fmi2Status fmi2CancelStep(fmi2Component c) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2CancelStep", modelInitialized)) return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log", "fmi2CancelStep");

	compLog(NULL, comp->instanceName, fmi2Error, "error",
			"fmi2CancelStep: Can be called when fmi2DoStep returned fmi2Pending."
			" This is not the case.");
	comp->state = modelError;
	return fmi2Error;
}
/* END: fmi2CancelStep */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetStatus */
fmi2Status fmi2GetStatus(	fmi2Component		c,
							const fmi2StatusKind s,
							fmi2Status*			value) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetStatus", modelInstantiated|modelInitialized))
		return fmi2Error;

	UNUSED(value);
	if (s==fmi2DoStepStatus) {
		if (comp->loggingOn) {
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"[fmi2GetStatus]: fmi2StatusKind = fmi2DoStepStatus");
			compLog(NULL, comp->instanceName, fmi2Error, "error",
				"[fmi2GetStatus]: Can be called with fmi2DoStepStatus when fmi2DoStep returned fmi2Pending."
				" This is not the case.");
		}
		return fmi2Discard;
	}
	else
		return fmi2Discard;
}
/* END: fmi2GetStatus */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetRealStatus */
fmi2Status fmi2GetRealStatus(	fmi2Component		c,
								const fmi2StatusKind s,
								fmi2Real*			value) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetRealStatus", modelInstantiated|modelInitialized))
		return fmi2Discard;

	if (s==fmi2LastSuccessfulTime) {
		if (comp->loggingOn) {
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"[fmi2GetRealStatus]: fmi2StatusKind = fmi2LastSuccessfulTime");
		}
		if (comp->state==modelTerminated) {
			*value = comp->lastSuccessfulTime;
			return fmi2OK;
		}
		else {
			compLog(NULL, comp->instanceName, fmi2Error, "error",
				"[fmi2GetRealStatus]: Can be called with fmi2LastSuccessfulTime when fmi2DoStep returned fmi2Discard."
				" This is not the case.");
			return fmi2Discard;
		}
	}
	else
		return fmi2Discard;
}
/* END: fmi2GetRealStatus */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetIntegerStatus */
fmi2Status fmi2GetIntegerStatus(fmi2Component		c,
								const fmi2StatusKind s,
								fmi2Integer*		value) {
	UNUSED(c);
	UNUSED(s);
	UNUSED(value);
	return fmi2Discard;
}
/* END: fmi2GetIntegerStatus */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetBooleanStatus */
fmi2Status fmi2GetBooleanStatus(fmi2Component		c,
								const fmi2StatusKind s,
								fmi2Boolean*		value) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetBooleanStatus", modelInstantiated|modelInitialized))
		return fmi2Discard;

	if (s==fmi2Terminated) {
		if (comp->loggingOn) {
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"[fmi2GetBooleanStatus]: fmi2StatusKind = fmi2Terminated");
		}
		if (comp->state==modelTerminated)
			*value = fmi2True;
		else
			*value = fmi2False;
		return fmi2OK;
	}
	else
		return fmi2Discard;
}
/* END: fmi2GetBooleanStatus */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetStringStatus */
fmi2Status fmi2GetStringStatus(	fmi2Component		c,
								const fmi2StatusKind s,
								fmi2String*			value) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetStringStatus", modelInstantiated|modelInitialized))
		return fmi2Discard;

	UNUSED(value);
	if (s==fmi2PendingStatus) {
		if (comp->loggingOn) {
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"[fmi2GetStringStatus]: fmi2StatusKind = fmi2PendingStatus");
			compLog(NULL, comp->instanceName, fmi2Error, "error",
					"[fmi2GetStringStatus]: Can be called with fmi2PendingStatus when fmi2DoStep returned fmi2Pending."
					" This is not the case.");
		}
		return fmi2Discard;
	}
	else
		return fmi2Discard;
}
/* END: fmi2GetStringStatus */
/*****************************************************************************/

#else
/*****************************************************************************
 * FMI functions: only for Model Exchange 2.0
 *****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2EnterEventMode */
fmi2Status fmi2EnterEventMode(fmi2Component c) {
	ModelInstance* comp = (ModelInstance *)c;

	if (comp) {
		comp->lastEventTime = comp->S.w[0]-1.0;
		return fmi2OK;
	}
	else
		return fmi2Error;
}
/* END: fmi2EnterEventMode */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2NewDiscreteStates */
fmi2Status fmi2NewDiscreteStates(fmi2Component	c,
								fmi2EventInfo*	eventInfo) {
	ModelInstance* comp = (ModelInstance *)c;
	int i;
#if NEVT+NCON>0
	fmi2Real save[NEQ],val;
#endif
	if (invalidState(comp, "fmi2NewDiscreteStates", modelInitialized))
		return fmi2Error;
	if (nullPointer (comp, "fmi2NewDiscreteStates", "eventInfo", eventInfo))
		return fmi2Error;

	eventInfo->newDiscreteStatesNeeded				= fmi2False;
	eventInfo->nominalsOfContinuousStatesChanged	= fmi2False;
	eventInfo->valuesOfContinuousStatesChanged		= fmi2False;
	eventInfo->terminateSimulation					= fmi2False;
	eventInfo->nextEventTimeDefined					= fmi2False;
	eventInfo->nextEventTime						= -0.0;

#if NEVT+NCON>0
	for(i=0;i<NEQ;i++) save[i]=comp->S.w[i+1];
#endif
	i=SolverProject(&(comp->S));
	if (i<0 || errorOccured==1) {
		setVidError(comp,NULL);
		if (comp->fptr) {
			writeErrorToFile(comp->fptr,NULL);
			comp->fptr = NULL;
		}
		eventInfo->terminateSimulation = fmi2True;
		comp->state = modelTerminated;
		logMessage(comp, "fmi2NewDiscreteStates", "error", fmi2Error);
		return fmi2Error;
	}
	else if (i>0 || errorOccured==2) {
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2NewDiscreteStates: model requested termination at t = %g",
				comp->S.w[0]);
		setVidError(comp,NULL);
		if (comp->fptr) {
			writeErrorToFile(comp->fptr,NULL);
			comp->fptr = NULL;
		}
		eventInfo->terminateSimulation = fmi2True;
		comp->state = modelTerminated;
		logMessage(comp, "fmi2NewDiscreteStates", "warning", fmi2Discard);
		return fmi2OK;
	}
	else if(errorOccured<0) {
		logMessage(comp, "fmi2NewDiscreteStates", "warning", fmi2Warning);
		errorOccured=0;
	}
#if NEVT>0
	if (comp->S.w[0]!=comp->lastEventTime) {
		i=RunEvents(comp->S.w, comp->S.iw, 0, -1, EVTITER, comp->S.psto);
		if (i<0 || errorOccured==1) {
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			eventInfo->terminateSimulation = fmi2True;
			comp->state = modelTerminated;
			logMessage(comp, "fmi2NewDiscreteStates", "error", fmi2Error);
			return fmi2Error;
		}
		else if (i>0 || errorOccured==2) {
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2NewDiscreteStates: model requested termination at t = %g",
					comp->S.w[0]);
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			eventInfo->terminateSimulation = fmi2True;
			comp->state = modelTerminated;
			logMessage(comp, "fmi2NewDiscreteStates", "warning", fmi2Discard);
			return fmi2OK;
		}
		else if(errorOccured<0) {
			logMessage(comp, "fmi2NewDiscreteStates", "warning", fmi2Warning);
			errorOccured=0;
		}
		comp->lastEventTime = comp->S.w[0];
	}
	i=RunEvents(comp->S.w, comp->S.iw, 1, -1, EVTITER, comp->S.psto);
	if (i<0 || errorOccured==1) {
		setVidError(comp,NULL);
		if (comp->fptr) {
			writeErrorToFile(comp->fptr,NULL);
			comp->fptr = NULL;
		}
		eventInfo->terminateSimulation = fmi2True;
		comp->state = modelTerminated;
		logMessage(comp, "fmi2NewDiscreteStates", "error", fmi2Error);
		return fmi2Error;
	}
	else if (i>0 || errorOccured==2) {
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2NewDiscreteStates: model requested termination at t = %g",
				comp->S.w[0]);
		setVidError(comp,NULL);
		if (comp->fptr) {
			writeErrorToFile(comp->fptr,NULL);
			comp->fptr = NULL;
		}
		eventInfo->terminateSimulation = fmi2True;
		comp->state = modelTerminated;
		logMessage(comp, "fmi2NewDiscreteStates", "warning", fmi2Discard);
		return fmi2OK;
	}
	else if(errorOccured<0) {
		logMessage(comp, "fmi2NewDiscreteStates", "warning", fmi2Warning);
		errorOccured=0;
	}
#endif
#if NEVT+NCON>0
	for(i=0;i<NEQ;i++) {
		val=1e-15;
		if(fabs(save[i])>val) val=fabs(save[i]);
		if(fabs(comp->S.w[i+1])>val) val=fabs(comp->S.w[i+1]);
		if( fabs(comp->S.w[i+1]-save[i])>1e-12*val )
			eventInfo->valuesOfContinuousStatesChanged = fmi2True;
	}
	if(eventInfo->valuesOfContinuousStatesChanged==fmi2True)
		SolverOutputs(&(comp->S));
#endif
	return fmi2OK;
}
/* END: fmi2NewDiscreteStates */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2EnterContinuousTimeMode */
fmi2Status fmi2EnterContinuousTimeMode(fmi2Component c) {
	if (c)	return fmi2OK;
	else	return fmi2Error;
}
/* END: fmi2EnterContinuousTimeMode */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2CompletedIntegratorStep */
fmi2Status fmi2CompletedIntegratorStep(	fmi2Component	c,
										fmi2Boolean		noSetFMUStatePriorToCurrentPoint,
										fmi2Boolean*	enterEventMode,
										fmi2Boolean*	terminateSimulation) {
	ModelInstance* comp = (ModelInstance *)c;
	int i;
#if NCON>0 && defined(CONDSTEPEVENT)
	fmi2Real save[NEQ],val,drift;
#endif

	UNUSED(noSetFMUStatePriorToCurrentPoint);
	if (invalidState(comp, "fmi2CompletedIntegratorStep", modelInitialized))
		return fmi2Error;
	if (nullPointer (comp, "fmi2CompletedIntegratorStep", "enterEventMode", enterEventMode))
		return fmi2Error;
	if (nullPointer (comp, "fmi2CompletedIntegratorStep", "terminateSimulation", terminateSimulation))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2CompletedIntegratorStep");

	*terminateSimulation = fmi2False;

	if (comp->synced)
		SolverUpdate(&(comp->S),1,1);
	else {
		SolverUpdate(&(comp->S),0,1);
		if (errorOccured>0) {
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			errorOccured = 0;
			comp->state = modelTerminated;
			logMessage(comp, "fmi2CompletedIntegratorStep", "error", fmi2Discard);
			return fmi2Discard;
		}
		else if(errorOccured<0) {
			logMessage(comp, "fmi2CompletedIntegratorStep", "warning", fmi2Warning);
			errorOccured=0;
		}
		comp->synced = fmi2True;
		comp->jsynced = fmi2False;
	}
	if(comp->fmuType==fmi2ModelExchange && comp->S.wset)
		for(i=NDIFF+1;i<=NDIFF+NIX1-NINP;i++)
			comp->S.wset[i]=comp->S.w[i];
	SolverOutputs(&(comp->S));
	if( comp->S.w[0]>=(comp->vidlasttime+comp->minSampleStep)*(1-1e-15) ) {
		comp->vidsts=2;
		comp->vidlasttime=comp->S.w[0];
	}
 	if (comp->fptr)
		if ( comp->S.w[0]>=(comp->lastsampletime+comp->minSampleStep)*(1-1e-15) ) {
			fwrite(comp->S.w,sizeof(fmi2Real),NEQ+1,comp->fptr);
			comp->lastsampletime=comp->S.w[0];
			if ( comp->numpts++ == WARNNUMDATPTS )
				compLog(compEnv, comp->instanceName, fmi2Warning, "warning",
						"[fmi2CompletedIntegratorStep]: At time t=%.16g, %d data points were written into file %s; consider increasing the minimum sample step, %.16g, to limit file size.",
						comp->S.w[0], WARNNUMDATPTS, comp->fstr, comp->minSampleStep);
		}

#if !defined(WMI_PROJECTION) && NCON>0
#   if defined(CONDSTEPEVENT)
	for(i=0;i<NEQ;i++) save[i]=comp->S.w[i+1];
	i=SolverProject(&(comp->S));
	if (i<0 || errorOccured>=1) {
		errorOccured=0;
		*enterEventMode = fmi2True;
	}
	else if (i>0) {
		setVidError(comp,NULL);
		if (comp->fptr) {
			writeErrorToFile(comp->fptr,NULL);
			comp->fptr = NULL;
		}
		comp->state = modelTerminated;
		*terminateSimulation = fmi2True;
		logMessage(comp, "fmi2CompletedIntegratorStep", "error", fmi2Discard);
		return fmi2OK;
	}
	else {
		drift=0.0;
		for(i=0;i<NEQ;i++) {
			val=1e-15;
			if(fabs(save[i])>val) val=fabs(save[i]);
			if(fabs(comp->S.w[i+1])>val) val=fabs(comp->S.w[i+1]);
			val=fabs(comp->S.w[i+1]-save[i])/val;
			if(val>drift) drift=val;
		}
		val=(CONTOL<1e-8) ? 1e-10 : 0.01*CONTOL;
		if(drift>val)
			*enterEventMode = fmi2True;
		else
			*enterEventMode = fmi2False;
	}
	for(i=0;i<NEQ;i++) comp->S.w[i+1]=save[i];
#   else
	*enterEventMode = fmi2True;
#   endif
#else
	*enterEventMode = fmi2False;
#endif

	return fmi2OK;
}
/* END: fmi2CompletedIntegratorStep */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetTime */
fmi2Status fmi2SetTime(	fmi2Component	c,
						fmi2Real		time) {
	ModelInstance* comp = (ModelInstance *)c;
	if (invalidState(comp, "fmi2SetTime", modelInstantiated|modelInitialized))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2SetTime: time = %.16g", time);
	if (comp->S.w[0] != time) {
		comp->S.w[0] = time;
		comp->synced = fmi2False;
		comp->jsynced = fmi2False;
	}
	return fmi2OK;
}
/* END: fmi2SetTime */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetContinuousStates */
fmi2Status fmi2SetContinuousStates(	fmi2Component	c,
									const fmi2Real	x[],
									size_t			nx){
	ModelInstance* comp = (ModelInstance *)c;
#if NDIFF>0
	double scalev;
	int i;
	fmi2ValueReference vr;
#endif

	if (invalidState (comp, "fmi2SetContinuousStates", modelInitialized))
		return fmi2Error;
	if (invalidNumber(comp, "fmi2SetContinuousStates", "nx", nx, NDIFF))
		return fmi2Error;
#if NDIFF>0
	if (nullPointer  (comp, "fmi2SetContinuousStates", "x[]", x))
		return fmi2Error;

	for (i=0; i<(int)nx; i++) {
		vr = vrStates[i];
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2SetContinuousStates: #r%d# = %.16g", vr, x[i]);
		/*assert(vr>=0 && vr<NUMBER_OF_REALS);*/
		if( nomfac )
			scalev = nomfac[i]*x[i];
		else
			scalev = x[i];
		if (comp->S.w[vr] != scalev) {
			comp->S.w[vr] = scalev;
			comp->synced = fmi2False;
			comp->jsynced = fmi2False;
		}
	}
#endif
	return fmi2OK;
}
/* END: fmi2SetContinuousStates */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetDerivatives */
fmi2Status fmi2GetDerivatives(	fmi2Component	c,
								fmi2Real		derivatives[],
								size_t			nx) {
#if NDIFF>0
	int i;
#endif
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState (comp, "fmi2GetDerivatives", validGet))
		return fmi2Error;
	if (invalidNumber(comp, "fmi2GetDerivatives", "nx", nx, NDIFF))
		return fmi2Error;
	if (nullPointer  (comp, "fmi2GetDerivatives", "derivatives[]", derivatives))
		return fmi2Error;

#if NDIFF>0
	if (comp->state==modelInitialized && !comp->synced) {
		SolverUpdate(&(comp->S),0,0);
		if(errorOccured>0) {
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			errorOccured=0;
			logMessage(comp, "fmi2GetDerivatives", "error", fmi2Discard);
			return fmi2Discard;
		}
		else if(errorOccured<0) {
			logMessage(comp, "fmi2GetDerivatives", "warning", fmi2Warning);
			errorOccured=0;
		}
		comp->synced = fmi2True;
		comp->jsynced = fmi2False;
	}
	for (i=0; i<(int)nx; i++) {
		if( nomfac )
			derivatives[i] = comp->S.w[vrDers[i]]/nomfac[i];
		else
			derivatives[i] = comp->S.w[vrDers[i]];
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2GetDerivatives: #r%d# = %.16g",	vrDers[i], derivatives[i]);
	}
#endif
	return fmi2OK;
}
/* END: fmi2GetDerivatives */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetEventIndicators */
fmi2Status fmi2GetEventIndicators(	fmi2Component	c,
									fmi2Real		eventIndicators[],
									size_t			ni) {
#if NEVT>0
	int i;
	M_INT *modes;
	fmi2Status sts;
#endif
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState (comp, "fmi2GetEventIndicators", validGet))
		return fmi2Error;
	if (invalidNumber(comp, "fmi2GetEventIndicators", "ni", ni, NEVT))
		return fmi2Error;

#if NEVT>0
	sts = syncModel(c,"fmi2GetEventIndicators");
	if ( sts!=fmi2OK ) return(sts);
	eev(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[1]),eventIndicators);
	modes=comp->S.iw;
	ComputeEventIndicators(eventIndicators,&(comp->S.w[1]),modes,
		&modes[3*NEVT],&modes[2*NEVT],&modes[4*NEVT]);
	for (i=0; i<(int)ni; i++) {
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2GetEventIndicators: z%d = %.16g",
					i, eventIndicators[i]);
	}
#else
	UNUSED(eventIndicators);
#endif
	return fmi2OK;
}
/* END: fmi2GetEventIndicators */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetContinuousStates */
fmi2Status fmi2GetContinuousStates(	fmi2Component	c,
									fmi2Real		states[],
									size_t			nx) {
#if NDIFF>0
	int i;
	fmi2Status sts;
#endif
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState (comp, "fmi2GetContinuousStates", validGet))
		return fmi2Error;
	if (invalidNumber(comp, "fmi2GetContinuousStates", "nx", nx, NDIFF))
		return fmi2Error;
#if NDIFF>0
	if (nullPointer  (comp, "fmi2GetContinuousStates", "states[]", states))
		return fmi2Error;

	sts = syncModel(c,"fmi2GetContinuousStates");
	if ( sts!=fmi2OK ) return(sts);
	for (i=0; i<(int)nx; i++) {
		if( nomfac )
			states[i] = comp->S.w[vrStates[i]]/nomfac[i];
		else
			states[i] = comp->S.w[vrStates[i]];
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2GetContinuousStates: #r%u# = %.16g", vrStates[i], states[i]);
	}
#endif
	return fmi2OK;
}
/* END: fmi2GetContinuousStates */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetNominalsOfContinuousStates */
fmi2Status fmi2GetNominalsOfContinuousStates(fmi2Component	c,
											fmi2Real		x_nominal[],
											size_t			nx) {
	ModelInstance* comp = (ModelInstance *)c;
	int i;

	if (invalidState (comp, "fmi2GetNominalsOfContinuousStates", validGet))
		return fmi2Error;
	if (invalidNumber(comp, "fmi2GetNominalsOfContinuousStates", "nx", nx, NDIFF))
		return fmi2Error;
	if (nullPointer  (comp, "fmi2GetNominalsOfContinuousStates", "x_nominal[]", x_nominal))
		return fmi2Error;

	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2GetNominalsOfContinuousStates: x_nominal[0..%d] = 1.0", nx-1);
	if( nomfac )
		for (i=0; i<(int)nx; i++) x_nominal[i] = 1.0/nomfac[i-1];
	else
		for (i=0; i<(int)nx; i++) x_nominal[i] = 1.0;

	return fmi2OK;
}
/* END: fmi2GetNominalsOfContinuousStates */
/*****************************************************************************/

#endif

/*****************************************************************************/
/* Special purpose data communication functions */

typedef fmi2Status getMapleSimVideoDataLengthTYPE(fmi2Component, fmi2Integer *);
#define getMapleSimVideoDataLength fmi2FullName(getMapleSimVideoDataLength)
FMI2_Export getMapleSimVideoDataLengthTYPE getMapleSimVideoDataLength;

fmi2Status getMapleSimVideoDataLength(fmi2Component c, fmi2Integer *len)
{
	ModelInstance* comp = (ModelInstance *)c;

	if(comp->vidsts==0) {
		*len=0;
		return(fmi2Warning);
	}
	else if(comp->vidsts==1)
		*len=2+NPAR;
	else if(comp->vidsts==2)
		*len=NEQ+1;
	else if(comp->vidsts==-1)
		*len=2+strlen(comp->viderror)/8;
	else {
		*len=0;
		return(fmi2Error);
	}
	return(fmi2OK);
}

typedef fmi2Status getMapleSimVideoDataTYPE(fmi2Component, fmi2Real *);
#define getMapleSimVideoData fmi2FullName(getMapleSimVideoData)
FMI2_Export getMapleSimVideoDataTYPE getMapleSimVideoData;

fmi2Status getMapleSimVideoData(fmi2Component c, fmi2Real *data)
{
	ModelInstance* comp = (ModelInstance *)c;

	if(comp->vidsts==0)
		return(fmi2Error);
	else if(comp->vidsts==1) {
		data[0]=nData[0];
		data[1]=nData[1];
		memcpy(&data[2],&comp->S.w[NEQ+1],NPAR*sizeof(fmi2Real));
	}
	else if(comp->vidsts==2)
		memcpy(data,comp->S.w,(NEQ+1)*sizeof(fmi2Real));
	else if(comp->vidsts==-1) {
		data[0]=-1e10;
		memcpy(&data[1],comp->viderror,strlen(comp->viderror)+1);
	}
	else
		return(fmi2Error);
	comp->vidsts=0;
	return(fmi2OK);
}

typedef fmi2Status getMapleSimAuxiliaryDataTYPE(fmi2Component, fmi2Real *);
#define getMapleSimAuxiliaryData fmi2FullName(getMapleSimAuxiliaryData)
FMI2_Export getMapleSimAuxiliaryDataTYPE getMapleSimAuxiliaryData;

fmi2Status getMapleSimAuxiliaryData(fmi2Component c, fmi2Real *data)
{
	ModelInstance* comp = (ModelInstance *)c;

	if(!comp->synced) {
		auxp(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[NEQ+NPAR+1]),data);
		return(fmi2Discard);
	}
	else if(comp->state==modelInitialized) {
		auxp(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[NEQ+NPAR+1]),data);
		return(fmi2OK);
	}
	else return(fmi2Error);
}
