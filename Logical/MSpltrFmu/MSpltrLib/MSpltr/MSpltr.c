/***************************************************
 * Automatically generated by Maple.
 * Created On: Fri Sep 27 13:58:30 2019.
***************************************************/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

/***************************************************
* Variable Definition for System:

* State variable(s):
*    S.w[ 1] = x[ 0] = `Main.CNC.P1.s`(t)
*    S.w[ 2] = x[ 1] = diff(`Main.CNC.P1.s`(t),t)
*    S.w[ 3] = x[ 2] = `Main.CNC.P2.s`(t)
*    S.w[ 4] = x[ 3] = diff(`Main.CNC.P2.s`(t),t)
*    S.w[ 5] = x[ 4] = `Main.CNC.S1.phi`(t)
*    S.w[ 6] = x[ 5] = diff(`Main.CNC.S1.phi`(t),t)
*    S.w[ 7] = x[ 6] = `Main.CNC.S2.phi`(t)
*    S.w[ 8] = x[ 7] = diff(`Main.CNC.S2.phi`(t),t)
*
* Output variable(s):
*    S.w[67] = y[ 0] = `Main.CNC.PositionX`(t)
*    S.w[68] = y[ 1] = `Main.CNC.PositionY`(t)
*    S.w[ 2] = y[ 2] = diff(`Main.CNC.P1.s`(t),t)
*    S.w[ 4] = y[ 3] = diff(`Main.CNC.P2.s`(t),t)
*    S.w[69] = y[ 4] = `Main.CNC.TorqueX`(t)
*    S.w[70] = y[ 5] = `Main.CNC.TorqueY`(t)
*
* Input variable(s):
*    S.w[73] = u[ 0] = `Main.CNC.InputX`(t)
*    S.w[74] = u[ 1] = `Main.CNC.InputY`(t)
*
* Additional Parameter(s):
*    (vr = 319) ap[ 0] = `Main.CNC.minsamplestep` (default = 1/40)
*    (vr = 320) ap[ 1] = `Main.CNC.binfilename` (default = "DISABLED", type = string)
*
************************************************/

/* Set up fixed initial condition mask */
int icmask[8] = {
	0,0,0,0,1,0,1,0};

/* No scaling - no nominals */
double *nomfac=NULL;
/* Configurable parameters */
#define MAXERRSTRLENGTH 10000
#define MAXWARNSTRLENGTH 10000
#define WARNNUMDATPTS 100000
#define CONITER 50
#define CONTOL 1.000000e-05
#define INITCONITER 100
#define INITCONTOL 1.000000e-10
#define INITITER 50
#define INITTOL 1.000000e-08
#define INITWEIGHT 2.000000e+01
#define EVTITER 100
#define EVTPROJ 1
#define EVTHYST 1.000000e-10
#define FMUHYST 2.000000e-10
#define INCONTOL 1e200

#define SSTO 0
/* Wordsize integer definition */
#ifndef M_INT
# if defined _MINGW64 || defined X86_64_WINDOWS
#  define M_INT long long
# elif defined __x86_64__ || defined __ppc64__
#  define M_INT long
# elif defined _M_X64
#  define M_INT long long
# else
#  define M_INT int
# endif
#endif

static int errorOccured = 0;
static char errorString[MAXERRSTRLENGTH+1];
static int warningOccured = 0;
static char warningString[MAXWARNSTRLENGTH+1];

static void SolverError(double t, int term, char *errmsg)
{
	if(term) {
		sprintf(errorString,"Simulation terminated at t=%20.16e: %s\n",t,errmsg);
		errorOccured = 2;
	}
	else {
		sprintf(errorString,"Error at t=%20.16e: %s\n",t,errmsg);
		errorOccured = 1;
	}
}


static void SolverWarning(double t, char *warnmsg)
{
	if(!warningOccured) {
		sprintf(warningString,"Warning at t=%20.16e: %s\n",t,warnmsg);
		warningOccured = 1;
	}
}

/* Fixed parameters */
#define NDIFF 8
#define NDFA 8
#define NEQ 134
#define NPAR 0
#define NINP 2
#define NDISC 60
#define NIX1 66
#define NOUT 6
#define NCON 2
#define NEVT 32

#ifndef max
#define max(a,b) (((a)>(b))?(a):(b))
#endif
#ifndef min
#define min(a,b) (((a)<(b))?(a):(b))
#endif
static double nData[2] = {1.0*NEQ,1.0*NPAR};
static double minsamplestep = 2.50000000000000000e-02;

static void writeErrorToFile(FILE *fptr, char *errstr) {
	char *err, uerr[]="unknown error";
	int i;
	double d;

	if (errstr)
		err = errstr;
	else if (errorOccured)
		err = errorString;
	else
		err = uerr;

	d = -1e10; /*terminate value*/
	fwrite(&d,sizeof(double),1,fptr);
	for(i=0;;i++) {
		d = (double)err[i];
		fwrite(&d,sizeof(double),1,fptr);
		if (!err[i]) break;
	}

	fclose(fptr);
}

static int inputchange=0;

typedef struct {
	double *w;		/* Float workspace */
	M_INT *iw;		/* Integer workspace */
	double *wset;		/* Float workspace */
	double *psto;		/* Float projection workspace */
	double *ssto;		/* Solver storage (implicit) */
} SolverStruct;

static double dsn_zero=0.0;
static unsigned char dsn_undefC[8] = { 0, 0, 0, 0, 0, 0, 0xF8, 0x7F };
static double *dsn_undef = (double *)&dsn_undefC;
static unsigned char dsn_posinfC[8] = { 0, 0, 0, 0, 0, 0, 0xF0, 0x7F };
static double *dsn_posinf = (double *)&dsn_posinfC;
static unsigned char dsn_neginfC[8] = { 0, 0, 0, 0, 0, 0, 0xF0, 0xFF };
static double *dsn_neginf = (double *)&dsn_neginfC;
#define trunc(v) ( (v>0.0) ? floor(v) : ceil(v) )
#define IS_UNDEF(a) (a-a!=0. || (a!=0. && a-2.*a==0.))
#define UNUSED(a) ((void)(a))
double avoidcompilerwarn() { return(dsn_zero+*dsn_undef+*dsn_posinf+*dsn_neginf); }

#ifdef MSVC
#pragma optimize( "gty", on)
#endif
#ifndef INCONTOL
#define INCONTOL 1e-14
#endif

static void LSQDecompSolve(M_INT n, double *A, M_INT Ainc, M_INT *ip, double *b)
{
	M_INT i,j,k,r,c,lsq,cp;
	double s,t;

	for(i=0;i<n;i++) {
		if(b[i]-b[i]!=0.0 || (b[i]!=0. && b[i]-2.*b[i]==0.)) { ip[n-1]=0; A[0]=1.; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
		t = fabs(A[i*Ainc]);
		for(j=1;j<n;j++) {
			s = fabs(A[i*Ainc+j]);
			if(s>t) t = s;
		}
		if( t==0.0 )
			A[i*Ainc+n] = 1.0;
		else {
			t = 1.0/t;
			for(j=0;j<n;j++) A[i*Ainc+j] *= t;
			b[i] *= t;
			A[i*Ainc+n] = t;
		}
	}

	for(j=0;j<n;j++) {
		t = fabs(A[j]);
		for(i=1;i<n;i++) {
			s = fabs(A[i*Ainc+j]);
			if(s>t) t = s;
		}
		if( t==0.0 )
			A[n*Ainc+j] = 1.0;
		else {
			t = 1.0/t;
			for(i=0;i<n;i++) A[i*Ainc+j] *= t;
			A[n*Ainc+j] = t;
		}
	}

	ip[n-1] = 0;
	lsq = 0;
	cp = 0;
	for(k=0;k<n;k++) {
		r = 0; c = 0; t = 0.0;
		if( cp<n ) {
			for(cp=cp+1;cp<n;cp++) {
				for(i=k;i<n;i++) {
					s = fabs(A[i*Ainc+cp]);
					if(s>t) { r = i; c = cp; t = s; }
				}
				if( t>0.5 ) break;
			}
		}
		if( cp>=n ) {
			for(i=k;i<n;i++)
				for(j=k;j<n;j++) {
					s = fabs(A[i*Ainc+j]);
					if(s>t) { r = i; c = j; t = s; }
				}
		}
		if( t<1e-10 ) {
			if( k==0 ) { ip[n-1]=0; A[0]=2.; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
			if( lsq ) { ip[n-1]=0; A[0]=3.; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
			lsq = 1;
			t = 1e-16;
			for(i=0;i<k;i++) {
				s = fabs(b[i]);
				if(s>t) t = s;
			}
			for(i=k;i<n;i++) {
				if( fabs(b[i])/t>INCONTOL*n ) { ip[n-1]=0; A[0]=4.; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
				b[i] = 0.0;
			}

			for(r=k;r<n;r++) {
				for(i=k;i<n;i++) A[i*Ainc+n+r] = 0.0;
				A[r*Ainc+n+r] = 1.0;
				A[(k-1)*Ainc+n+r] = -A[(k-1)*Ainc+r]/A[(k-1)*Ainc+k-1];
				for(i=k-1;i>=0;i--) {
					A[i*Ainc+n+r] = A[i*Ainc+r];
					for(j=i+1;j<k;j++)
						A[i*Ainc+n+r] += A[i*Ainc+j]*A[j*Ainc+n+r];
					A[i*Ainc+n+r] = -A[i*Ainc+n+r]/A[i*(Ainc+1)];
				}
			}
			for(r=0;r<k;r++) {
				s = -1.0/A[r*(Ainc+1)];
				for(i=k;i<n;i++)
					if( A[r*Ainc+n+i]!=0.0 ) {
						t = s*A[r*Ainc+n+i];
						A[i*Ainc+r] += t;
						for(j=r+1;j<n;j++)
							A[j*Ainc+n+i] += t*A[r*Ainc+j];
						b[i] += t*b[r];
					}
			}
			for(i=k;i<n;i++)
				for(j=k;j<n;j++)
					A[i*Ainc+j] = A[j*Ainc+n+i];
			r = 0; c = 0; t = 0.0;
			for(i=k;i<n;i++)
				for(j=k;j<n;j++) {
					s = fabs(A[i*Ainc+j]);
					if(s>t) { r = i; c = j; t = s; }
				}
			if( t<1e-10 ) { ip[n-1]=0; A[0]=3.; for(j=0;j<n;j++) b[j]=*dsn_undef; return; }
		}
		if( !lsq ) ip[n-1]++;
		if( k==n-1 ) break;
		ip[k] = r;
		ip[n+k] = c;
		if( r>k ) {
			for(j=0;j<n;j++) {
				t = A[r*Ainc+j]; A[r*Ainc+j] = A[k*Ainc+j]; A[k*Ainc+j] = t;
			}
			t = b[r]; b[r] = b[k]; b[k] = t;
		}
		if( c>k )
			for(i=0;i<n;i++) {
				t = A[i*Ainc+c]; A[i*Ainc+c] = A[i*Ainc+k]; A[i*Ainc+k] = t;
			}
		s = -1.0/A[k*(Ainc+1)];
		for(i=k+1;i<n;i++)
			if( A[i*Ainc+k]!=0.0 ) {
				t = s*A[i*Ainc+k];
				A[i*Ainc+k] = t;
				for(j=k+1;j<n;j++)
					A[i*Ainc+j] += t*A[k*Ainc+j];
				b[i] += t*b[k];
			}
	}
	for(j=n-1;j>0;j--) {
		b[j] = b[j]/A[j*(Ainc+1)];
		t = -b[j];
		for(i=0;i<j;i++)
			b[i] += t*A[i*Ainc+j];
	}
	b[0] = b[0]/A[0];
	for(j=n-2;j>=0;j--) {
		i = ip[n+j];
		if(i!=j) {
			t = b[i]; b[i] = b[j]; b[j] = t;
		}
	}
	for(j=0;j<n;j++) b[j] *= A[n*Ainc+j];
}
#ifdef MSVC
#pragma optimize( "", on)
#endif

#ifdef MSVC
#pragma optimize( "gty", on)
#endif
static void DecompCInc(M_INT n, double *A, M_INT Ainc, M_INT *ip)
{
	M_INT i,j,k,m;
	double t;

	ip[n-1]=1;
	for(k=0;k<n-1;k++) {
		m=k;
		for(i=k+1;i<n;i++)
			if( fabs(A[i*Ainc+k])>fabs(A[m*Ainc+k]) ) m=i;
		ip[k]=m;
		if( m!=k ) ip[n-1]=-ip[n-1];
		t=A[m*Ainc+k]; A[m*Ainc+k]=A[(Ainc+1)*k]; A[(Ainc+1)*k]=t;
		if( t==0.0 ) { ip[n-1]=0; return; }
		t=-1.0/t;
		for(i=k+1;i<n;i++) A[i*Ainc+k]=A[i*Ainc+k]*t;
		for(j=k+1;j<n;j++) {
			t=A[m*Ainc+j]; A[m*Ainc+j]=A[k*Ainc+j]; A[k*Ainc+j]=t;
			if( t!=0.0 )
				for(i=k+1;i<n;i++) A[i*Ainc+j]+=A[i*Ainc+k]*t;
		}
	}
	if(A[(n-1)*(Ainc+1)]==0.0) ip[n-1]=0;
}
#ifdef MSVC
#pragma optimize( "", on)
#endif

#ifdef MSVC
#pragma optimize( "gty", on)
#endif
static void MultiSolveCInc(M_INT n, double *A, M_INT Ainc, M_INT *ip, M_INT nb, double *b, M_INT binc)
{
	M_INT i,j,k,m;
	double t;

	if( n>1 ) {
		for(j=0;j<n-1;j++) {
			m=ip[j];
			for(k=0;k<nb;k++) {
				t=b[m*binc+k]; b[m*binc+k]=b[j*binc+k]; b[j*binc+k]=t;
				for(i=j+1;i<n;i++) b[i*binc+k]+=A[i*Ainc+j]*t;
			}
		}
		for(j=n-1;j>0;j--) {
			for(k=0;k<nb;k++) {
				b[j*binc+k]=b[j*binc+k]/A[(Ainc+1)*j];
				t=-b[j*binc+k];
				for(i=0;i<=j-1;i++) b[i*binc+k]+=A[i*Ainc+j]*t;
			}
		}
	}
	for(k=0;k<nb;k++)
		b[k]=b[k]/A[0];
}
#ifdef MSVC
#pragma optimize( "", on)
#endif

static double dsn_U_Modelica_U_46_U_Math_U_46_U_Matrices_U_46_U_isEqual_U_46_U_proc_U_1_U_5_U_1_U_5(double *M1, double *M2, double eps)
{
	double ncol, nrow, result;
	int i, j;

	nrow = 1.;
	ncol = 5.;
	i = 1;
	result = 0.;
	if( (1.==nrow) && (5.==ncol) ) {
		result = 1.;
		while( ((double)i)<=nrow ) {
			j = 1;
			while( ((double)j)<=ncol ) {
				if( eps<fabs(M1[(i-1)*5+j-1]-M2[(i-1)*5+j-1]) ) {
					result = 0.;
					i = ((int)(trunc(nrow)));
					j = ((int)(trunc(ncol)));
				}
				j = j+1;
			}
			i = i+1;
		}
	}
	return(result);
}

static void fp(int N, double T, double *Y, double *YP)
{
	double M[60], V[5], Z[10];
	int ti1, ti2;
	M_INT P[9];

	UNUSED(N);
	UNUSED(T);
	YP[0] = Y[1];
	YP[2] = Y[3];
	YP[4] = Y[5];
	YP[6] = Y[7];
	Y[64] = Y[1]-0.0002204328263378327563*Y[5];
	Y[60] = 1.*tanh(20.*Y[64])*(2400.*exp(-fabs(Y[64]))-2500.)-0.5*Y[64];
	YP[7] = Y[71];
	Y[65] = Y[3]-0.0002204328263378327563*Y[7];
	M[0] = 26.15057414717343431;
	Z[0] = 0.2982456140350877193*Y[6];
	Z[1] = sin(Z[0]);
	Z[0] = cos(Z[0]);
	Z[2] = -4.840045108533975192e-06;
	Z[3] = sin(Y[6]);
	Z[4] = cos(Y[6]);
	Z[5] = Y[7]*Y[7];
	Z[6] = -0.1260862329545794117;
	V[0] = (-5.728882850950149731e-08*Z[1]-4.190849202485267875e-06*Z[0]-0.4339536129058066533*Z[1]*Z[2])*YP[7]+Z[5]*(-1.708614183616711323e-08*Z[0]+1.249902393723676384e-06*Z[1]-0.129424761743837072*Z[0]*Z[2])+Z[6]*(YP[7]*(-0.00001775636314077511021*Z[4]+0.00003853424339345102039*Z[3])+Z[5]*(0.00001775636314077511021*Z[3]+0.00003853424339345102039*Z[4]))+Y[60]-0.001*Y[1];
	if( M[0]==0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	YP[1] = V[0]/M[0];
	Y[61] = 1.*tanh(20.*Y[65])*(2400.*exp(-fabs(Y[65]))-2500.)-0.5*Y[65];
	M[0] = 2.186147044774565811;
	V[0] = Y[61]-0.001*Y[3];
	if( M[0]==0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	YP[3] = V[0]/M[0];
	YP[5] = Y[70];
	Y[28] = 0.2982456140350877193*YP[5];
	Y[29] = YP[5];
	M[0] = -1.;
	if( Y[89]==1. )
		V[0] = -0.05-0.0001*Y[28];
	else if( Y[88]==1. )
		V[0] = 0.05-0.0001*Y[28];
	else if( Y[75]==1. )
		V[0] = -0.05-0.0001*Y[28];
	else
		V[0] = 0.05-0.0001*Y[28];
	if( M[0]==0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Y[8] = V[0]/M[0];
	Y[9] = 0.0001*Y[29];
	Y[30] = YP[7];
	Y[10] = 0.0001*Y[30];
	Y[31] = 0.2982456140350877193*YP[7];
	Y[12] = YP[5];
	Y[32] = 1.;
	M[0] = -1.;
	if( Y[95]==1. )
		V[0] = -0.05-0.0001*Y[31];
	else if( Y[94]==1. )
		V[0] = 0.05-0.0001*Y[31];
	else if( Y[81]==1. )
		V[0] = -0.05-0.0001*Y[31];
	else
		V[0] = 0.05-0.0001*Y[31];
	if( M[0]==0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Y[11] = V[0]/M[0];
	if( Y[82]==1. )
		Y[13] = 1.;
	else
		Y[13] = Y[32];
	Y[34] = 0.;
	Y[33] = 1.;
	if( Y[82]==1. )
		Y[43] = 0.;
	else
		Y[43] = fabs(Y[34]);
	M[0] = -1.;
	Z[0] = 0.2982456140350877193*Y[4];
	Z[1] = cos(Z[0]);
	Z[0] = sin(Z[0]);
	Z[2] = 4.737878549169818022e-08*Y[5]*Y[5];
	Z[3] = 1.22857406392729025e-06;
	V[0] = Z[3]*(Z[0]*(-Z[1]*Z[2]-1.588582807662821337e-07*Z[0]*YP[5])+Z[1]*(Z[0]*Z[2]-1.588582807662821337e-07*Z[1]*YP[5]))-0.00002982456140350877193*Y[5]-0.0002101822782735614298*YP[5];
	if( M[0]==0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Y[62] = V[0]/M[0];
	if( Y[82]==1. )
		Y[14] = 1.;
	else
		Y[14] = Y[33];
	Y[35] = 0.;
	if( Y[82]==1. )
		Y[44] = 0.;
	else
		Y[44] = fabs(Y[35]);
	if( (Y[104]==1.) && (Y[105]==1.) )
		Y[45] = 0.5*Y[43];
	else {
		Z[0] = 1.0/Y[14]-Y[13];
		Z[0] = 1.0/Z[0];
		Y[45] = 1.*(Y[44]-Y[43])*Z[0];
	}
	Y[17] = YP[7];
	Y[46] = 1.;
	for(ti1=0;ti1<=4;ti1++)
		for(ti2=0;ti2<=4;ti2++)
			M[ti1*10+ti2] = 0.;
	for(ti1=0;ti1<=4;ti1++)
		V[ti1] = 0.;
	M[0] = 1.;
	M[33] = 1.;
	M[34] = -1.;
	if( Y[82]!=1. ) {
		if( (Y[97]==1.) || (Y[84]==1.) ) {
			M[1] = -1.;
			V[3] = -Y[45];
		}
		else {
			M[2] = -1.;
			V[3] = Y[45];
		}
	}
	M[11] = 1.;
	M[22] = 1.;
	if( Y[102]==1. ) {
		M[14] = Y[13]-1.;
		V[1] = Y[43];
		M[24] = (1.-Y[14])/Y[14];
		V[2] = -Y[44];
	}
	else {
		M[14] = (1.-Y[14])/Y[14];
		V[1] = Y[44];
		M[24] = Y[13]-1.;
		V[2] = -Y[43];
	}
	M[40] = -3.352941176470588235;
	M[44] = 3.352941176470588235;
	if( Y[89]==1. )
		V[4] = Y[62]+0.01+0.00073909830007390983*Y[60];
	else if( Y[88]==1. )
		V[4] = Y[62]-0.01+0.00073909830007390983*Y[60];
	else if( Y[75]==1. )
		V[4] = Y[62]+0.01+0.00073909830007390983*Y[60];
	else
		V[4] = Y[62]-0.01+0.00073909830007390983*Y[60];
	LSQDecompSolve(5,M,10,P,V);
	if( P[4]==0 ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Y[15] = V[0];
	Y[41] = V[1];
	Y[42] = V[2];
	Y[16] = V[3];
	Y[24] = V[4];
	Z[0] = ((1.-Y[14])*Y[24])/Y[14];
	Y[39] = -(Y[44]+Z[0]);
	Y[37] = Y[44]-Z[0];
	Z[0] = (1.-Y[13])*Y[24];
	Y[38] = Z[0]-Y[43];
	Y[36] = Y[43]+Z[0];
	Y[40] = Y[12]+Y[15];
	if( Y[85]==1. )
		Y[18] = 1.;
	else
		Y[18] = Y[46];
	Y[48] = 0.;
	Y[47] = 1.;
	if( Y[85]==1. )
		Y[57] = 0.;
	else
		Y[57] = fabs(Y[48]);
	M[0] = -1.;
	Z[0] = 0.2982456140350877193*Y[6];
	Z[1] = cos(Z[0]);
	Z[0] = sin(Z[0]);
	Z[2] = -4.430588537718271921e-07*Z[1]-1.149810619910374036e-06*Z[0];
	Z[3] = -4.840045108533975192e-06;
	Z[4] = Z[1]*Z[3]-9.999970063317986742e-06*Z[0];
	Z[3] = Z[0]*Z[3]+9.999970063317986742e-06*Z[1];
	Z[0] = -4.430588537718271921e-07*Z[0]+1.149810619910374036e-06*Z[1];
	Z[1] = Z[4]-Z[2];
	Z[5] = Z[3]-Z[0];
	Z[6] = Y[7]*Y[7];
	Z[7] = 0.1293029763919466115;
	Z[8] = 0.03856404559058056833;
	Z[9] = 0.4339536129058066533;
	V[0] = Z[0]*(YP[7]*Z[5]*Z[7]+Z[1]*Z[6]*Z[8]+0.4335452737847621679*YP[1])+Z[3]*((Z[0]*Z[7]-Z[3]*Z[9])*YP[7]+Z[6]*(Z[2]*Z[8]-0.129424761743837072*Z[4])-1.455020937390057602*YP[1])-Z[2]*(Z[5]*Z[6]*Z[8]-Z[1]*Z[7]*YP[7])-Z[4]*((Z[4]*Z[9]-Z[2]*Z[7])*YP[7]+Z[6]*(Z[0]*Z[8]-0.129424761743837072*Z[3]))-0.00002982456140350877193*Y[7]-0.0002096821176339954068*YP[7];
	if( M[0]==0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Y[63] = V[0]/M[0];
	if( Y[85]==1. )
		Y[19] = 1.;
	else
		Y[19] = Y[47];
	Y[49] = 0.;
	if( Y[85]==1. )
		Y[58] = 0.;
	else
		Y[58] = fabs(Y[49]);
	if( (Y[106]==1.) && (Y[107]==1.) )
		Y[59] = 0.5*Y[57];
	else {
		Z[0] = 1.0/Y[19]-Y[18];
		Z[0] = 1.0/Z[0];
		Y[59] = 1.*(Y[58]-Y[57])*Z[0];
	}
	M[0] = -1.;
	Z[0] = cos(Y[4]);
	Z[1] = sin(Y[4]);
	Z[2] = -0.00002522860511691704896*Z[1]-0.00003411484968640632001*Z[0];
	Z[0] = -0.00002522860511691704896*Z[0]+0.00003411484968640632001*Z[1];
	Z[1] = Y[5]*Y[5];
	Z[3] = -0.1260862173534897399;
	V[0] = Z[3]*(Z[0]*(Z[0]*YP[5]-Z[1]*Z[2])+Z[2]*(Z[2]*YP[5]+Z[0]*Z[1]))-0.0005*Y[5]-0.00001471871816576617*YP[5];
	if( M[0]==0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Y[26] = V[0]/M[0];
	M[0] = -1.;
	Z[0] = cos(Y[6]);
	Z[1] = sin(Y[6]);
	Z[2] = 0.00001775636314077511021*Z[1]+0.00003853424339345102039*Z[0];
	Z[0] = -0.00001775636314077511021*Z[0]+0.00003853424339345102039*Z[1];
	Z[1] = Y[7]*Y[7];
	Z[3] = -0.1260862329545794117;
	V[0] = Z[3]*(Z[0]*(Z[0]*YP[7]+Z[1]*Z[2]+YP[1])+Z[2]*(Z[2]*YP[7]-Z[0]*Z[1]))-0.0005*Y[7]-0.00001471871671053671071*YP[7];
	if( M[0]==0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Y[27] = V[0]/M[0];
	for(ti1=0;ti1<=4;ti1++)
		for(ti2=0;ti2<=4;ti2++)
			M[ti1*10+ti2] = 0.;
	for(ti1=0;ti1<=4;ti1++)
		V[ti1] = 0.;
	M[0] = 1.;
	M[33] = 1.;
	M[34] = -1.;
	if( Y[85]!=1. ) {
		if( (Y[99]==1.) || (Y[87]==1.) ) {
			M[1] = -1.;
			V[3] = -Y[59];
		}
		else {
			M[2] = -1.;
			V[3] = Y[59];
		}
	}
	M[11] = 1.;
	M[22] = 1.;
	if( Y[103]==1. ) {
		M[14] = Y[18]-1.;
		V[1] = Y[57];
		M[24] = (1.-Y[19])/Y[19];
		V[2] = -Y[58];
	}
	else {
		M[14] = (1.-Y[19])/Y[19];
		V[1] = Y[58];
		M[24] = Y[18]-1.;
		V[2] = -Y[57];
	}
	M[40] = -3.352941176470588235;
	M[44] = 3.352941176470588235;
	if( Y[95]==1. )
		V[4] = Y[63]+0.01+0.00073909830007390983*Y[61];
	else if( Y[94]==1. )
		V[4] = Y[63]-0.01+0.00073909830007390983*Y[61];
	else if( Y[81]==1. )
		V[4] = Y[63]+0.01+0.00073909830007390983*Y[61];
	else
		V[4] = Y[63]-0.01+0.00073909830007390983*Y[61];
	LSQDecompSolve(5,M,10,P,V);
	if( P[4]==0 ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Y[20] = V[0];
	Y[55] = V[1];
	Y[56] = V[2];
	Y[21] = V[3];
	Y[25] = V[4];
	Z[0] = ((1.-Y[19])*Y[25])/Y[19];
	Y[53] = -(Z[0]+Y[58]);
	Y[51] = Y[58]-Z[0];
	Z[0] = (1.-Y[18])*Y[25];
	Y[52] = Z[0]-Y[57];
	Y[50] = Z[0]+Y[57];
	Y[54] = Y[17]+Y[20];
	if( Y[91]==1. )
		Y[22] = 0.01;
	else if( Y[90]==1. )
		Y[22] = -0.01;
	else if( Y[77]==1. )
		Y[22] = 0.01;
	else
		Y[22] = -0.01;
	if( Y[93]==1. )
		Y[23] = 0.01;
	else if( Y[92]==1. )
		Y[23] = -0.01;
	else if( Y[79]==1. )
		Y[23] = 0.01;
	else
		Y[23] = -0.01;
}

static void otp(double T, double *Y, double *YP)
{
	UNUSED(T);
	UNUSED(YP);
	Y[66] = 1000.*Y[0];
	Y[67] = 1000.*Y[2];
	Y[68] = Y[26]+Y[22]+Y[24];
	Y[69] = -(Y[27]+Y[23]+Y[25]);
}

static void auxp(double T, double *Y, double *YP, double *R)
{
	double Z[5];

	UNUSED(T);
	UNUSED(YP);
	Z[0] = cos(Y[6]);
	Z[1] = sin(Y[6]);
	Z[2] = -0.03853424339345102039;
	Z[3] = 1000.*Y[0];
	R[0] = Z[0]*Z[2]+Z[3]-0.01775636314077511021*Z[1]+217.504500985827413;
	R[1] = Z[1]*Z[2]+0.01775636314077511021*Z[0]+284.6346609707052722;
	Z[2] = atan2(0.,Z[0]);
	R[2] = 57.2957795130823208*Z[2];
	Z[4] = cos(Z[2]);
	R[3] = 57.2957795130823208*atan2(-Z[1],Z[0]*Z[4]);
	R[4] = 57.2957795130823208*atan2(-Z[1]*sin(Z[2]),Z[4]);
	R[5] = Z[3]+217.5417779031954501;
	R[6] = 1000.*Y[2]-495.0964543967238207;
	R[7] = Z[3]+175.8053150814549715;
	Z[0] = 0.2982456140350877193*Y[4];
	Z[1] = cos(Z[0]);
	Z[0] = sin(Z[0]);
	R[8] = 57.2957795130823208*atan2(0.,Z[0]*Z[0]+Z[1]*Z[1]);
	R[9] = 57.2957795130823208*atan2(-Z[0],Z[1]);
	Z[0] = 0.2982456140350877193*Y[6];
	Z[1] = cos(Z[0]);
	Z[0] = sin(Z[0]);
	R[10] = Z[3]+0.004840045108533975192*Z[1]+0.009999970063317986742*Z[0]+217.499999999999975;
	R[11] = 0.004840045108533975192*Z[0]-0.009999970063317986742*Z[1]+144.0000000000000047;
	Z[2] = atan2(0.,Z[1]);
	R[12] = 57.2957795130823208*Z[2];
	Z[3] = cos(Z[2]);
	R[13] = 57.2957795130823208*atan2(-Z[0],Z[1]*Z[3]);
	R[14] = 57.2957795130823208*atan2(-Z[0]*sin(Z[2]),Z[3]);
	Z[0] = cos(Y[4]);
	Z[1] = sin(Y[4]);
	R[15] = 0.02522860511691704896*Z[1]+0.03411484968640632001*Z[0]-638.0003390593296302;
	R[16] = 0.02522860511691704896*Z[0]-0.03411484968640632001*Z[1]-109.6446609406748598;
	R[17] = 57.2957795130823208*atan2(0.,Z[0]*Z[0]+Z[1]*Z[1]);
	R[18] = 57.2957795130823208*atan2(-Z[1],Z[0]);
}

static void Rblkp(double T, double *Y, double *R, int prb, int code)
{
	UNUSED(T);
	if( prb==0 )
		R[0] = 2.;
	else if( prb==1 ) {
		if( code==1 ) {
			R[0] = 1.;
			R[1] = 1.;
		}
		else if( code==2 )
			R[0] = 6.;
		else if( code==3 )
			R[0] = Y[5]-Y[72];
	}
	else if( prb==2 ) {
		if( code==1 ) {
			R[0] = 1.;
			R[1] = 1.;
		}
		else if( code==2 )
			R[0] = 8.;
		else if( code==3 )
			R[0] = Y[7]-Y[73];
	}
}

static void Jblkp(double T, double *Y, double *J, int prb)
{
	int ti1, ti2;

	UNUSED(T);
	if( prb==1 ) {
		for(ti1=0;ti1<=0;ti1++)
			for(ti2=0;ti2<=0;ti2++)
				J[ti1*8+ti2] = 0.;
		J[0] = 1.;
	}
	else if( prb==2 ) {
		for(ti1=0;ti1<=0;ti1++)
			for(ti2=0;ti2<=0;ti2++)
				J[ti1*8+ti2] = 0.;
		J[0] = 1.;
	}
}

static void eev(double T, double *Y, double *Ypre, double *EA)
{
	double Z[4];

	UNUSED(T);
	UNUSED(Ypre);
	EA[0] = Y[16];
	EA[1] = Y[21];
	EA[2] = -fabs(1.-Y[13])+1e-15;
	EA[3] = -fabs(1.-Y[14])+1e-15;
	EA[4] = -fabs(1.-Y[18])+1e-15;
	EA[5] = -fabs(1.-Y[19])+1e-15;
	EA[6] = Y[12]+Y[15];
	EA[7] = Y[17]+Y[20];
	EA[8] = Y[5];
	EA[9] = Y[7];
	EA[10] = Y[9];
	EA[11] = Y[10];
	Z[0] = 1e-10*Y[5];
	EA[12] = Z[0]-1.;
	Z[1] = 1e-10*Y[7];
	EA[13] = Z[1]-1.;
	Z[2] = 2.982456140350877193e-11*Y[5];
	EA[14] = Z[2]-1.;
	Z[3] = 2.982456140350877193e-11*Y[7];
	EA[15] = Z[3]-1.;
	EA[16] = Y[8]-0.05;
	EA[17] = Y[11]-0.05;
	EA[18] = Y[8]-0.01;
	EA[19] = Y[9]-0.01;
	EA[20] = Y[10]-0.01;
	EA[21] = Y[11]-0.01;
	EA[22] = -(1.+Z[0]);
	EA[23] = -(1.+Z[1]);
	EA[24] = -(1.+Z[2]);
	EA[25] = -(1.+Z[3]);
	EA[26] = -Y[8]-0.05;
	EA[27] = -Y[8]-0.01;
	EA[28] = -Y[9]-0.01;
	EA[29] = -Y[10]-0.01;
	EA[30] = -Y[11]-0.05;
	EA[31] = -Y[11]-0.01;
}

static int eex(int N, double T, double *Y, double *Ypre)
{
	double Z[4];

	UNUSED(T);
	if( N<17 ) {
		if( N==1 )
			Y[102] = 1.-Y[102];
		else if( N==2 )
			Y[103] = 1.-Y[103];
		else if( N==3 )
			Y[104] = 1.-Y[104];
		else if( N==4 )
			Y[105] = 1.-Y[105];
		else if( N==5 )
			Y[106] = 1.-Y[106];
		else if( N==6 )
			Y[107] = 1.-Y[107];
		else if( N==7 )
			Y[108] = 1.-Y[108];
		else if( N==8 )
			Y[109] = 1.-Y[109];
		else if( N==9 )
			Y[110] = 1.-Y[110];
		else if( N==10 )
			Y[111] = 1.-Y[111];
		else if( N==11 )
			Y[112] = 1.-Y[112];
		else if( N==12 )
			Y[113] = 1.-Y[113];
		else if( N==13 )
			Y[114] = 1.-Y[114];
		else if( N==14 )
			Y[115] = 1.-Y[115];
		else if( N==15 )
			Y[116] = 1.-Y[116];
		else if( N==16 )
			Y[117] = 1.-Y[117];
	}
	else if( N<33 ) {
		if( N==17 )
			Y[118] = 1.-Y[118];
		else if( N==18 )
			Y[119] = 1.-Y[119];
		else if( N==19 )
			Y[120] = 1.-Y[120];
		else if( N==20 )
			Y[121] = 1.-Y[121];
		else if( N==21 )
			Y[122] = 1.-Y[122];
		else if( N==22 )
			Y[123] = 1.-Y[123];
		else if( N==23 )
			Y[124] = 1.-Y[124];
		else if( N==24 )
			Y[125] = 1.-Y[125];
		else if( N==25 )
			Y[126] = 1.-Y[126];
		else if( N==26 )
			Y[127] = 1.-Y[127];
		else if( N==27 )
			Y[128] = 1.-Y[128];
		else if( N==28 )
			Y[129] = 1.-Y[129];
		else if( N==29 )
			Y[130] = 1.-Y[130];
		else if( N==30 )
			Y[131] = 1.-Y[131];
		else if( N==31 )
			Y[132] = 1.-Y[132];
		else if( N==32 )
			Y[133] = 1.-Y[133];
	}
	else if( N==33 ) {
		Z[0] = Y[5];
		Z[1] = Y[7];
		Z[2] = 0.2982456140350877193*Y[5];
		Z[3] = 0.2982456140350877193*Y[7];
		if( ( ( (Ypre[75]==0.) && ( (Y[118]==1.) || ( (Ypre[89]==1.) && (Y[120]==1.) ) ) ) || ( (Ypre[75]==-1.) && (Y[116]==1.) ) ) || ( (Y[100]==1.) && (Z[2]>0.) ) )
			Y[89] = 1.;
		else
			Y[89] = 0.;
		if( ( ( (Ypre[75]==0.) && ( (Y[128]==1.) || ( (Ypre[88]==1.) && (Y[129]==1.) ) ) ) || ( (Ypre[75]==1.) && (Y[126]==1.) ) ) || ( (Y[100]==1.) && (Z[2]<0.) ) )
			Y[88] = 1.;
		else
			Y[88] = 0.;
		Y[82] = 1.;
		if( ( ( (Ypre[81]==0.) && ( (Y[119]==1.) || ( (Ypre[95]==1.) && (Y[123]==1.) ) ) ) || ( (Ypre[81]==-1.) && (Y[117]==1.) ) ) || ( (Y[100]==1.) && (Z[3]>0.) ) )
			Y[95] = 1.;
		else
			Y[95] = 0.;
		if( ( ( (Ypre[81]==0.) && ( (Y[132]==1.) || ( (Ypre[94]==1.) && (Y[133]==1.) ) ) ) || ( (Ypre[81]==1.) && (Y[127]==1.) ) ) || ( (Y[100]==1.) && (Z[3]<0.) ) )
			Y[94] = 1.;
		else
			Y[94] = 0.;
		Y[85] = 1.;
		if( ( (Ypre[84]==0.) && (Y[108]==1.) ) || ( (Y[100]==1.) && (Z[0]>0.) ) )
			Y[97] = 1.;
		else
			Y[97] = 0.;
		if( ( (Ypre[84]==0.) && (Y[108]==0.) ) || ( (Y[100]==1.) && (Z[0]<0.) ) )
			Y[96] = 1.;
		else
			Y[96] = 0.;
		if( ( ( (Ypre[77]==0.) && ( (Y[112]==1.) || ( (Ypre[91]==1.) && (Y[121]==1.) ) ) ) || ( (Ypre[77]==-1.) && (Y[114]==1.) ) ) || ( (Y[100]==1.) && (Y[5]>0.) ) )
			Y[91] = 1.;
		else
			Y[91] = 0.;
		if( ( ( (Ypre[77]==0.) && ( (Y[112]==0.) || ( (Ypre[90]==1.) && (Y[130]==1.) ) ) ) || ( (Ypre[77]==1.) && (Y[124]==1.) ) ) || ( (Y[100]==1.) && (Y[5]<0.) ) )
			Y[90] = 1.;
		else
			Y[90] = 0.;
		if( ( (Ypre[87]==0.) && (Y[109]==1.) ) || ( (Y[100]==1.) && (Z[1]>0.) ) )
			Y[99] = 1.;
		else
			Y[99] = 0.;
		if( ( (Ypre[87]==0.) && (Y[109]==0.) ) || ( (Y[100]==1.) && (Z[1]<0.) ) )
			Y[98] = 1.;
		else
			Y[98] = 0.;
		if( ( ( (Ypre[79]==0.) && ( (Y[113]==1.) || ( (Ypre[93]==1.) && (Y[122]==1.) ) ) ) || ( (Ypre[79]==-1.) && (Y[115]==1.) ) ) || ( (Y[100]==1.) && (Y[7]>0.) ) )
			Y[93] = 1.;
		else
			Y[93] = 0.;
		if( ( ( (Ypre[79]==0.) && ( (Y[113]==0.) || ( (Ypre[92]==1.) && (Y[131]==1.) ) ) ) || ( (Ypre[79]==1.) && (Y[125]==1.) ) ) || ( (Y[100]==1.) && (Y[7]<0.) ) )
			Y[92] = 1.;
		else
			Y[92] = 0.;
		if( ( ( (Ypre[75]==1.) || (Ypre[75]==2.) ) || (Y[89]==1.) ) && (Y[110]==1.) )
			Y[75] = 1.;
		else {
			if( ( ( (Ypre[75]==-1.) || (Ypre[75]==2.) ) || (Y[88]==1.) ) && (Y[110]==0.) )
				Y[75] = -1.;
			else
				Y[75] = 0.;
		}
		if( ( ( (Ypre[81]==1.) || (Ypre[81]==2.) ) || (Y[95]==1.) ) && (Y[111]==1.) )
			Y[81] = 1.;
		else {
			if( ( ( (Ypre[81]==-1.) || (Ypre[81]==2.) ) || (Y[94]==1.) ) && (Y[111]==0.) )
				Y[81] = -1.;
			else
				Y[81] = 0.;
		}
		if( Y[82]==1. )
			Y[84] = 2.;
		else {
			if( ( (Ypre[84]==1.) || (Y[97]==1.) ) && (Y[110]==1.) )
				Y[84] = 1.;
			else {
				if( ( (Ypre[84]==-1.) || (Y[96]==1.) ) && (Y[110]==0.) )
					Y[84] = -1.;
				else
					Y[84] = 0.;
			}
		}
		if( ( ( (Ypre[77]==1.) || (Ypre[77]==2.) ) || (Y[91]==1.) ) && (Y[110]==1.) )
			Y[77] = 1.;
		else {
			if( ( ( (Ypre[77]==-1.) || (Ypre[77]==2.) ) || (Y[90]==1.) ) && (Y[110]==0.) )
				Y[77] = -1.;
			else
				Y[77] = 0.;
		}
		if( Y[85]==1. )
			Y[87] = 2.;
		else {
			if( ( (Ypre[87]==1.) || (Y[99]==1.) ) && (Y[111]==1.) )
				Y[87] = 1.;
			else {
				if( ( (Ypre[87]==-1.) || (Y[98]==1.) ) && (Y[111]==0.) )
					Y[87] = -1.;
				else
					Y[87] = 0.;
			}
		}
		if( ( ( (Ypre[79]==1.) || (Ypre[79]==2.) ) || (Y[93]==1.) ) && (Y[111]==1.) )
			Y[79] = 1.;
		else {
			if( ( ( (Ypre[79]==-1.) || (Ypre[79]==2.) ) || (Y[92]==1.) ) && (Y[111]==0.) )
				Y[79] = -1.;
			else
				Y[79] = 0.;
		}
		if( !( ( ( ( (Y[82]==1.) || (Ypre[84]==1.) ) || (Y[97]==1.) ) || (Ypre[84]==-1.) ) || (Y[96]==1.) ) )
			Y[83] = 1.;
		else
			Y[83] = 0.;
		if( !( ( ( ( (Y[85]==1.) || (Ypre[87]==1.) ) || (Y[99]==1.) ) || (Ypre[87]==-1.) ) || (Y[98]==1.) ) )
			Y[86] = 1.;
		else
			Y[86] = 0.;
		if( ( !( ( ( ( (Ypre[75]==2.) || (Ypre[75]==1.) ) || (Y[89]==1.) ) || (Ypre[75]==-1.) ) || (Y[88]==1.) ) ) || ( ( ( ( (Y[75]==0.) && ( !(Y[89]==1.) ) ) && ( !(Y[88]==1.) ) ) && ( !(Ypre[89]==1.) ) ) && ( !(Ypre[88]==1.) ) ) )
			Y[74] = 1.;
		else
			Y[74] = 0.;
		if( ( !( ( ( ( (Ypre[77]==2.) || (Ypre[77]==1.) ) || (Y[91]==1.) ) || (Ypre[77]==-1.) ) || (Y[90]==1.) ) ) || ( ( ( ( (Y[77]==0.) && ( !(Y[91]==1.) ) ) && ( !(Y[90]==1.) ) ) && ( !(Ypre[91]==1.) ) ) && ( !(Ypre[90]==1.) ) ) )
			Y[76] = 1.;
		else
			Y[76] = 0.;
		if( ( !( ( ( ( (Ypre[79]==2.) || (Ypre[79]==1.) ) || (Y[93]==1.) ) || (Ypre[79]==-1.) ) || (Y[92]==1.) ) ) || ( ( ( ( (Y[79]==0.) && ( !(Y[93]==1.) ) ) && ( !(Y[92]==1.) ) ) && ( !(Ypre[93]==1.) ) ) && ( !(Ypre[92]==1.) ) ) )
			Y[78] = 1.;
		else
			Y[78] = 0.;
		if( ( !( ( ( ( (Ypre[81]==2.) || (Ypre[81]==1.) ) || (Y[95]==1.) ) || (Ypre[81]==-1.) ) || (Y[94]==1.) ) ) || ( ( ( ( (Y[81]==0.) && ( !(Y[95]==1.) ) ) && ( !(Y[94]==1.) ) ) && ( !(Ypre[95]==1.) ) ) && ( !(Ypre[94]==1.) ) ) )
			Y[80] = 1.;
		else
			Y[80] = 0.;
		if( !( (Y[74]==0.) || (Y[74]==1.) ) ) {
			Y[101] = 1.;
			return(1);
		}
		if( !( (Y[76]==0.) || (Y[76]==1.) ) ) {
			Y[101] = 5.;
			return(1);
		}
		if( !( (Y[78]==0.) || (Y[78]==1.) ) ) {
			Y[101] = 9.;
			return(1);
		}
		if( !( (Y[80]==0.) || (Y[80]==1.) ) ) {
			Y[101] = 13.;
			return(1);
		}
		if( !( (Y[82]==0.) || (Y[82]==1.) ) ) {
			Y[101] = 17.;
			return(1);
		}
		if( !( (Y[83]==0.) || (Y[83]==1.) ) ) {
			Y[101] = 18.;
			return(1);
		}
		if( !( (Y[102]==0.) || (Y[102]==1.) ) ) {
			Y[101] = 22.;
			return(1);
		}
		if( !( (Y[85]==0.) || (Y[85]==1.) ) ) {
			Y[101] = 23.;
			return(1);
		}
		if( !( (Y[86]==0.) || (Y[86]==1.) ) ) {
			Y[101] = 24.;
			return(1);
		}
		if( !( (Y[103]==0.) || (Y[103]==1.) ) ) {
			Y[101] = 28.;
			return(1);
		}
		if( !( (Y[88]==0.) || (Y[88]==1.) ) ) {
			Y[101] = 3.;
			return(1);
		}
		if( !( (Y[89]==0.) || (Y[89]==1.) ) ) {
			Y[101] = 4.;
			return(1);
		}
		if( !( (Y[90]==0.) || (Y[90]==1.) ) ) {
			Y[101] = 7.;
			return(1);
		}
		if( !( (Y[91]==0.) || (Y[91]==1.) ) ) {
			Y[101] = 8.;
			return(1);
		}
		if( !( (Y[92]==0.) || (Y[92]==1.) ) ) {
			Y[101] = 11.;
			return(1);
		}
		if( !( (Y[93]==0.) || (Y[93]==1.) ) ) {
			Y[101] = 12.;
			return(1);
		}
		if( !( (Y[94]==0.) || (Y[94]==1.) ) ) {
			Y[101] = 15.;
			return(1);
		}
		if( !( (Y[95]==0.) || (Y[95]==1.) ) ) {
			Y[101] = 16.;
			return(1);
		}
		if( !( (Y[96]==0.) || (Y[96]==1.) ) ) {
			Y[101] = 20.;
			return(1);
		}
		if( !( (Y[97]==0.) || (Y[97]==1.) ) ) {
			Y[101] = 21.;
			return(1);
		}
		if( !( (Y[98]==0.) || (Y[98]==1.) ) ) {
			Y[101] = 26.;
			return(1);
		}
		if( !( (Y[99]==0.) || (Y[99]==1.) ) ) {
			Y[101] = 27.;
			return(1);
		}
		if( !(floor(Y[75]+0.5)==Y[75]) ) {
			Y[101] = 2.;
			return(1);
		}
		if( !(floor(Y[77]+0.5)==Y[77]) ) {
			Y[101] = 6.;
			return(1);
		}
		if( !(floor(Y[79]+0.5)==Y[79]) ) {
			Y[101] = 10.;
			return(1);
		}
		if( !(floor(Y[81]+0.5)==Y[81]) ) {
			Y[101] = 14.;
			return(1);
		}
		if( !(floor(Y[84]+0.5)==Y[84]) ) {
			Y[101] = 19.;
			return(1);
		}
		if( !(floor(Y[87]+0.5)==Y[87]) ) {
			Y[101] = 25.;
			return(1);
		}
		if( Y[100]==1. )
			Y[100] = 0.;
	}
	return(0);
}

static int cpr(double T, double *Y)
{
	double v;
	int k;

	UNUSED(T);
	k = 0;
	if( Y[16]>=0. )
		v = 1.;
	else
		v = 0.;
	if( Y[102]!=v ) {
		Y[102] = v;
		k = 1;
	}
	if( Y[21]>=0. )
		v = 1.;
	else
		v = 0.;
	if( Y[103]!=v ) {
		Y[103] = v;
		k = 1;
	}
	if( fabs(Y[13]-1.)<=1e-15 )
		v = 1.;
	else
		v = 0.;
	if( Y[104]!=v ) {
		Y[104] = v;
		k = 1;
	}
	if( fabs(Y[14]-1.)<=1e-15 )
		v = 1.;
	else
		v = 0.;
	if( Y[105]!=v ) {
		Y[105] = v;
		k = 1;
	}
	if( fabs(Y[18]-1.)<=1e-15 )
		v = 1.;
	else
		v = 0.;
	if( Y[106]!=v ) {
		Y[106] = v;
		k = 1;
	}
	if( fabs(Y[19]-1.)<=1e-15 )
		v = 1.;
	else
		v = 0.;
	if( Y[107]!=v ) {
		Y[107] = v;
		k = 1;
	}
	if( Y[12]+Y[15]>0. )
		v = 1.;
	else
		v = 0.;
	if( Y[108]!=v ) {
		Y[108] = v;
		k = 1;
	}
	if( Y[17]+Y[20]>0. )
		v = 1.;
	else
		v = 0.;
	if( Y[109]!=v ) {
		Y[109] = v;
		k = 1;
	}
	if( Y[5]>0. )
		v = 1.;
	else
		v = 0.;
	if( Y[110]!=v ) {
		Y[110] = v;
		k = 1;
	}
	if( Y[7]>0. )
		v = 1.;
	else
		v = 0.;
	if( Y[111]!=v ) {
		Y[111] = v;
		k = 1;
	}
	if( Y[9]>0. )
		v = 1.;
	else
		v = 0.;
	if( Y[112]!=v ) {
		Y[112] = v;
		k = 1;
	}
	if( Y[10]>0. )
		v = 1.;
	else
		v = 0.;
	if( Y[113]!=v ) {
		Y[113] = v;
		k = 1;
	}
	if( Y[5]>1e10 )
		v = 1.;
	else
		v = 0.;
	if( Y[114]!=v ) {
		Y[114] = v;
		k = 1;
	}
	if( Y[7]>1e10 )
		v = 1.;
	else
		v = 0.;
	if( Y[115]!=v ) {
		Y[115] = v;
		k = 1;
	}
	if( 0.2982456140350877193*Y[5]>1e10 )
		v = 1.;
	else
		v = 0.;
	if( Y[116]!=v ) {
		Y[116] = v;
		k = 1;
	}
	if( 0.2982456140350877193*Y[7]>1e10 )
		v = 1.;
	else
		v = 0.;
	if( Y[117]!=v ) {
		Y[117] = v;
		k = 1;
	}
	if( Y[8]>0.05 )
		v = 1.;
	else
		v = 0.;
	if( Y[118]!=v ) {
		Y[118] = v;
		k = 1;
	}
	if( Y[11]>0.05 )
		v = 1.;
	else
		v = 0.;
	if( Y[119]!=v ) {
		Y[119] = v;
		k = 1;
	}
	if( Y[8]>0.01 )
		v = 1.;
	else
		v = 0.;
	if( Y[120]!=v ) {
		Y[120] = v;
		k = 1;
	}
	if( Y[9]>0.01 )
		v = 1.;
	else
		v = 0.;
	if( Y[121]!=v ) {
		Y[121] = v;
		k = 1;
	}
	if( Y[10]>0.01 )
		v = 1.;
	else
		v = 0.;
	if( Y[122]!=v ) {
		Y[122] = v;
		k = 1;
	}
	if( Y[11]>0.01 )
		v = 1.;
	else
		v = 0.;
	if( Y[123]!=v ) {
		Y[123] = v;
		k = 1;
	}
	if( Y[5]<-1e10 )
		v = 1.;
	else
		v = 0.;
	if( Y[124]!=v ) {
		Y[124] = v;
		k = 1;
	}
	if( Y[7]<-1e10 )
		v = 1.;
	else
		v = 0.;
	if( Y[125]!=v ) {
		Y[125] = v;
		k = 1;
	}
	if( 0.2982456140350877193*Y[5]<-1e10 )
		v = 1.;
	else
		v = 0.;
	if( Y[126]!=v ) {
		Y[126] = v;
		k = 1;
	}
	if( 0.2982456140350877193*Y[7]<-1e10 )
		v = 1.;
	else
		v = 0.;
	if( Y[127]!=v ) {
		Y[127] = v;
		k = 1;
	}
	if( Y[8]<-0.05 )
		v = 1.;
	else
		v = 0.;
	if( Y[128]!=v ) {
		Y[128] = v;
		k = 1;
	}
	if( Y[8]<-0.01 )
		v = 1.;
	else
		v = 0.;
	if( Y[129]!=v ) {
		Y[129] = v;
		k = 1;
	}
	if( Y[9]<-0.01 )
		v = 1.;
	else
		v = 0.;
	if( Y[130]!=v ) {
		Y[130] = v;
		k = 1;
	}
	if( Y[10]<-0.01 )
		v = 1.;
	else
		v = 0.;
	if( Y[131]!=v ) {
		Y[131] = v;
		k = 1;
	}
	if( Y[11]<-0.05 )
		v = 1.;
	else
		v = 0.;
	if( Y[132]!=v ) {
		Y[132] = v;
		k = 1;
	}
	if( Y[11]<-0.01 )
		v = 1.;
	else
		v = 0.;
	if( Y[133]!=v ) {
		Y[133] = v;
		k = 1;
	}
	return(k);
}

/*
	Projection: Use Rblkp, Jblkp constraint residual and Jacobian functions
	to project the input solution back onto the constraint manfold.

	Return codes:
	0 - Successful completion
	1 - Entry of Residual or Jacobian is undefined/infinity
	2 - Row of Jacobian is zero, but residual is nonzero
	3 - Iteration limit reached
*/
static int Projection(
	double t,		/* Current time */
	double *x,		/* Current solution (updated) */
	double tol,		/* Tolerance limit for iteration */
	int maxiter,/* Max iteration limit */
	double *w,		/* Weight vector */
	double *psto		/* Projecion storage */
)
{
	int i, j, k, c, r, iter, n, nc, nc2, cb, nblk;
	int per[NDIFF], varmap[NDIFF];
	M_INT ip[NDIFF];
	double scl, resmag, val, val2, *R, *J, *A, *iA;
	double der[NDIFF];

	/* Set up storage */
	R=psto; psto+=NDIFF;
	J=psto; psto+=NCON*NDIFF;
	A=psto; psto+=NDIFF*NDIFF;
	iA=psto;

	/* Get number of blocks */
	Rblkp(t, x, R, 0, 0); 
	nblk = (int)(R[0]);
	for(cb=1;cb<=nblk;cb++) {
		/* Get problem size */
		Rblkp(t, x, R, cb, 1); 
		nc = (int)(R[0]);
		n = (int)(R[1]);
		/* Get dep. variable mapping */
		Rblkp(t, x, R, cb, 2); 
		for(i=0;i<n;i++) varmap[i]=(int)(R[i])-1;

		for(iter=0;iter<maxiter;iter++) {

			/* Reset var. mapping */
			for(i=0;i<n;i++) per[i]=varmap[i];
	/* Compute the Jacobian and Residual at the current solution */
			Rblkp(t, x, R, cb, 3);
			Jblkp(t, x, J, cb);

	/* Scale the columns by the weight factor */
	if( w ) {
				for(j=0;j<n;j++)
					for(i=0;i<nc;i++)
						J[NDIFF*i+j] /= w[per[j]];
	}

	/* Rescale rows of Jacobian so that maximum coeff is 1, validating */
	resmag = 0.0;
			for(i=0;i<nc;i++) {
		if( IS_UNDEF(R[i]) ) return(1);
		val = 0.0;
				for(j=0;j<n;j++) {
			if( IS_UNDEF(J[i*NDIFF+j]) ) return(1);
			val2 = fabs(J[i*NDIFF+j]);
			if( val2>val ) val = val2;
		}
		if( val==0. ) {
			if( R[i]!=0. )
				return(2);
		}
		else {
			val = 1.0/val;
					for(j=0;j<n;j++) J[i*NDIFF+j] *= val;
			R[i] *= val;
			resmag += R[i]*R[i];
		}
	}

	/* Compute J_hat from J
		The solving process will select the row with the largest residual,
		then choose the largest coeff, computing an approx.  of the condition
		as we go, stopping when the condition becomes too poor. */
			nc2 = nc;
	scl = 1.0;
	i = 0;
	while( i<nc2 ) {
		/* Search for row with largest residual */
		resmag = fabs(R[i]); r = i;
		for(j=i+1;j<nc2;j++) {
			val2 = fabs(R[j]);
			if( val2>resmag ) { resmag = val2; r = j; }
		}
		/* Check for termination on the first row */
				if( i==0 && resmag<=tol ) {
					nc2 = n+1; break;
		}

		/* Row 'r' has largest residual 'val', locate column with
			largest coeff */
		val = fabs(J[r*NDIFF+i]); c = i;
				for(j=i+1;j<n;j++) {
			val2 = fabs(J[r*NDIFF+j]);
			if( val2>val ) { val = val2; c = j; }
		}

		if( scl*val<sqrt(tol) )  {
			/* Coefficient is too small - remove row */
			if( r!=nc2-1 ) {
						for(j=0;j<n;j++) J[r*NDIFF+j] = J[(nc2-1)*NDIFF+j];
				R[r] = R[nc2-1];
			}
			nc2--;
		}
		else {
			/* Adjust condition estimate */
			scl *= val;
			/* Row/Column exchanges */
			if( c!=i ) {
				for(j=0;j<nc2;j++) { val=J[j*NDIFF+i]; J[j*NDIFF+i]=J[j*NDIFF+c]; J[j*NDIFF+c]=val; }
				j=per[i]; per[i]=per[c]; per[c]=j;
			}
			if( r!=i ) {
						for(j=i;j<n;j++) { val=J[i*NDIFF+j]; J[i*NDIFF+j]=J[r*NDIFF+j]; J[r*NDIFF+j]=val; }
				val=R[i]; R[i]=R[r]; R[r]=val;
			}
			/* Rescale if necessary */
			if( J[i*NDIFF+i]!=1.0 ) {
				val = 1.0/J[i*NDIFF+i];
				J[i*NDIFF+i] = 1.0;
						for(j=i+1;j<n;j++) J[i*NDIFF+j] = J[i*NDIFF+j]*val;
				R[i] *= val;
			}
			/* Backsub */
			for(r=0;r<nc2;r++)
				if( r!=i && J[r*NDIFF+i]!=0.0 ) {
							for(c=i+1;c<n;c++) J[r*NDIFF+c] -= J[r*NDIFF+i]*J[i*NDIFF+c];
					R[r] -= J[r*NDIFF+i]*R[i];
					J[r*NDIFF+i] = 0.0;
				}
					if( i==n-1 ) {
						nc2=n;
				break;
			}
			else
				i++;
		}
	}
	/* Early termination: residual within bound on first row */
			if( nc2==n+1 ) break;

	/* Compute A = J_hat * J_hat^T */
	for(j=0;j<nc2;j++)
		for(i=0;i<=j;i++) {
			A[i*nc2+j] = 0.0;
					for(k=0;k<n;k++) A[i*nc2+j]+=J[i*NDIFF+k]*J[j*NDIFF+k];
		}
	for(i=0;i<nc2;i++)
		for(j=0;j<i;j++)
			A[i*nc2+j]=A[j*nc2+i];

	/* Construct (J_hat * J_hat^T)^(-1) in iA */
	for(i=0;i<nc2*nc2;i++) iA[i]=0.0;
	for(i=0;i<nc2;i++) iA[i*(1+nc2)]=1.0;
	DecompCInc(nc2, A, nc2, ip);
	MultiSolveCInc(nc2, A, nc2, ip, nc2, iA, nc2);

	/* Multiply iA (nc2 x nc2) with R (nc2 x 1) to A (nc2 x 1)
		A = (J_hat * J_hat^T)^(-1) * R */
	for(i=0;i<nc2;i++) {
		A[i] = 0.0;
		for(k=0;k<nc2;k++) A[i] += iA[i*nc2+k]*R[k];
	}

	/* Multiply J_hat^T (NDIFF x nc2) with A (nc2 x 1) to iA (NDIFF x 1)
		 iA = J_hat^T * (J_hat * J_hat^T)^(-1) * R */
			for(i=0;i<n;i++) {
		der[i] = 0.0;
		for(k=0;k<nc2;k++) der[i] += J[k*NDIFF+i]*A[k];
	}

			val=0.0; for(i=0;i<n;i++) val+=x[per[i]]*x[per[i]]; val=sqrt(val);
			val2=0.0; for(i=0;i<n;i++) val2+=der[i]*der[i]; val2=sqrt(val2);
		val = val2/((val>0.1*val2)?val:(0.1*val2));
		if( val>0.1 ) {
			/* Solution is very far off - Use relaxed */
			val2 = ( tol>0.1/val )?tol:(0.1/val);
			if( w )
					for(i=0;i<n;i++) x[per[i]]-=val2*der[i]/w[per[i]];
			else
					for(i=0;i<n;i++) x[per[i]]-=val2*der[i];
		}
		else {
			/* Direct newton */
			if( w )
					for(i=0;i<n;i++) x[per[i]]-=der[i]/w[per[i]];
			else
					for(i=0;i<n;i++) x[per[i]]-=der[i];
		}
	}
		if( iter==maxiter ) return(3);
	}
	return(0);
}

/*
	ProjectInitial: Use weighted projection to find consistent initial
	data with fixed initial values.

	Return codes:
	0 - Successful completion
	2 - Projection not converging
	3 - Iteration limit reached
*/
static int ProjectInitial(
	double t,			/* t0 */
	double *x,			/* Current solution (updated) */
	double ptol,		/* Tolerance limit for iteration for projection */
	int pmaxiter,	/* Max iteration limit for projection */
	int *icmask,	/* Fixed IC mask vector */
	double tol,		/* Convergence tolerance */
	int maxiter,	/* Max limit for number of calls to projection */
	double W,			/* Default fixed IC weight */
	double *psto		/* Projecion storage */
)
{
	int i, ip, iter;
	double delta1, delta2, val, w[NDIFF], ic[NDIFF];

	for(i=0;i<NDIFF;i++) {
		if( icmask[i]==0 )
			w[i] = 1.0;
		else {
			w[i] = W;
			ic[i] = x[i];
		}
	}

	delta1 = 1.0;
	for(iter=0;iter<maxiter;iter++) {
		/* Do weighted projection and check fixed IC deviation */
		ip=Projection(t,x,ptol,pmaxiter,w,psto);
		if( ip>0 && ip!=3 ) return(2);

		delta2 = 0.0;
		for(i=0;i<NDIFF;i++)
			if( w[i]!=1.0 ) {
				val = 0.5*(fabs(x[i])+fabs(ic[i]));
				val = ( val > 1.0e-3 ) ? val : 1.0e-3;
				delta2+=fabs((x[i]-ic[i]))/(val);
			}

		/* Return if projection converged */
		if( delta2<=tol ) break;
		/* Check for adequate convergence rate */
		if( iter>2 && (delta2/delta1 > 0.9) ) return(2);
		/* Check iteration limit */
		if( iter==maxiter-1 ) { iter++; break; }

		/* Overwrite the solution vector with fixed IC values,
		   for next pass. */
		for(i=0;i<NDIFF;i++)
			if( w[i]!=1.0 ) x[i]=ic[i];

		delta1 = delta2;
	}
	/* Check iteration limit */
	if( iter==maxiter ) return(3); else return(0);
}

static void terminate(double T, double *Y, int j)
{
	UNUSED(Y);
	if(j==1) SolverError(T,1,"variable `Main.CNC.BF2.locked`(t) must be boolean valued");
	if(j==2) SolverError(T,1,"variable `Main.CNC.BF2.mode`(t) must be integer valued");
	if(j==3) SolverError(T,1,"variable `Main.CNC.BF2.startBackward`(t) must be boolean valued");
	if(j==4) SolverError(T,1,"variable `Main.CNC.BF2.startForward`(t) must be boolean valued");
	if(j==5) SolverError(T,1,"variable `Main.CNC.BF3.locked`(t) must be boolean valued");
	if(j==6) SolverError(T,1,"variable `Main.CNC.BF3.mode`(t) must be integer valued");
	if(j==7) SolverError(T,1,"variable `Main.CNC.BF3.startBackward`(t) must be boolean valued");
	if(j==8) SolverError(T,1,"variable `Main.CNC.BF3.startForward`(t) must be boolean valued");
	if(j==9) SolverError(T,1,"variable `Main.CNC.BF4.locked`(t) must be boolean valued");
	if(j==10) SolverError(T,1,"variable `Main.CNC.BF4.mode`(t) must be integer valued");
	if(j==11) SolverError(T,1,"variable `Main.CNC.BF4.startBackward`(t) must be boolean valued");
	if(j==12) SolverError(T,1,"variable `Main.CNC.BF4.startForward`(t) must be boolean valued");
	if(j==13) SolverError(T,1,"variable `Main.CNC.BF5.locked`(t) must be boolean valued");
	if(j==14) SolverError(T,1,"variable `Main.CNC.BF5.mode`(t) must be integer valued");
	if(j==15) SolverError(T,1,"variable `Main.CNC.BF5.startBackward`(t) must be boolean valued");
	if(j==16) SolverError(T,1,"variable `Main.CNC.BF5.startForward`(t) must be boolean valued");
	if(j==17) SolverError(T,1,"variable `Main.CNC.LG1.ideal`(t) must be boolean valued");
	if(j==18) SolverError(T,1,"variable `Main.CNC.LG1.locked`(t) must be boolean valued");
	if(j==19) SolverError(T,1,"variable `Main.CNC.LG1.mode`(t) must be integer valued");
	if(j==20) SolverError(T,1,"variable `Main.CNC.LG1.startBackward`(t) must be boolean valued");
	if(j==21) SolverError(T,1,"variable `Main.CNC.LG1.startForward`(t) must be boolean valued");
	if(j==22) SolverError(T,1,"variable `Main.CNC.LG1.tau_aPos`(t) must be boolean valued");
	if(j==23) SolverError(T,1,"variable `Main.CNC.LG2.ideal`(t) must be boolean valued");
	if(j==24) SolverError(T,1,"variable `Main.CNC.LG2.locked`(t) must be boolean valued");
	if(j==25) SolverError(T,1,"variable `Main.CNC.LG2.mode`(t) must be integer valued");
	if(j==26) SolverError(T,1,"variable `Main.CNC.LG2.startBackward`(t) must be boolean valued");
	if(j==27) SolverError(T,1,"variable `Main.CNC.LG2.startForward`(t) must be boolean valued");
	if(j==28) SolverError(T,1,"variable `Main.CNC.LG2.tau_aPos`(t) must be boolean valued");
}

static void InitEventModes(double *tval, double *y,
	M_INT *modes, M_INT *req, M_INT *inc)
{
	int i;

	for(i=0;i<NEVT;i++) {
		if(tval[i]>0.0)
			modes[i]=1;
		else if(tval[i]<0.0)
			modes[i]=0;
		else if(req[i]>0) {
			if(y[req[i]-1]==1.0)
				modes[i]=1;
			else
				modes[i]=0;
		}
		else if(inc[i])
			modes[i]=0;
		else
			modes[i]=1;
	}
}

static int ComputeEventIndicators(double *tval, double *y,
	M_INT *modes, M_INT *req, M_INT *inc, M_INT *ivl)
{
	int i;

	for(i=0;i<NEVT;i++) {
		if(req[i]>0) {
			/* Requires triggers - have an assoc. state variable, so we
				know the expected state */
			if(y[req[i]-1]==1.0)
				tval[i]+=FMUHYST;
			else
				tval[i]-=FMUHYST;
		}
		else if(inc[i]) {
			/* Increase-only trigger */
			if(modes[i]==0)
				tval[i]-=FMUHYST;
			else
				tval[i]+=FMUHYST;
		}
		else if(ivl[i]>0) {
			/* Integer-shift trigger */
			tval[i]-=FMUHYST;
		}
		else return(-1); /* Bad event */
	}
	return(0);
}

static int CheckEvents(double *tval, double *yt, M_INT *modes,
	M_INT *oldmodes, M_INT *req, M_INT *inc, M_INT *ivl)
{
	int i,flag;

	flag=0;
	for(i=0;i<NEVT;i++) {
		if(req[i]>0) {
			/* Requires triggers - have an assoc. state variable, so we
				do not need to rely on 'oldmodes' */
			if(yt[req[i]]==1.0) {
				/* Switch orig in '+' state */
				if( tval[i]<-EVTHYST ) {
					oldmodes[i]=1; modes[i]=0; flag=1;
				}
				else {
					oldmodes[i]=1; modes[i]=1;
				}
			}
			else {
				/* Switch orig in '-' state */
				if( tval[i]>EVTHYST ) {
					oldmodes[i]=0; modes[i]=1; flag=1;
				}
				else {
					oldmodes[i]=0; modes[i]=0;
				}
			}
		}
		else if(inc[i]) {
			/* Increase-only triggers */
			if(oldmodes[i]==0 && tval[i]>EVTHYST) {
				modes[i]=1; flag=1;
			}
			else if(oldmodes[i]==1 && tval[i]<-EVTHYST ) {
				oldmodes[i]=0; modes[i]=0;
			}
		}
		else if(ivl[i]>0) {
			/* Integer-shift trigger */
			if(tval[i]<-EVTHYST) {
				oldmodes[i]=1; modes[i]=0; flag=1;
			}
			else {
				oldmodes[i]=1; modes[i]=1;
			}
		}
		else return(-1); /* Bad event */
	}
	return(flag);
}

static int RunEvents(double *w, M_INT *modes, int first,
	int termvar, int maxiter, double *psto)
{
	double t,*y,*yp,*ypre,*tval;
	M_INT *m=NULL,*oldmodes,*inc,*req,*ivl;
	int i,flag,iter,evt,rc,failskip;

	/* Transfer data to approp. named arrays */
	t=w[0]; y=&w[1]; yp=&y[NEQ+NPAR]; ypre=&yp[NDFA]; tval=&ypre[NEQ];
	oldmodes=&modes[NEVT]; inc=&oldmodes[NEVT]; req=&inc[NEVT], ivl=&req[NEVT];
	/* Verify that no y values are undefined */
	for(i=0;i<NEQ;i++)
		if(IS_UNDEF(y[i])) {
			if (errorOccured<=0) {
				errorOccured = 1;
				sprintf(errorString,"undefined value encountered on entry into RunEvents at t=%f",t);
			}
			return(-3);
		}
	/* Set the old modes to the new and ypre to y */
	for(i=0;i<NEVT;i++) oldmodes[i]=modes[i];
	for(i=0;i<NEQ;i++) ypre[i]=y[i];

	if(first!=1) {
		/* Check for events */
		eev(t,y,ypre,tval);
		flag=CheckEvents(tval,y-1,modes,oldmodes,req,inc,ivl);
		if(flag<0) {
			if (errorOccured<=0) {
				errorOccured = 1;
				sprintf(errorString,"internal error: bad event at t=%f",t);

			}	
			return(-5);
		}
		/* If no events, return, but still need to update modes as we may
			have a sign change for a decrease on an increase-only trigger */
		if(!first && !flag) {
			if(m) for(i=0;i<NEVT;i++) m[i]=modes[i];
			return(0);
		}
	}

	/* Iteration loop */
	failskip=0;
	for(iter=0;;iter++) {
		if( first!=1 || iter>0 )
			/* Event loop */
			for(evt=0;evt<NEVT;evt++)
				if(modes[evt]!=oldmodes[evt]) {
					rc=eex(evt+1,t,y,ypre);
					if(termvar>=0 && y[termvar]>0.0) {
						i=(int)y[termvar];
						terminate(t,y,i);
						return(i);
					}
					/* Handle RC */
					oldmodes[evt]=modes[evt];
				}

		/* Discrete equations */
		rc=eex(NEVT+1,t,y,ypre);
		/* Fail skip */
		if(rc==8 && !failskip) {
			failskip=1;
			iter--;
			if(termvar>=0) y[termvar]=0.0;
		}
		else
			failskip=0;
		if(termvar>=0 && y[termvar]>0.0) {
			i=(int)y[termvar];
			terminate(t,y,i);
			return(i);
		}
		/* Handle RC */

		/* Check for termination */
		for(i=0;i<NEQ;i++) if(y[i]!=ypre[i]) break;
		if( !failskip && i==NEQ ) {
			/* Update modes and return */
			if(m) for(i=0;i<NEVT;i++) m[i]=modes[i];
			return(0);
		}

		/* Check iter limit */
		if( iter>=maxiter ) {
			if (errorOccured<=0) {
				errorOccured = 1;
				sprintf(errorString,"maximum number of event iterations reached (%li) at t=%f",(long)iter,t);
			}
			return(-1);
		}

		/* Update index-1 equations */
		if(!failskip && NIX1>0) {
			fp(NEQ,t,y,yp);
			if( IS_UNDEF(yp[0]) ) {
				if (errorOccured<=0) {
					errorOccured = 1;
					sprintf(errorString,"index-1 and derivative evaluation failure on event at t=%f",t);
				}
				return(-2);
			}
		}
		/* Verify that no y values are undefined */
		for(i=0;i<NEQ;i++)
			if(IS_UNDEF(y[i])) {
				if (errorOccured<=0) {
					errorOccured = 1;
					sprintf(errorString,"undefined value encountered during execution of RunEvents at t=%f",t);
				}
				return(-4);
			}

		/* Projection */
		if(!failskip && EVTPROJ) i=Projection(t,y,CONTOL,CONITER,NULL,psto);

		/* Update pre */
		for(i=0;i<NEQ;i++) ypre[i]=y[i];
		if(failskip) continue;

		/* Evaluate event triggers, and update modes */
		eev(t,y,ypre,tval);
		flag=CheckEvents(tval,y-1,modes,oldmodes,req,inc,ivl);
		if(flag<0) {
			if (errorOccured<=0) {
				errorOccured = 1;
				sprintf(errorString,"internal error: bad event at t=%f",t);
			}
			return(-5);
		}
	}
	return(0);
}

static void numdiffinp(double *w, int initial, int commit)
{
	double dt1,dt2,idt1,idt2,idt12,*nd1,*nd2;

	if(!initial && !inputchange && !commit) return;
	inputchange=0;
	nd1=w+1+2*NEQ+NPAR+NDFA+NEVT;
	nd2=nd1+3;
	if(!initial && w[0]-nd1[0]>0.0) {
		dt1=w[0]-nd1[0]; idt1=1.0/dt1;
		if(nd1[0]-nd2[0]>0.0) {
			dt2=w[0]-nd2[0]; idt2=1.0/dt2;
			idt12=1.0/(nd2[0]-nd1[0]);
			w[71]=(idt1+idt2)*w[73]+idt12*(dt2*idt1*nd1[1]-dt1*idt2*nd2[1]);
			w[72]=(idt1+idt2)*w[74]+idt12*(dt2*idt1*nd1[2]-dt1*idt2*nd2[2]);
		}
		else {
			w[71]=idt1*(w[73]-nd1[1]);
			w[72]=idt1*(w[74]-nd1[2]);
		}
	}
	if(initial || (w[0]-nd1[0]>1e-10 && commit)) {
		nd2[0]=nd1[0]; nd1[0]=w[0];
		nd2[1]=nd1[1]; nd1[1]=w[73];
		nd2[2]=nd1[2]; nd1[2]=w[74];
	}
}

static void SolverUpdate(SolverStruct *S, int synced, int commit)
{
	numdiffinp(S->w,0,commit);
	if( synced ) return;
	fp(NEQ,S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
	if(IS_UNDEF(S->w[NEQ+NPAR+1])) {
		SolverError(S->w[0],0,"index-1 and derivative evaluation failure");
		return;
	}
	otp(S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
}

static int SolverProject(SolverStruct *S)
{
	int i;

	i=Projection(S->w[0],&S->w[1],CONTOL,CONITER,NULL,S->psto);
	if(i>0 && i!=3) {
		SolverError(S->w[0],0,"constraint projection failure");
		return(-1);
	}
	fp(NEQ,S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
	if(IS_UNDEF(S->w[NEQ+NPAR+1])) {
		SolverError(S->w[0],0,"index-1 and derivative evaluation failure");
		return(-1);
	}
	i=RunEvents(S->w,S->iw,0,101,EVTITER,S->psto);
	if(i) return(i);
	return(0);
}

static void SolverOutputs(SolverStruct *S)
{
	otp(S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
}

static void EulerStep(double h, SolverStruct *S)
{
	int i;

	S->w[0]+=h;
	for(i=1;i<=NDIFF;i++) S->w[i]+=h*S->w[NEQ+NPAR+i];
}

static void SolverSetup(SolverStruct *S)
{
	int i;

	S->w[0] =  0.00000000000000000e+00;
	S->w[1] =  0.00000000000000000e+00;
	S->w[2] =  0.00000000000000000e+00;
	S->w[3] =  0.00000000000000000e+00;
	S->w[4] =  0.00000000000000000e+00;
	S->w[5] =  0.00000000000000000e+00;
	S->w[6] =  0.00000000000000000e+00;
	S->w[7] =  0.00000000000000000e+00;
	S->w[8] =  0.00000000000000000e+00;
	S->w[9] = -5.00000000000000030e-02;
	S->w[10] =  0.00000000000000000e+00;
	S->w[11] =  0.00000000000000000e+00;
	S->w[12] = -5.00000000000000030e-02;
	S->w[13] =  0.00000000000000000e+00;
	S->w[14] =  1.00000000000000000e+00;
	S->w[15] =  1.00000000000000000e+00;
	S->w[16] =  0.00000000000000000e+00;
	S->w[17] = -2.98245614035087730e-03;
	S->w[18] =  0.00000000000000000e+00;
	S->w[19] =  1.00000000000000000e+00;
	S->w[20] =  1.00000000000000000e+00;
	S->w[21] =  0.00000000000000000e+00;
	S->w[22] = -2.98245614035087730e-03;
	S->w[23] = -1.00000000000000000e-02;
	S->w[24] = -1.00000000000000000e-02;
	S->w[25] = -2.98245614035087730e-03;
	S->w[26] = -2.98245614035087730e-03;
	S->w[27] = -0.00000000000000000e+00;
	S->w[28] =  0.00000000000000000e+00;
	S->w[29] =  0.00000000000000000e+00;
	S->w[30] =  0.00000000000000000e+00;
	S->w[31] =  0.00000000000000000e+00;
	S->w[32] =  0.00000000000000000e+00;
	S->w[33] =  1.00000000000000000e+00;
	S->w[34] =  1.00000000000000000e+00;
	S->w[35] =  0.00000000000000000e+00;
	S->w[36] =  0.00000000000000000e+00;
	S->w[37] =  0.00000000000000000e+00;
	S->w[38] =  0.00000000000000000e+00;
	S->w[39] = -0.00000000000000000e+00;
	S->w[40] =  0.00000000000000000e+00;
	S->w[41] =  0.00000000000000000e+00;
	S->w[42] =  0.00000000000000000e+00;
	S->w[43] =  0.00000000000000000e+00;
	S->w[44] =  0.00000000000000000e+00;
	S->w[45] =  0.00000000000000000e+00;
	S->w[46] =  0.00000000000000000e+00;
	S->w[47] =  1.00000000000000000e+00;
	S->w[48] =  1.00000000000000000e+00;
	S->w[49] =  0.00000000000000000e+00;
	S->w[50] =  0.00000000000000000e+00;
	S->w[51] =  0.00000000000000000e+00;
	S->w[52] =  0.00000000000000000e+00;
	S->w[53] = -0.00000000000000000e+00;
	S->w[54] =  0.00000000000000000e+00;
	S->w[55] =  0.00000000000000000e+00;
	S->w[56] =  0.00000000000000000e+00;
	S->w[57] =  0.00000000000000000e+00;
	S->w[58] =  0.00000000000000000e+00;
	S->w[59] =  0.00000000000000000e+00;
	S->w[60] =  0.00000000000000000e+00;
	S->w[61] = -0.00000000000000000e+00;
	S->w[62] = -0.00000000000000000e+00;
	S->w[63] = -0.00000000000000000e+00;
	S->w[64] = -0.00000000000000000e+00;
	S->w[65] =  0.00000000000000000e+00;
	S->w[66] =  0.00000000000000000e+00;
	S->w[67] =  0.00000000000000000e+00;
	S->w[68] =  0.00000000000000000e+00;
	S->w[69] =  1.41827319580999620e-01;
	S->w[70] = -1.41529004757355140e-01;
	S->w[71] =  0.00000000000000000e+00;
	S->w[72] =  0.00000000000000000e+00;
	S->w[73] =  0.00000000000000000e+00;
	S->w[74] =  0.00000000000000000e+00;
	S->w[75] =  1.00000000000000000e+00;
	S->w[76] =  3.00000000000000000e+00;
	S->w[77] =  1.00000000000000000e+00;
	S->w[78] =  3.00000000000000000e+00;
	S->w[79] =  1.00000000000000000e+00;
	S->w[80] =  3.00000000000000000e+00;
	S->w[81] =  1.00000000000000000e+00;
	S->w[82] =  3.00000000000000000e+00;
	S->w[83] =  1.00000000000000000e+00;
	S->w[84] =  0.00000000000000000e+00;
	S->w[85] =  2.00000000000000000e+00;
	S->w[86] =  1.00000000000000000e+00;
	S->w[87] =  0.00000000000000000e+00;
	S->w[88] =  2.00000000000000000e+00;
	S->w[89] =  0.00000000000000000e+00;
	S->w[90] =  0.00000000000000000e+00;
	S->w[91] =  0.00000000000000000e+00;
	S->w[92] =  0.00000000000000000e+00;
	S->w[93] =  0.00000000000000000e+00;
	S->w[94] =  0.00000000000000000e+00;
	S->w[95] =  0.00000000000000000e+00;
	S->w[96] =  0.00000000000000000e+00;
	S->w[97] =  0.00000000000000000e+00;
	S->w[98] =  0.00000000000000000e+00;
	S->w[99] =  0.00000000000000000e+00;
	S->w[100] =  0.00000000000000000e+00;
	S->w[101] =  1.00000000000000000e+00;
	S->w[102] =  0.00000000000000000e+00;
	S->w[103] =  0.00000000000000000e+00;
	S->w[104] =  0.00000000000000000e+00;
	S->w[105] =  1.00000000000000000e+00;
	S->w[106] =  1.00000000000000000e+00;
	S->w[107] =  1.00000000000000000e+00;
	S->w[108] =  1.00000000000000000e+00;
	S->w[109] =  0.00000000000000000e+00;
	S->w[110] =  0.00000000000000000e+00;
	S->w[111] =  0.00000000000000000e+00;
	S->w[112] =  0.00000000000000000e+00;
	S->w[113] =  0.00000000000000000e+00;
	S->w[114] =  0.00000000000000000e+00;
	S->w[115] =  0.00000000000000000e+00;
	S->w[116] =  0.00000000000000000e+00;
	S->w[117] =  0.00000000000000000e+00;
	S->w[118] =  0.00000000000000000e+00;
	S->w[119] =  0.00000000000000000e+00;
	S->w[120] =  0.00000000000000000e+00;
	S->w[121] =  0.00000000000000000e+00;
	S->w[122] =  0.00000000000000000e+00;
	S->w[123] =  0.00000000000000000e+00;
	S->w[124] =  0.00000000000000000e+00;
	S->w[125] =  0.00000000000000000e+00;
	S->w[126] =  0.00000000000000000e+00;
	S->w[127] =  0.00000000000000000e+00;
	S->w[128] =  0.00000000000000000e+00;
	S->w[129] =  0.00000000000000000e+00;
	S->w[130] =  1.00000000000000000e+00;
	S->w[131] =  0.00000000000000000e+00;
	S->w[132] =  0.00000000000000000e+00;
	S->w[133] =  0.00000000000000000e+00;
	S->w[134] =  1.00000000000000000e+00;
	for(i=0;i<NDIFF;i++) S->w[i+NEQ+NPAR+1]=0.0;
	S->iw[2*NEVT+0] = 0; S->iw[3*NEVT+0] = 103; S->iw[4*NEVT+0] = 0;
	S->iw[2*NEVT+1] = 0; S->iw[3*NEVT+1] = 104; S->iw[4*NEVT+1] = 0;
	S->iw[2*NEVT+2] = 0; S->iw[3*NEVT+2] = 105; S->iw[4*NEVT+2] = 0;
	S->iw[2*NEVT+3] = 0; S->iw[3*NEVT+3] = 106; S->iw[4*NEVT+3] = 0;
	S->iw[2*NEVT+4] = 0; S->iw[3*NEVT+4] = 107; S->iw[4*NEVT+4] = 0;
	S->iw[2*NEVT+5] = 0; S->iw[3*NEVT+5] = 108; S->iw[4*NEVT+5] = 0;
	S->iw[2*NEVT+6] = 0; S->iw[3*NEVT+6] = 109; S->iw[4*NEVT+6] = 0;
	S->iw[2*NEVT+7] = 0; S->iw[3*NEVT+7] = 110; S->iw[4*NEVT+7] = 0;
	S->iw[2*NEVT+8] = 0; S->iw[3*NEVT+8] = 111; S->iw[4*NEVT+8] = 0;
	S->iw[2*NEVT+9] = 0; S->iw[3*NEVT+9] = 112; S->iw[4*NEVT+9] = 0;
	S->iw[2*NEVT+10] = 0; S->iw[3*NEVT+10] = 113; S->iw[4*NEVT+10] = 0;
	S->iw[2*NEVT+11] = 0; S->iw[3*NEVT+11] = 114; S->iw[4*NEVT+11] = 0;
	S->iw[2*NEVT+12] = 0; S->iw[3*NEVT+12] = 115; S->iw[4*NEVT+12] = 0;
	S->iw[2*NEVT+13] = 0; S->iw[3*NEVT+13] = 116; S->iw[4*NEVT+13] = 0;
	S->iw[2*NEVT+14] = 0; S->iw[3*NEVT+14] = 117; S->iw[4*NEVT+14] = 0;
	S->iw[2*NEVT+15] = 0; S->iw[3*NEVT+15] = 118; S->iw[4*NEVT+15] = 0;
	S->iw[2*NEVT+16] = 0; S->iw[3*NEVT+16] = 119; S->iw[4*NEVT+16] = 0;
	S->iw[2*NEVT+17] = 0; S->iw[3*NEVT+17] = 120; S->iw[4*NEVT+17] = 0;
	S->iw[2*NEVT+18] = 0; S->iw[3*NEVT+18] = 121; S->iw[4*NEVT+18] = 0;
	S->iw[2*NEVT+19] = 0; S->iw[3*NEVT+19] = 122; S->iw[4*NEVT+19] = 0;
	S->iw[2*NEVT+20] = 0; S->iw[3*NEVT+20] = 123; S->iw[4*NEVT+20] = 0;
	S->iw[2*NEVT+21] = 0; S->iw[3*NEVT+21] = 124; S->iw[4*NEVT+21] = 0;
	S->iw[2*NEVT+22] = 0; S->iw[3*NEVT+22] = 125; S->iw[4*NEVT+22] = 0;
	S->iw[2*NEVT+23] = 0; S->iw[3*NEVT+23] = 126; S->iw[4*NEVT+23] = 0;
	S->iw[2*NEVT+24] = 0; S->iw[3*NEVT+24] = 127; S->iw[4*NEVT+24] = 0;
	S->iw[2*NEVT+25] = 0; S->iw[3*NEVT+25] = 128; S->iw[4*NEVT+25] = 0;
	S->iw[2*NEVT+26] = 0; S->iw[3*NEVT+26] = 129; S->iw[4*NEVT+26] = 0;
	S->iw[2*NEVT+27] = 0; S->iw[3*NEVT+27] = 130; S->iw[4*NEVT+27] = 0;
	S->iw[2*NEVT+28] = 0; S->iw[3*NEVT+28] = 131; S->iw[4*NEVT+28] = 0;
	S->iw[2*NEVT+29] = 0; S->iw[3*NEVT+29] = 132; S->iw[4*NEVT+29] = 0;
	S->iw[2*NEVT+30] = 0; S->iw[3*NEVT+30] = 133; S->iw[4*NEVT+30] = 0;
	S->iw[2*NEVT+31] = 0; S->iw[3*NEVT+31] = 134; S->iw[4*NEVT+31] = 0;
	eev(S->w[0],&S->w[1],&S->w[1],&S->w[2*NEQ+NPAR+NDFA+1]);
	InitEventModes(&S->w[2*NEQ+NPAR+NDFA+1],&S->w[1],S->iw,&S->iw[3*NEVT],&S->iw[2*NEVT]);
}

static void SolverInitialize(SolverStruct *S)
{
	int i, j;

	UNUSED(i);
	numdiffinp(S->w,1,1);
	numdiffinp(S->w,1,1);

	eev(S->w[0],&S->w[1],&S->w[1],&S->w[2*NEQ+NPAR+NDFA+1]);
	i=RunEvents(S->w,S->iw,2,101,EVTITER,S->psto);
	if (i<0) {
		SolverError(S->w[0],0,"error running events");
		return;
	}
	else if (i>0) {
		SolverError(S->w[0],1,"error running events");
		return;
	}
	i=cpr(S->w[0],&S->w[1]);
	S->w[NEQ+NPAR+1]=0.0;
	fp(NEQ,S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
	if(IS_UNDEF(S->w[NEQ+NPAR+1])) {
		SolverError(S->w[0],0,"index-1 and derivative evaluation failure");
		return;
	}
#if INITCONITER>0
	for(j=0;j<20;j++) {
#endif
#if INITCONITER>0
 	i=ProjectInitial(S->w[0],&S->w[1],INITCONTOL,INITCONITER,icmask,INITTOL,INITITER,INITWEIGHT,S->psto);
 	if(i>0 && i!=3) {
 		SolverError(S->w[0],0,"constraint projection failure");
 		return;
 	}
 	fp(NEQ,S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
 	if(IS_UNDEF(S->w[NEQ+NPAR+1])) {
 		SolverError(S->w[0],0,"index-1 and derivative evaluation failure");
 		return;
 	}
#endif
 	i=cpr(S->w[0],&S->w[1]);
 	if(i>0) {
 		fp(NEQ,S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
 		if(IS_UNDEF(S->w[NEQ+NPAR+1])) {
 			SolverError(S->w[0],0,"index-1 and derivative evaluation failure");
 			return;
 		}
 	}
#if INITCONITER>0
		if(i<1) break;
	}
#endif
	i=RunEvents(S->w,S->iw,0,101,EVTITER,S->psto);
	if (i<0) {
		SolverError(S->w[0],0,"error running events");
		return;
	}
	else if (i>0) {
		SolverError(S->w[0],1,"error running events");
		return;
	}
	SolverOutputs(S);
}

/*****************************************************************************/
/* FILE fmuTemplate.c */
/*****************************************************************************/


#define FMI2_COSIMULATION
#define MODEL_GUID "{d25602c7-833a-5e8d-e356-ec0e85f22cec}"
#ifndef DISABLE_PREFIX
    #define FMI2_FUNCTION_PREFIX MSpltr_
#endif



/* define model size */
#define NUMBER_OF_REALS 318
#define NUMBER_OF_INTEGERS 5*NEVT
#define NUMBER_OF_BOOLEANS 0
#define NUMBER_OF_STRINGS 1

/* include FMU header files, typedefs and macros */
#include "fmuTemplate.h"

/* define initial state vector and derivative vector as vectors of value references */
#define STATES {1, 2, 3, 4, 5, 6, 7, 8}
#define DERS   {135, 136, 137, 138, 139, 140, 141, 142}
#define OUTS   {67, 68, 2, 4, 69, 70}

#ifdef FMI2_PROVIDES_DERIVATIVES
#define NIKNO 0
#define NIUNK 0
#define IKNOS { }
#define IUNKS { }
#endif

/*****************************************************************************/

#if NDIFF>0
fmi2ValueReference vrStates[NDIFF] = STATES;
fmi2ValueReference   vrDers[NDIFF] = DERS;
#else
fmi2ValueReference *vrStates = NULL;
fmi2ValueReference   *vrDers = NULL;
#endif

#if NOUT>0
fmi2ValueReference   vrOuts[NOUT] = OUTS;
#else
fmi2ValueReference   *vrOuts = NULL;
#endif

#ifdef FMI2_PROVIDES_DERIVATIVES
#if NIKNO>0
fmi2ValueReference   vrIknowns[NIKNO] = IKNOS;
#else
fmi2ValueReference   *vrIknowns = NULL;
#endif
#if NIUNK>0
fmi2ValueReference   vrIunknowns[NIUNK] = IUNKS;
#else
fmi2ValueReference   *vrIunknowns = NULL;
#endif
#endif

/*****************************************************************************
 * BEGIN: Private functions
 *****************************************************************************/
/*****************************************************************************/
static fmi2Boolean invalidNumber(ModelInstance*	comp,
								 const char*	f,
								 const char*	arg,
								 int			n,
								 int			nExpected) {
	if (n != nExpected) {
		comp->state = modelError;
		compLog(compEnv, comp->instanceName, fmi2Error,
			"error", "[%s]: Invalid argument %s = %d. Expected %d.",
			f, arg, n, nExpected);
		return fmi2True;
	}
	return fmi2False;
}
/*****************************************************************************/
static fmi2Boolean invalidState(ModelInstance*	comp,
								const char*		f,
								int				statesExpected) {
	if (!comp) return fmi2True;
	if (!(comp->state && statesExpected)) {
		comp->state = modelError;
		compLog(compEnv, comp->instanceName, fmi2Error,
			"error", "[%s]: Illegal call sequence.", f);
		return fmi2True;
	}
	return fmi2False;
}
/*****************************************************************************/
static fmi2Boolean nullPointer(	ModelInstance*	comp,
								const char*		f,
								const char*		arg,
								const void*		p) {
	if (!p) {
		comp->state = modelError;
		compLog(compEnv, comp->instanceName, fmi2Error,
			"error", "[%s]: Invalid argument %s = NULL.", f, arg);
		return fmi2True;
	}
	return fmi2False;
}
/*****************************************************************************/
static fmi2Boolean vrOutOfRange(ModelInstance*		comp,
								const char*			f,
								fmi2ValueReference	vr,
								int					end) {
	if ((int)vr >= end) {
		comp->state = modelError;
		compLog(compEnv, comp->instanceName, fmi2Error,
			"error", "[%s]: Illegal value reference %u.", f, vr);
		return fmi2True;
	}
	return fmi2False;
}
/*****************************************************************************/
void logMessage(ModelInstance*	comp,
				const char*		f,
				const char*		e,
				fmi2Status		value) {
	compLog(compEnv, comp->instanceName, value,
			e, "[%s]: %s", f, errorString);
}
/*****************************************************************************/
void logWarning(ModelInstance*	comp,
				const char*		f,
				const char*		e,
				fmi2Status		value) {
	compLog(compEnv, comp->instanceName, value,
			e, "[%s]: %s", f, warningString);
}
/*****************************************************************************/
static void setVidError(ModelInstance *comp, char *errstr)
{
	if (errstr)
		strcpy(comp->viderror,errstr);
	else if (errorOccured)
		strcpy(comp->viderror,errorString);
	else
		strcpy(comp->viderror,"unknown error");
	comp->vidsts = -1;
}
/*****************************************************************************/
fmi2Status syncModel(ModelInstance *c, const char *f)
{
	ModelInstance* comp = (ModelInstance *)c;
	int i;

	if (comp->state==modelInitialized && !comp->synced) {
		if(comp->initializeMode) {
			if(comp->S.wset) {
				SolverSetup(&(comp->S));
				for(i=0;i<NUMBER_OF_REALS;i++)
					if(!IS_UNDEF(comp->S.wset[i]))
						comp->S.w[i]=comp->S.wset[i];
			}
			SolverInitialize(&(comp->S));
			if (errorOccured>0) {
				setVidError(comp,NULL);
				if (comp->fptr) {
					writeErrorToFile(comp->fptr, NULL);
					comp->fptr = NULL;
				}
				comp->state = modelTerminated;
				logMessage(comp, f, "error", fmi2Error);
				return fmi2Error;
			}
			else if(errorOccured<0) {
				logMessage(comp, f, "warning", fmi2Warning);
				errorOccured=0;
			}
		}
		else {
			if(comp->fmuType==fmi2ModelExchange && comp->S.wset)
				for(i=NDIFF+1;i<=NDIFF+NIX1-NINP;i++)
					comp->S.w[i]=comp->S.wset[i];
			SolverUpdate(&(comp->S),0,0);
			if(errorOccured>0) {
				setVidError(comp,NULL);
				if (comp->fptr) {
					writeErrorToFile(comp->fptr,NULL);
					comp->fptr = NULL;
				}
				errorOccured=0;
				logMessage(comp, f, "error", fmi2Error);
				return fmi2Discard;
			}
			else if(errorOccured<0) {
				logMessage(comp, f, "warning", fmi2Warning);
				errorOccured=0;
			}
		}
		if(inputchange) inputchange=0;
		comp->synced = fmi2True;
		comp->jsynced = fmi2False;
	}
	return fmi2OK;
}

/*****************************************************************************
 * END: Private functions
 *****************************************************************************/
/*****************************************************************************
 * Common functions: for FMI Model Exchange 2.0 and for FMI Co-Simulation 2.0
 *****************************************************************************/
/*****************************************************************************/
/* BEGIN: fmi2GetTypesPlatform */
const char* fmi2GetTypesPlatform() {
	return fmi2TypesPlatform;
}
/* END: fmi2GetTypesPlatform */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetVersion */
const char* fmi2GetVersion() {
	return fmi2Version;
}
/* END: fmi2GetVersion */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetDebugLogging */
fmi2Status fmi2SetDebugLogging(	fmi2Component	c,
								fmi2Boolean		loggingOn,
								size_t			nCategories,
								const fmi2String categories[]) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2SetDebugLogging", not_modelError))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK,
			"log", "fmi2SetDebugLogging: loggingOn = %d", loggingOn);
	if(nCategories>0 && categories!=NULL)
		/* No support for separate logging categories at this time */
		comp->loggingOn = fmi2True;
	else
		comp->loggingOn = loggingOn;
	return fmi2OK;
}
/* END: fmi2SetDebugLogging */
/*****************************************************************************/

static char nameME[] = "ModelExchange";
static char nameCS[] = "CoSimulation";
static char binfile[] = "DISABLED";

/*****************************************************************************/
/* BEGIN: fmi2Instantiate */
fmi2Component fmi2Instantiate(	fmi2String					instanceName,
								fmi2Type					fmuType,
								fmi2String					GUID,
								fmi2String					fmuLocation,
								const fmi2CallbackFunctions* functions,
								fmi2Boolean					visible,
								fmi2Boolean					loggingOn) {
	ModelInstance* comp;
	char * fname;
	fmi2String iname;
	int i;

	UNUSED(fmuLocation);
	UNUSED(visible);
	if (fmuType==fmi2ModelExchange)
		fname = nameME;
	else
		fname = nameCS;

	if (!functions->logger)
		return NULL;
	if (!functions->allocateMemory || !functions->freeMemory) {
		functions->logger(NULL, instanceName, fmi2Error,
				"error", "[%s]: Callback function is not found.", fname);
		return NULL;
	}
	if (!instanceName || strlen(instanceName)==0) {
		functions->logger(NULL, instanceName, fmi2Error,
				"error", "[%s]: Instance name is not found.", fname);
		return NULL;
	}
	if (strcmp(GUID, MODEL_GUID)) {
		functions->logger(NULL, instanceName, fmi2Error,
				"error", "[%s]: Inconsistent GUID %s. Expected %s.",
				fname, GUID, MODEL_GUID);
		return NULL;
	}

	comp = (ModelInstance *)functions->allocateMemory(1,sizeof(ModelInstance));

	iname = functions->allocateMemory(strlen((char*)instanceName) + 1,sizeof(char));
	if (!iname)
		functions->logger(NULL, instanceName, fmi2Error,
				"error", "[%s]: Cannot allocate memory.", fname);
	strcpy((char*)iname, (char*)instanceName);

	if (comp) {
		comp->S.w = functions->allocateMemory(NUMBER_OF_REALS,sizeof(fmi2Real));
		if (fmuType==fmi2ModelExchange)
			comp->S.wset = functions->allocateMemory(NUMBER_OF_REALS,sizeof(fmi2Real));
		else
			comp->S.wset = NULL;
		if(NCON>0)
			comp->S.psto = functions->allocateMemory(NDIFF*(1+NCON+2*NDIFF),sizeof(fmi2Real));
		else
			comp->S.psto = NULL;
		if(SSTO>0)
			comp->S.ssto = functions->allocateMemory(NDFA*(NDFA+1),sizeof(fmi2Real));
		else
			comp->S.ssto = NULL;
#ifdef FMI2_PROVIDES_DERIVATIVES
		if( (1+NDIFF+NINP)*(NDIFF+NOUT)>0 ) {
			comp->Jacobian = functions->allocateMemory((1+NDIFF+NINP)*(NDIFF+NOUT),sizeof(fmi2Real));
			if (!comp->Jacobian) {
				functions->logger(NULL, instanceName, fmi2Error,
						"error", "[%s]: Cannot allocate memory.", fname);
				return NULL;
			}
		}
		else
			comp->Jacobian = NULL;

		if( NIUNK*NIKNO>0 ) {
			comp->initJacobian = functions->allocateMemory(NIUNK*NIKNO,sizeof(fmi2Real));
			if (!comp->initJacobian) {
				functions->logger(NULL, instanceName, fmi2Error,
						"error", "[%s]: Cannot allocate memory.", fname);
				return NULL;
			}
		}
		else
			comp->initJacobian = NULL;

		if( NIUNK>0 ) {
			comp->initRes = functions->allocateMemory(NIUNK,sizeof(fmi2Real));
			if (!comp->initRes) {
				functions->logger(NULL, instanceName, fmi2Error,
						"error", "[%s]: Cannot allocate memory.", fname);
				return NULL;
			}
		}
		else
			comp->initRes = NULL;

#else
		comp->Jacobian = NULL;
		comp->initJacobian = NULL;
		comp->initRes = NULL;
#endif
		if (NUMBER_OF_INTEGERS > 0)
			comp->S.iw = functions->allocateMemory(NUMBER_OF_INTEGERS,sizeof(M_INT));
		else
			comp->S.iw = NULL;
		if (NUMBER_OF_BOOLEANS > 0)
			comp->b = functions->allocateMemory(NUMBER_OF_BOOLEANS,sizeof(fmi2Boolean));
		else
			comp->b = NULL;
		if (NUMBER_OF_STRINGS > 0) {
			comp->s = functions->allocateMemory(NUMBER_OF_STRINGS,sizeof(fmi2String));
			for (i=0; i<NUMBER_OF_STRINGS; i++)
				comp->s[i] = NULL;
		}
		else
			comp->s = NULL;
	}

	if (!comp || !comp->S.w ||	(NUMBER_OF_INTEGERS>0 && !comp->S.iw ) ||
								(NUMBER_OF_BOOLEANS>0 && !comp->b) ||
								(NUMBER_OF_STRINGS>0  && !comp->s)) {
		functions->logger(NULL, instanceName, fmi2Error,
				"error", "[%s]: Cannot allocate memory.", fname);
		return NULL;
	}

	comp->instanceName	= iname;
	comp->GUID			= MODEL_GUID;
	comp->fmuType		= fmuType;
	memcpy(&comp->functions,functions,sizeof(fmi2CallbackFunctions));
	comp->loggingOn		= loggingOn;

	if(comp->S.wset) {
		for(i=0;i<NUMBER_OF_REALS;i++)
			comp->S.wset[i]=1.0/dsn_zero;
		comp->synced			= fmi2False;
		comp->jsynced			= fmi2False;
	}
	else {
		SolverSetup(&(comp->S));
		comp->synced			= fmi2True;
		comp->jsynced			= fmi2True;
	}

	comp->initializeMode	= fmi2False;
	comp->state				= modelInstantiated;
	comp->vidsts			= 0;
	comp->minSampleStep	= minsamplestep;
	comp->fptr				= NULL;
	if (strcmp(binfile,"DISABLED") == 0)
		comp->fstr = NULL;
	else {
		comp->fstr = binfile;
		comp->s[0] = comp->functions.allocateMemory(1+strlen(binfile),sizeof(char));
		strcpy((char*)comp->s[0],(char*)binfile);
	}

	if (comp->loggingOn)
		compLog(compEnv, instanceName, fmi2OK,
			"log", "[%s]: GUID = %s", fname, GUID);

	return comp;
}
/* END: fmi2Instantiate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2FreeInstance */
/*****************************************************************************/
void fmi2FreeInstance(fmi2Component c) {
	int i;
	ModelInstance* comp = (ModelInstance *)c;

	if (!comp) return;

	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK,
			"log", "fmi2FreeInstance");

	if (comp->instanceName)	comp->functions.freeMemory((char*)comp->instanceName);
	if (comp->S.w)			comp->functions.freeMemory(comp->S.w);
	if (comp->S.iw)			comp->functions.freeMemory(comp->S.iw);
	if (comp->S.wset)			comp->functions.freeMemory(comp->S.wset);
	if (comp->S.psto)			comp->functions.freeMemory(comp->S.psto);
	if (comp->S.ssto)			comp->functions.freeMemory(comp->S.ssto);
	if (comp->b)			comp->functions.freeMemory(comp->b);
	if (comp->Jacobian)		comp->functions.freeMemory(comp->Jacobian);
	if (comp->initRes)		comp->functions.freeMemory(comp->initRes);
	if (comp->initJacobian)		comp->functions.freeMemory(comp->initJacobian);
	if (comp->s) {
		for (i=0; i<NUMBER_OF_STRINGS; i++)
			if (comp->s[i]) comp->functions.freeMemory((char*)comp->s[i]);
		comp->functions.freeMemory((char*)comp->s);
	}

	comp->functions.freeMemory(comp);
}
/* END: fmi2FreeInstance */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetupExperiment */
/*****************************************************************************/
fmi2Status fmi2SetupExperiment(	fmi2Component	c,
								fmi2Boolean		toleranceDefined,
								fmi2Real		tolerance,
								fmi2Real		startTime,
								fmi2Boolean		stopTimeDefined,
								fmi2Real		stopTime) {
	ModelInstance* comp = (ModelInstance *)c;

	UNUSED(toleranceDefined);
	UNUSED(tolerance);
	comp->S.w[0]	= startTime;
	comp->startTime	= startTime;

	if (stopTimeDefined)
		comp->stopTime = stopTime;
	else
		comp->stopTime = 0.0;

	comp->stopTimeDefined = stopTimeDefined;

	if (comp->fptr) {
		fclose(comp->fptr);
		comp->fptr = NULL;
	}
	if (comp->fstr && strcmp(comp->fstr,"DISABLED")!=0
						&& strcmp(comp->fstr,"'DISABLED'")!=0 )
		comp->fptr = fopen(comp->fstr,"wb");

	comp->lastsampletime = -1e10;
	comp->lastStepSize = -1.0;
	comp->lastSuccessfulTime = startTime;
	comp->numpts = 0;
	comp->vidsts = 0;
	comp->vidlasttime = -1e10;

	return fmi2OK;
}
/* END: fmi2SetupExperiment */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2EnterInitializationMode */
fmi2Status fmi2EnterInitializationMode(fmi2Component c) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2EnterInitializationMode", modelInstantiated))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK,
			"log", "fmi2EnterInitializationMode");

	/* Do not sync here - delay the sync until the first FMU query */
	comp->synced			= fmi2False;
	comp->jsynced			= fmi2False;

	comp->initializeMode	= fmi2True;
	comp->state				= modelInitialized;
	comp->vidsts			= 1;
	if (comp->fptr) {
		fwrite(nData,sizeof(fmi2Real),2,comp->fptr);
		if(NPAR>0) {
			syncModel(c,"fmi2EnterInitializationMode");
			fwrite(&comp->S.w[NEQ+1],sizeof(fmi2Real),NPAR,comp->fptr);
		}
	}

	return fmi2OK;
}
/* END: fmi2EnterInitializationMode */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2ExitInitializationMode */
fmi2Status fmi2ExitInitializationMode(fmi2Component c) {
	ModelInstance* comp = (ModelInstance *)c;
	fmi2Status sts;
	int i;

	if (comp) {
		sts = syncModel(c,"fmi2ExitInitializationMode");
		if ( sts!=fmi2OK ) return(sts);
		comp->initializeMode = fmi2False;
		if(comp->fmuType==fmi2ModelExchange && comp->S.wset)
			for(i=NDIFF+1;i<=NDIFF+NIX1-NINP;i++)
				comp->S.wset[i]=comp->S.w[i];
		comp->jsynced =fmi2False;
		comp->vidsts = 2;
		if (comp->fptr)
			fwrite(comp->S.w,sizeof(fmi2Real),NEQ+1,comp->fptr);
		return fmi2OK;
	}
	else
		return fmi2Error;
}
/* END: fmi2ExitInitializationMode */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2Terminate */
fmi2Status fmi2Terminate(fmi2Component c) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2Terminate", modelInitialized)) return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK,
			"log", "fmi2Terminate");
	if (comp->fptr) {
		fclose(comp->fptr);
		comp->fptr = NULL;
	}

	comp->state = modelTerminated;

	return fmi2OK;
}
/* END: fmi2Terminate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2Reset */
fmi2Status fmi2Reset(fmi2Component c) {
	ModelInstance* comp = (ModelInstance *)c;
	int i;

	if (invalidState(comp, "fmi2Reset", modelInitialized)) return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK,
			"log", "fmi2Reset");

	comp->state = modelInstantiated;
	comp->synced = fmi2False;
	comp->jsynced = fmi2False;

	if(comp->S.wset)
		for(i=0;i<NUMBER_OF_REALS;i++)
			comp->S.wset[i]=1.0/dsn_zero;
	else
		SolverSetup(&(comp->S));

	return fmi2OK;
}
/* END: fmi2Reset */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetReal */
fmi2Status fmi2GetReal(	fmi2Component			c,
						const fmi2ValueReference vr[],
						size_t					nvr,
						fmi2Real				value[]) {
	int i;
	fmi2Status sts;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetReal", validGet))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetReal", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetReal", "value[]", value))
		return fmi2Error;

#if NUMBER_OF_REALS+1>0
	/*for (i=0; i<(int)nvr; i++)
		if (vrOutOfRange(comp, "fmi2GetReal", vr[i], NUMBER_OF_REALS))
		return fmi2Error;*/

	if(comp->state != modelTerminated) {
		sts = syncModel(comp,"fmi2GetReal");
		if ( sts!=fmi2OK ) return sts;
	}

	for (i=0; i<(int)nvr; i++) {
		if( nomfac && vr[i]>=vrStates[0] && vr[i]<vrStates[0]+NDIFF )
			value[i] = comp->S.w[vr[i]]/nomfac[vr[i]-vrStates[0]];
		else if( nomfac && vr[i]>=vrDers[0] && vr[i]<vrDers[0]+NDIFF )
			value[i] = comp->S.w[vr[i]]/nomfac[vr[i]-vrDers[0]];
		else if (vr[i] == 318)
			value[i] = comp->minSampleStep;
		else
			value[i] = comp->S.w[vr[i]];
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK,
				"log", "fmi2GetReal: #r%u# = %.16g", vr[i], value[i]);
	}
#endif
	return fmi2OK;
}
/* END: fmi2GetReal */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetInteger */
fmi2Status fmi2GetInteger(	fmi2Component			c,
							const fmi2ValueReference vr[],
							size_t					nvr,
							fmi2Integer				value[]) {
	int i;
	fmi2Status sts;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetInteger", validGet))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetInteger", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetInteger", "value[]", value))
		return fmi2Error;

	if(comp->state != modelTerminated) {
		sts = syncModel(comp,"fmi2GetInteger");
		if ( sts!=fmi2OK ) return sts;
	}

	for (i=0; i<(int)nvr; i++) {
		if (vrOutOfRange(comp, "fmi2GetInteger", vr[i], NUMBER_OF_INTEGERS))
			return fmi2Error;
		value[i] = (fmi2Integer)comp->S.iw[vr[i]];
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK,
				"log", "fmi2GetInteger: #i%u# = %d", vr[i], value[i]);
	}
	return fmi2OK;
}
/* END: fmi2GetInteger */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetBoolean */
fmi2Status fmi2GetBoolean(	fmi2Component			c,
							const fmi2ValueReference vr[],
							size_t					nvr,
							fmi2Boolean				value[]) {
	int i;
	fmi2Status sts;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetBoolean", validGet))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetBoolean", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetBoolean", "value[]", value))
		return fmi2Error;

	if(comp->state != modelTerminated) {
		sts = syncModel(comp,"fmi2GetBoolean");
		if ( sts!=fmi2OK ) return sts;
	}

	for (i=0; i<(int)nvr; i++) {
		if (vrOutOfRange(comp, "fmi2GetBoolean", vr[i], NUMBER_OF_BOOLEANS))
			return fmi2Error;
		value[i] = comp->b[vr[i]];
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK,
				"log", "fmi2GetBoolean: #b%u# = %s",vr[i], value[i]? "true":"false");
	}
	return fmi2OK;
}
/* END: fmi2GetBoolean */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetString */
fmi2Status fmi2GetString(fmi2Component			c,
						const fmi2ValueReference vr[],
						size_t					nvr,
						fmi2String				value[]) {
	int i;
	fmi2Status sts;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetString", validGet))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetString", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetString", "value[]", value))
		return fmi2Error;

	if(comp->state != modelTerminated) {
		sts = syncModel(comp,"fmi2GetString");
		if ( sts!=fmi2OK ) return sts;
	}

	for (i=0; i<(int)nvr; i++) {
		if (vr[i] == 319)
			value[i] = comp->s[0];
		else {
			comp->state = modelError;
			compLog(compEnv, comp->instanceName, fmi2Error,
					"error", "[%s]: Illegal value reference %u.", "fmi2GetString", vr);
			return fmi2Error;
		}
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2GetString: #s%u# = '%s'", vr[i], value[i]);
	}
	return fmi2OK;
}
/* END: fmi2GetString */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetReal */
fmi2Status fmi2SetReal(	fmi2Component			c,
						const fmi2ValueReference vr[],
						size_t					nvr,
						const fmi2Real			value[]) {
	int i;
	ModelInstance* comp = (ModelInstance *)c;
	double scalev;

	if (invalidState(comp, "fmi2SetReal", modelInstantiated|modelInitialized))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetReal", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetReal", "value[]", value))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName,
				fmi2OK, "log",
				"fmi2SetReal: nvr = %d",
				nvr);

	for (i=0; i<(int)nvr; i++) {
		if (vrOutOfRange(comp, "fmi2SetReal", vr[i], NUMBER_OF_REALS+1))
			return fmi2Error;
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName,
					fmi2OK, "log",
					"fmi2SetReal: #r%d# = %.16g", vr[i], value[i]);
		if( nomfac && vr[i]>=vrStates[0] && vr[i]<vrStates[0]+NDIFF )
			scalev = nomfac[vr[i]-vrStates[0]]*value[i];
		else if( nomfac && vr[i]>=vrDers[0] && vr[i]<vrDers[0]+NDIFF )
			scalev = nomfac[vr[i]-vrDers[0]]*value[i];
		else if (vr[i] == 318) {
			comp->minSampleStep = value[i];
			continue;
		}
		else
			scalev = value[i];
		if (comp->S.w[vr[i]]!=scalev) {
#if NINP>0
			if(vr[i]>=1+NDIFF+NIX1-NINP && vr[i]<1+NDIFF+NIX1)
				inputchange=1;
#endif
#if NPAR>0
			if(comp->state==modelInitialized && comp->initializeMode==fmi2False
				&& vr[i]>=1+NEQ && vr[i]<=1+NEQ+NPAR) {
				if(pflags[vr[i]-1-NEQ])
					pchange=1;
				else {
					compLog(NULL, comp->instanceName, fmi2Error, "error",
						"fmi2SetReal: attempt to change fixed parameter after initialization.");
					return fmi2Error;
				}
			}
#endif
			comp->S.w[vr[i]] = scalev;
			if(comp->fmuType==fmi2ModelExchange && comp->S.wset)
				comp->S.wset[vr[i]] = scalev;
			comp->synced = fmi2False;
			comp->jsynced = fmi2False;
		}
	}

	return fmi2OK;
}
/* END: fmi2SetReal */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetInteger */
fmi2Status fmi2SetInteger(fmi2Component			c,
						const fmi2ValueReference vr[],
						size_t					nvr,
						const fmi2Integer		value[]) {
	int i;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2SetInteger", modelInstantiated|modelInitialized))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetInteger", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetInteger", "value[]", value))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName,
				fmi2OK, "log", "fmi2SetInteger: nvr = %d",
				nvr);

	for (i=0; i<(int)nvr; i++) {
		if (vrOutOfRange(comp, "fmi2SetInteger", vr[i], NUMBER_OF_INTEGERS))
			return fmi2Error;
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName,
					fmi2OK, "log", "fmi2SetInteger: #i%d# = %d", vr[i], value[i]);
		if (comp->S.iw[vr[i]]!=(M_INT)value[i]) {
			comp->S.iw[vr[i]] = (M_INT)value[i];
			comp->synced = fmi2False;
			comp->jsynced = fmi2False;
		}
	}

	return fmi2OK;
}
/* END: fmi2SetInteger */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetBoolean */
fmi2Status fmi2SetBoolean(fmi2Component			c,
						const fmi2ValueReference vr[],
						size_t					nvr,
						const fmi2Boolean		value[]) {
	int i;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2SetBoolean", modelInstantiated|modelInitialized))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetBoolean", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetBoolean", "value[]", value))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName,
				fmi2OK, "log", "fmi2SetBoolean: nvr = %d", nvr);
	for (i=0; i<(int)nvr; i++) {
		if (vrOutOfRange(comp, "fmi2SetBoolean", vr[i], NUMBER_OF_BOOLEANS))
			return fmi2Error;
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName,
					fmi2OK, "log",
					"fmi2SetBoolean: #b%d# = %s",
					vr[i], value[i] ? "true" : "false");
		if (comp->b[vr[i]]!=value[i]) {
			comp->b[vr[i]] = value[i];
			comp->synced = fmi2False;
			comp->jsynced = fmi2False;
		}
	}

	return fmi2OK;
}
/* END: fmi2SetBoolean */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetString */
fmi2Status fmi2SetString(fmi2Component			c,
						const fmi2ValueReference vr[],
						size_t					nvr,
						const fmi2String		value[]) {
	int i;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2SetString", modelInstantiated|modelInitialized))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetString", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetString", "value[]", value))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName,
				fmi2OK, "log", "fmi2SetString: nvr = %d",	nvr);

	for (i=0; i<(int)nvr; i++) {
		char* string = (char*)comp->s[0];
		if (vr[i] != 319) {
			comp->state = modelError;
			compLog(compEnv, comp->instanceName, fmi2Error,
					"error", "[%s]: Illegal value reference %u.", "fmi2SetString", vr);
			return fmi2Error;
		}
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName,
					fmi2OK, "log",
					"fmi2SetString: #s%d# = '%s'",
					vr[i], value[i]);
		if (nullPointer(comp, "fmi2SetString", "value[i]", value[i]))
			return fmi2Error;
		if (string==NULL || strlen(string) < strlen(value[i])) {
			if (string) comp->functions.freeMemory(string);
			comp->s[0] = comp->functions.allocateMemory(1+strlen(value[i]),
															sizeof(char));
			if (!comp->s[0]) {
				comp->state = modelError;
				compLog(NULL, comp->instanceName,
						fmi2Error, "error", "fmi2SetString: Out of memory.");
				return fmi2Error;
			}
		}
		strcpy((char*)comp->s[0], (char*)value[i]);
		/*comp->synced = fmi2False;*/
		if (vr[i] == 319)
			comp->fstr = comp->s[0];
	}

	return fmi2OK;
}
/* END: fmi2SetString */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetFMUstate */
/*****************************************************************************/
/* Storage structure:
		State id (hard coded value)
		Data length (bytes)
		ModelInstance
		Real data storage
		Integer data storage
		Real backup data storage (only for ME)
		Jacobian storage
		Error code
		String storage
*/
#define FMUStateID 983472598

fmi2Status fmi2GetFMUstate (
	fmi2Component	c,
	fmi2FMUstate*	FMUstate
)
{
	ModelInstance* comp = (ModelInstance *)c;
	char *cur;
	fmi2Real *rcur;
	M_INT i,j,*icur,wsto,ssto,jsto,totsto;

	if (invalidState(comp, "fmi2GetFMUstate", modelInitialized))
		return fmi2Error;

	if(comp->fmuType==fmi2ModelExchange)
		wsto = NUMBER_OF_REALS*sizeof(fmi2Real);
	else
		wsto = 0;

#ifdef FMI2_PROVIDES_DERIVATIVES
	jsto=( (1+NDIFF+NINP)*(NDIFF+NOUT) + NIUNK*(NIKNO+1) )*sizeof(fmi2Real);
#else
	jsto=0;
#endif

	ssto=0;
	for(i=0;i<NUMBER_OF_STRINGS;i++)
		if(comp->s[i])
			ssto+=strlen(comp->s[i])+1;
		else
			ssto++;

	totsto = 2*sizeof(M_INT) +
				sizeof(ModelInstance) +
				NUMBER_OF_REALS*sizeof(fmi2Real) +
				NUMBER_OF_INTEGERS*sizeof(M_INT) +
				wsto +
				jsto +
				sizeof(M_INT) +
				ssto;

	/* Verify that previously allocated FMU state is of sufficient size */
	if(*FMUstate) {
		icur=(M_INT *)(*FMUstate);
		if(icur[0]!=FMUStateID) {
			/* FMUstate pointer is not previously allocated in this routine
				so no way to verify the size */
			compLog(compEnv, comp->instanceName, fmi2Warning, "warning",
				"fmi2GetFMUstate: called with non-NULL state pointer of unknown size. Assuming sufficiently large.");
		}
		else if(icur[1]<totsto) {
			comp->functions.freeMemory(*FMUstate);
			*FMUstate=NULL;
		}
	}

	if(*FMUstate==NULL)
		FMUstate[0] = (fmi2FMUstate)comp->functions.allocateMemory(1,totsto);

	cur = (char *)(*FMUstate);

	icur = (M_INT *)cur;
	icur[0] = FMUStateID;
	icur[1] = totsto;
	cur += 2*sizeof(M_INT);

	memcpy(cur,comp,sizeof(ModelInstance));
	cur += sizeof(ModelInstance);

	rcur = (fmi2Real*)cur;
	for (i=0;i<NUMBER_OF_REALS;i++)	rcur[i] = comp->S.w[i];
	cur += NUMBER_OF_REALS*sizeof(fmi2Real);

	icur = (M_INT *)cur;
	for (i=0;i<NUMBER_OF_INTEGERS;i++) icur[i] = comp->S.iw[i];
	cur += NUMBER_OF_INTEGERS*sizeof(M_INT);

	if(comp->fmuType==fmi2ModelExchange) {
		rcur = (fmi2Real*)cur;
		for (i=0;i<NUMBER_OF_REALS;i++)	rcur[i] = comp->S.wset[i];
		cur += NUMBER_OF_REALS*sizeof(fmi2Real);
	}

#ifdef FMI2_PROVIDES_DERIVATIVES
	rcur = (fmi2Real*)cur;
	for (i=0;i<(1+NDIFF+NINP)*(NDIFF+NOUT);i++)	rcur[i] = comp->Jacobian[i];
	cur += (1+NDIFF+NINP)*(NDIFF+NOUT)*sizeof(fmi2Real);

	rcur = (fmi2Real*)cur;
	for (i=0;i<NIUNK*NIKNO;i++)	rcur[i] = comp->initJacobian[i];
	cur += NIUNK*NIKNO*sizeof(fmi2Real);

	rcur = (fmi2Real*)cur;
	for (i=0;i<NIUNK;i++)	rcur[i] = comp->initRes[i];
	cur += NIUNK*sizeof(fmi2Real);
#endif

	icur = (M_INT *)cur;
	icur[0] = errorOccured;
	cur += sizeof(M_INT);

	for(i=0;i<NUMBER_OF_STRINGS;i++) {
		if(comp->s[i]) {
			for(j=0;comp->s[i][j]!='\0';j++)
				*(cur++)=comp->s[i][j];
		}
		*(cur++)='\0';
	}

	return fmi2OK;
}
/* END: fmi2GetFMUstate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetFMUstate */
/*****************************************************************************/
fmi2Status fmi2SetFMUstate (fmi2Component	c,
							fmi2FMUstate	FMUstate) {
	ModelInstance* comp = (ModelInstance *)c;
	char *cur;
	fmi2String *scur;
	fmi2Real *rcur,*wcur,*jcur1,*jcur2,*jcur3;
	M_INT i,j,l,*icur,totsto;

	if (invalidState(comp, "fmi2SetFMUstate", modelInitialized))
		return fmi2Error;

	cur = (char *)FMUstate;
	icur = (M_INT *)cur;
	if(icur[0]!=FMUStateID) {
		compLog(compEnv, comp->instanceName, fmi2Error, "error",
			"fmi2SetFMUstate: called with invalid FMUstate");
		return(fmi2Error);
	}
	totsto = icur[1];
	cur += 2*sizeof(M_INT);

	rcur = comp->S.w;
	icur = comp->S.iw;
	wcur = comp->S.wset;
	jcur1 = comp->Jacobian;
	jcur2 = comp->initJacobian;
	jcur3 = comp->initRes;
	scur = comp->s;
	memcpy(comp,cur,sizeof(ModelInstance));
	comp->S.w  = rcur;
	comp->S.iw = icur;
	comp->S.wset = wcur;
	comp->Jacobian = jcur1;
	comp->initJacobian = jcur2;
	comp->initRes = jcur3;
	comp->s = scur;
	cur += sizeof(ModelInstance);

	rcur = (fmi2Real *)cur;
	for(i=0;i<NUMBER_OF_REALS;i++) comp->S.w[i] = rcur[i];
	cur += NUMBER_OF_REALS*sizeof(fmi2Real);

	icur = (M_INT *)cur;
	for (i=0;i<NUMBER_OF_INTEGERS;i++) comp->S.iw[i] = icur[i];
	cur += NUMBER_OF_INTEGERS*sizeof(M_INT);

	if(comp->fmuType==fmi2ModelExchange) {
		rcur = (fmi2Real *)cur;
		for(i=0;i<NUMBER_OF_REALS;i++) comp->S.wset[i] = rcur[i];
		cur += NUMBER_OF_REALS*sizeof(fmi2Real);
	}
	else
		comp->S.wset = NULL;

#ifdef FMI2_PROVIDES_DERIVATIVES
	rcur = (fmi2Real*)cur;
	for (i=0;i<(1+NDIFF+NINP)*(NDIFF+NOUT);i++)	comp->Jacobian[i] = rcur[i];
	cur += (1+NDIFF+NINP)*(NDIFF+NOUT)*sizeof(fmi2Real);

	rcur = (fmi2Real*)cur;
	for (i=0;i<NIUNK*NIKNO;i++)	comp->initJacobian[i] = rcur[i];
	cur += NIUNK*NIKNO*sizeof(fmi2Real);

	rcur = (fmi2Real*)cur;
	for (i=0;i<NIUNK;i++)	comp->initRes[i] = rcur[i];
	cur += NIUNK*sizeof(fmi2Real);
#else
	comp->Jacobian = NULL;
	comp->initJacobian = NULL;
	comp->initRes = NULL;
#endif

	icur = (M_INT *)cur;
	errorOccured = icur[0];
	cur += sizeof(M_INT);

	for(i=0;i<NUMBER_OF_STRINGS;i++) {
		l=(comp->s[i]) ? strlen(comp->s[i]) : -1;
		j=strlen(cur);
		if(j>l) {
			if(comp->s[i]) comp->functions.freeMemory((char *)comp->s[i]);
			comp->s[i]=(fmi2String)comp->functions.allocateMemory(1,j+1);
		}
		strcpy((char *)comp->s[i],cur);
		cur += j+1;
	}

	return fmi2OK;
}
/* END: fmi2SetFMUstate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2FreeFMUstate */
/*****************************************************************************/
fmi2Status fmi2FreeFMUstate(fmi2Component c,
							fmi2FMUstate* FMUstate) {
	ModelInstance* comp = (ModelInstance *)c;
	M_INT *icur;

	if (invalidState(comp, "fmi2FreeFMUstate",
		modelInstantiated|modelInitialized|modelTerminated|modelError))
		return fmi2Error;

	if( *FMUstate ) {
		icur = (M_INT *)(*FMUstate);
		if(icur[0]!=FMUStateID)
			compLog(compEnv, comp->instanceName, fmi2Warning, "warning",
				"fmi2FreeFMUstate: called with invalid FMUstate");
		comp->functions.freeMemory(*FMUstate);
	}

	*FMUstate = NULL;

	return fmi2OK;
}
/* END: fmi2FreeFMUstate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SerializedFMUstateSize */
/*****************************************************************************/
fmi2Status fmi2SerializedFMUstateSize(	fmi2Component	c,
										fmi2FMUstate	FMUstate,
										size_t			*size) {
	ModelInstance* comp = (ModelInstance *)c;
	M_INT *icur;

	if (invalidState(comp, "fmi2SerializedFMUstateSize", modelInitialized))
		return fmi2Error;

	icur = (M_INT *)FMUstate;
	if(icur[0]!=FMUStateID) {
		compLog(compEnv, comp->instanceName, fmi2Error, "error",
			"fmi2SerializedFMUstateSize: called with invalid FMUstate");
		return(fmi2Error);
	}
	*size = (size_t)icur[1];

	return fmi2OK;
}
/* END: fmi2SerializedFMUstateSize */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SerializeFMUstate */
/*****************************************************************************/
fmi2Status fmi2SerializeFMUstate(fmi2Component		c,
								fmi2FMUstate		FMUstate,
								fmi2Byte 			serializedState[],
								size_t				size) {
	ModelInstance* comp = (ModelInstance *)c;
	M_INT *icur;

	if (invalidState(comp, "fmi2SerializeFMUstate", modelInitialized))
		return fmi2Error;

	icur = (M_INT *)FMUstate;
	if(icur[0]!=FMUStateID) {
		compLog(compEnv, comp->instanceName, fmi2Error, "error",
			"fmi2SerializedFMUstate: called with invalid FMUstate");
		return fmi2Error;
	}
	if(icur[1]>(M_INT)size) {
		compLog(compEnv, comp->instanceName, fmi2Error, "error",
			"fmi2SerializedFMUstate: called with size not sufficient to contain FMUstate");
		return fmi2Error;
	}
	memcpy(serializedState, FMUstate, size);

	return fmi2OK;
}
/* END: fmi2SerializeFMUstate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2DeSerializeFMUstate */
/*****************************************************************************/
fmi2Status fmi2DeSerializeFMUstate(	fmi2Component	c,
									const fmi2Byte	serializedState[],
									size_t			size,
									fmi2FMUstate	*FMUstate) {
	ModelInstance* comp = (ModelInstance *)c;
	M_INT *icur;

	if (invalidState(comp, "fmi2DeSerializeFMUstate", modelInitialized))
		return fmi2Error;

	icur = (M_INT *)serializedState;
	if(icur[0]!=FMUStateID) {
		compLog(compEnv, comp->instanceName, fmi2Error, "error",
			"fmi2DeSerializedFMUstate: called with serializedState not containing valid FMUstate");
		return fmi2Error;
	}
	if(icur[1]>(M_INT)size) {
		compLog(compEnv, comp->instanceName, fmi2Error, "error",
			"fmi2SerializedFMUstate: called with size not sufficient to contain serializedState");
		return fmi2Error;
	}
	FMUstate[0] = (fmi2FMUstate)comp->functions.allocateMemory(1,size);
	memcpy(*FMUstate, serializedState, size);

	return fmi2OK;
}
/* END: fmi2DeSerializeFMUstate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetDirectionalDerivative */
/*****************************************************************************/
fmi2Status fmi2GetDirectionalDerivative(	fmi2Component			c,
										const fmi2ValueReference	vUnknown_ref[],
										size_t						nUnknown,
										const fmi2ValueReference	vKnown_ref[],
										size_t						nKnown,
										const fmi2Real				dvKnown[],
										fmi2Real					dvUnknown[]) {
#ifdef FMI2_PROVIDES_DERIVATIVES
	int i, j, k, row, col, offset;
	fmi2Status sts;
	fmi2ValueReference vrs, vrd;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetDirectionalDerivatives", modelInstantiated|modelInitialized))
		return fmi2Error;
	if (nKnown>0 && nullPointer(comp, "fmi2GetDirectionalDerivative", "vKnown_ref[]", vKnown_ref))
		return fmi2Error;
	if (nUnknown>0 && nullPointer(comp, "fmi2GetDirectionalDerivative", "vUnknown_ref[]", vUnknown_ref))
		return fmi2Error;
	if (nKnown>0 && nullPointer(comp, "fmi2GetDirectionalDerivative", "dvKnown[]", dvKnown))
		return fmi2Error;

	sts = syncModel(comp,"fmi2GetDirectionalDerivative");
	if ( sts!=fmi2OK ) return sts;

	/* Initialize unknown vector */
	for (i=0; i<nUnknown; i++) dvUnknown[i] = 0.;

	/* Get Jacobian information, dimensions, data, etc? */
	if(!comp->jsynced) {
		if(comp->initializeMode)
			initjac(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[NEQ+NPAR+1]),comp->initRes,comp->initJacobian);
		else
			intjac(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[NEQ+NPAR+1]),comp->Jacobian);
		comp->jsynced = fmi2True;
	}

	/* Order of value references :
	t, #states, #index-1(inps), #discrete, #params, #derivs, #events */

	/* Start the computation loop */
	if (comp->initializeMode) {
		offset = NIKNO;
		for (i=0; i<nKnown; i++) {
			/* Check the seed */
			if (dvKnown[i]!=0) {
				vrs = vKnown_ref[i];
				/* assert(vr>=0 && vr<NUMBER_OF_REALS); */
				col = -1;
				for (k=0; k<NIKNO; k++)
					if (vrs==vrIknowns[k]) {
						col = k;
						break;
					}
				/* Compute column i */
				for (j=0; j<nUnknown; j++) {
					vrd = vUnknown_ref[j];
					/* assert(vrd>=0 && vrd<NUMBER_OF_REALS); */
					if ( vrd==vrs ) {
						dvUnknown[j] += 1.0;
					}
					else if(col!=-1) {
						for (k=0; k<NIUNK; k++)
							if (vrd==vrIunknowns[k]) {
								dvUnknown[j] += dvKnown[i]*comp->initJacobian[k*offset+col];
								break;
							}
					}
				}
			}
		}
	}
	else {
		offset = 1+NDIFF+NINP;
		for (i=0; i<nKnown; i++) {
			/* Check the seed */
			if (dvKnown[i]!=0) {
				vrs = vKnown_ref[i];
				/* assert(vr>=0 && vr<NUMBER_OF_REALS); */
				/* Check that vKnown_ref[i] is a state or input */
				if ( vrs==0 || (vrs>=vrStates[0] && vrs<vrStates[0]+NDIFF) )
					col = vrs;
				else if(vrs>=1+NDIFF+NIX1-NINP && vrs<1+NDIFF+NIX1)
					col = vrs-(NIX1-NINP);
				else
					return fmi2Error;
				/* Compute column i */
				for (j=0; j<nUnknown; j++) {
					vrd = vUnknown_ref[j];
					/* assert(vrd>=0 && vrd<NUMBER_OF_REALS); */
					/* Check if vrd is a derivative or an output,
					it could also be an output that's a state */
					if ( vrd>=vrDers[0] && vrd<vrDers[0]+NDIFF ) {
						row = vrd-vrDers[0];
						dvUnknown[j] += dvKnown[i]*comp->Jacobian[row*offset+col];
					}
					else if( vrd>=vrStates[0] && vrd<vrStates[0]+NDIFF ) {
						if ( vrd==vrs ) dvUnknown[j] += 1.0;
					}
					else {
						for (k=0; k<NOUT; k++)
							if (vrd==vrOuts[k]) {
								/* refval-t-states+derivs: vrd-1-NDIFF+NDIFF */
								row = vrd-1;
								dvUnknown[j] += dvKnown[i]*comp->Jacobian[row*offset+col];
								break;
							}
						if (k==NOUT) return fmi2Error;
					}
				}
			}
		}
	}
	return fmi2OK;
#else
	/* Compiler warning fix */
	int i=nUnknown+nKnown;
	void *tmp;
	tmp=(void *)vUnknown_ref;
	tmp=(void *)vKnown_ref;
	tmp=(void *)dvKnown;
	tmp=(void *)dvUnknown;
	if(i>0) tmp=(void *)c;
	/* End compiler warning fix */
	return fmi2Error;
#endif
}
/* END: fmi2GetDirectionalDerivative */
/*****************************************************************************/

#if NCON>0 && defined(WMI_PROJECTION)
/*****************************************************************************/
/* BEGIN: fmi2Projection */
/*****************************************************************************/
fmi2Status fmi2Projection(	fmi2Component	c,
								fmi2Real	P[],
								fmi2Real	projectionTolerance,
								size_t	iterationLimit,
								fmi2Boolean	apply) {
	int i;
	fmi2Status sts;
	fmi2Real S2[NDIFF];

	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2Projection", modelInstantiated|modelInitialized))
		return fmi2Error;

	sts = syncModel(comp,"fmi2Projection");
	if ( sts!=fmi2OK ) return sts;

	for(i=0;i<NDIFF;i++) S2[i] = comp->S.w[i+1];
	i=Projection(comp->S.w[0], &comp->S.w[1], projectionTolerance, iterationLimit, NULL, comp->S.psto);
	if( i!=0 ){
		/* Restore state */
		for(i=0;i<NDIFF;i++) comp->S.w[i+1]=S2[i];
		return fmi2Discard;
	}
	for(i=0;i<NDIFF;i++) P[i] = comp->S.w[i+1]-S2[i];

	if( !apply ){
		for(i=0;i<NDIFF;i++) comp->S.w[i+1]=S2[i];
	}

	return fmi2OK;
}
/* END: fmi2Projection */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2ProjectionStep: No longer supported */
/*****************************************************************************/
fmi2Status fmi2ProjectionStep(	fmi2Component	c,
									fmi2Real	S[]) {
	UNUSED(c);
	UNUSED(S);
		return fmi2Error;
}
/* END: fmi2ProjectionStep */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2Constraint */
/*****************************************************************************/
fmi2Status fmi2Constraint(	fmi2Component	c,
								fmi2Real	C[]) {
	int cb, cr, nblk;
	fmi2Real blkdata[2];
	fmi2Status sts;

	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2Constraint", modelInstantiated|modelInitialized))
		return fmi2Error;

	sts = syncModel(comp,"fmi2Constraint");
	if ( sts!=fmi2OK ) return sts;

	/* Iterate over Residual blocks */
	Rblkp(comp->S.w[0], &comp->S.w[1], blkdata, 0, 0);
	nblk = (int)(blkdata[0]);
	cr = 0;
	for(cb=1;cb<=nblk;cb++) {
		Rblkp(comp->S.w[0], &comp->S.w[1], &C[cr], cb, 3);
		Rblkp(comp->S.w[0], &comp->S.w[1], blkdata, cb, 1);
		cr += (int)(blkdata[0]);
	}

	return fmi2OK;
}
/* END: fmi2Constraint*/
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2ConstraintJacobian: No longer supported */
/*****************************************************************************/
fmi2Status fmi2ConstraintJacobian(	fmi2Component	c,
										fmi2Real	J[]) {

	/* If this function is required at some point, the code will need to be
	modified to fill in the ncon x ndiff Matrix using a sequence of calls to
	the block-based Jacobian. It is known that this will provide 0 entries
	for block dependencies on vars from a prior block, but this will only
	slow convergence of a newton approach, and be irrelevant when sufficiently
	close to the solution manifold */
	UNUSED(c);
	UNUSED(J);
		return fmi2Error;
}
/* END: fmi2ConstraintJacobian*/
/*****************************************************************************/
#endif

#ifdef FMI2_COSIMULATION
/*****************************************************************************
 * FMI functions: only for FMI Co-Simulation 2.0
 *****************************************************************************/
/*****************************************************************************/
/* BEGIN: fmi2SetRealInputDerivatives */
fmi2Status fmi2SetRealInputDerivatives(	fmi2Component			c,
										const fmi2ValueReference vr[],
										size_t					nvr,
										const fmi2Integer		order[],
										const fmi2Real			value[]) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2SetRealInputDerivatives", modelInitialized))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2SetRealInputDerivatives: nvr= %d", nvr);

	compLog(NULL, comp->instanceName, fmi2Error, "warning",
			"fmi2SetRealInputDerivatives: ignoring function call."
			" This model cannot interpolate inputs: canInterpolateInputs = \"fmi2False\"");

	return fmi2Warning;
}
/* END: fmi2SetRealInputDerivatives */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetRealOutputDerivatives */
fmi2Status fmi2GetRealOutputDerivatives(fmi2Component			c,
										const fmi2ValueReference vr[],
										size_t					nvr,
										const fmi2Integer		order[],
										fmi2Real				value[]) {
	int i;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetRealOutputDerivatives", modelInitialized))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2GetRealOutputDerivatives: nvr= %d",	nvr);

	compLog(NULL, comp->instanceName, fmi2Error, "warning",
			"fmi2GetRealOutputDerivatives: ignoring function call."
			" This model cannot compute derivatives of outputs: MaxOutputDerivativeOrder=\"0\"");

	for (i=0; i<(int)nvr; i++) value[i] = 0;

	return fmi2Warning;
}
/* END: fmi2GetRealOutputDerivatives */
/*****************************************************************************/

#define MAX_STEP  1.00000000000000000e-03

/*****************************************************************************/
/* BEGIN: fmi2DoStep */
fmi2Status fmi2DoStep(  fmi2Component	c,
						fmi2Real		currentCommunicationPoint,
						fmi2Real		communicationStepSize,
						fmi2Boolean		newStep) {

	ModelInstance* comp	= (ModelInstance *)c;
	int		i;
	double	h;
	int		n;	/* how many internal steps to perform for one fmi2DoStep */
	int		k, hasEvent;
#if NEVT>0
	M_INT *modes;
	double	prevEventIndicators[max(NEVT, 1)], eventIndicators[max(NEVT, 1)];
#endif

	if (invalidState(comp, "fmi2DoStep", modelInitialized)) return fmi2Error;

	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log", "fmi2DoStep: "
				"currentCommunicationPoint = %g, "
				"communicationStepSize = %g, "
				"newStep = fmi2%s",
				currentCommunicationPoint, communicationStepSize, newStep ? "True" : "False");

	if (comp->stopTimeDefined && currentCommunicationPoint+communicationStepSize > comp->stopTime) {
		comp->state = modelError;
		return fmi2Error;
	}

	if(communicationStepSize==0) {
		n = 1;
		h = 0.0;
	}
	else {
		n = (int)floor((communicationStepSize-1e-12)/MAX_STEP)+1;
		h = communicationStepSize/n;
	}

#if NPAR>0
	if(pchange) {
		SolverInitialize(&(comp->S));
		pchange=0;
		if (errorOccured>0) {
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			comp->state = modelTerminated;
			logMessage(comp, "fmi2DoStep", "error", fmi2Error);
			return fmi2Error;
		}
		else if(errorOccured<0) {
			logMessage(comp, "fmi2DoStep", "warning", fmi2Warning);
			errorOccured=0;
		}
	}
#endif

#if NEVT>0
	/* Run to get initial event indicators */
	eev(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[1]),prevEventIndicators);
	modes=comp->S.iw;
	ComputeEventIndicators(prevEventIndicators,&(comp->S.w[1]),modes,
		&modes[3*NEVT],&modes[2*NEVT],&modes[4*NEVT]);
#endif

	comp->S.w[0] = currentCommunicationPoint;
	/* break the step into n steps and do a step */
	for (k=0; k<n; k++) {
#if NUMBER_OF_REALS>0
		if (h>0.0) {
			EulerStep(h,&(comp->S));
			if (errorOccured>0) {
				setVidError(comp,NULL);
				if (comp->fptr) {
					writeErrorToFile(comp->fptr,NULL);
					comp->fptr = NULL;
				}
				comp->state = modelTerminated;
				logMessage(comp,"EulerStep","error", fmi2Error);
				return fmi2Error;
			}
			else if(errorOccured<0) {
				logMessage(comp, "EulerStep", "warning", fmi2Warning);
				errorOccured=0;
			}
		}

		SolverUpdate(&(comp->S),0,1);
		if (errorOccured>0) {
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			errorOccured = 0;
			comp->state = modelTerminated;
			logMessage(comp, "fmi2DoStep", "error", fmi2Discard);
			return fmi2Discard;
		}
		else if(errorOccured<0) {
			logMessage(comp, "fmi2DoStep", "warning", fmi2Warning);
			errorOccured=0;
		}
		comp->synced = fmi2True;
		comp->jsynced = fmi2False;

		i=SolverProject(&(comp->S));
		if(i<0 || errorOccured==1) {
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			errorOccured = 0;
			comp->state = modelTerminated;
			logMessage(comp, "fmi2DoStep", "error", fmi2Error);
			return fmi2Error;
		}
		else if(i>0 || errorOccured==2) {
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2DoStep: model requested termination at t = %g",
					comp->S.w[0]);
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			errorOccured = 0;
			comp->state = modelTerminated;
			logMessage(comp, "fmi2DoStep", "warning", fmi2Discard);
			return fmi2Discard;
		}
		else if(errorOccured<0) {
			logMessage(comp, "fmi2DoStep", "warning", fmi2Warning);
			errorOccured=0;
		}
#endif
		hasEvent = 0;

#if NEVT>0
		/* check for state event */
		eev(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[1]),eventIndicators);
		modes=comp->S.iw;
		ComputeEventIndicators(eventIndicators,&(comp->S.w[1]),modes,
			&modes[3*NEVT],&modes[2*NEVT],&modes[4*NEVT]);
		for (i=0; i<NEVT; i++) {
			if (eventIndicators[i] * prevEventIndicators[i] < 0) {
				hasEvent = 1;
				if (comp->loggingOn)
					compLog(compEnv, comp->instanceName, fmi2OK, "log",
							"fmi2DoStep: state event at %g, z%d crosses zero -%c-",
							comp->S.w[0], i, eventIndicators[i]<0 ? '\\' : '/');
			}
			prevEventIndicators[i] = eventIndicators[i];
		}

		if (hasEvent) {
			i = RunEvents(comp->S.w, comp->S.iw, 0, -1, EVTITER, comp->S.psto);
			if (i>0 || errorOccured==2) {
				compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2DoStep: model requested termination at t = %g",
					comp->S.w[0]);
			}
			else if (i<0 || errorOccured>0) {
				logMessage(comp, "fmi2DoStep", "error", fmi2Error);
			}
			if (i || errorOccured>0) {
				setVidError(comp,NULL);
				if (comp->fptr) {
					writeErrorToFile(comp->fptr,NULL);
					comp->fptr = NULL;
				}
				errorOccured = 0;
				comp->state = modelTerminated;
				return fmi2Discard;
			}
			if(errorOccured<0) {
				logMessage(comp, "fmi2DoStep", "warning", fmi2Warning);
				errorOccured=0;
			}
		}
#endif

		SolverOutputs(&(comp->S));
	}

	comp->lastSuccessfulTime = currentCommunicationPoint + communicationStepSize;
	comp->vidsts = 2;
 	if (comp->fptr)
		fwrite(comp->S.w,sizeof(fmi2Real),NEQ+1,comp->fptr);

	return fmi2OK;
}
/* END: fmi2DoStep */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2CancelStep */
fmi2Status fmi2CancelStep(fmi2Component c) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2CancelStep", modelInitialized)) return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log", "fmi2CancelStep");

	compLog(NULL, comp->instanceName, fmi2Error, "error",
			"fmi2CancelStep: Can be called when fmi2DoStep returned fmi2Pending."
			" This is not the case.");
	comp->state = modelError;
	return fmi2Error;
}
/* END: fmi2CancelStep */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetStatus */
fmi2Status fmi2GetStatus(	fmi2Component		c,
							const fmi2StatusKind s,
							fmi2Status*			value) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetStatus", modelInstantiated|modelInitialized))
		return fmi2Error;

	if (s==fmi2DoStepStatus) {
		if (comp->loggingOn) {
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"[fmi2GetStatus]: fmi2StatusKind = fmi2DoStepStatus");
			compLog(NULL, comp->instanceName, fmi2Error, "error",
				"[fmi2GetStatus]: Can be called with fmi2DoStepStatus when fmi2DoStep returned fmi2Pending."
				" This is not the case.");
		}
		return fmi2Discard;
	}
	else
		return fmi2Discard;
}
/* END: fmi2GetStatus */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetRealStatus */
fmi2Status fmi2GetRealStatus(	fmi2Component		c,
								const fmi2StatusKind s,
								fmi2Real*			value) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetRealStatus", modelInstantiated|modelInitialized))
		return fmi2Discard;

	if (s==fmi2LastSuccessfulTime) {
		if (comp->loggingOn) {
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"[fmi2GetRealStatus]: fmi2StatusKind = fmi2LastSuccessfulTime");
		}
		if (comp->state==modelTerminated) {
			*value = comp->lastSuccessfulTime;
			return fmi2OK;
		}
		else {
			compLog(NULL, comp->instanceName, fmi2Error, "error",
				"[fmi2GetRealStatus]: Can be called with fmi2LastSuccessfulTime when fmi2DoStep returned fmi2Discard."
				" This is not the case.");
			return fmi2Discard;
		}
	}
	else
		return fmi2Discard;
}
/* END: fmi2GetRealStatus */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetIntegerStatus */
fmi2Status fmi2GetIntegerStatus(fmi2Component		c,
								const fmi2StatusKind s,
								fmi2Integer*		value) {
	return fmi2Discard;
}
/* END: fmi2GetIntegerStatus */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetBooleanStatus */
fmi2Status fmi2GetBooleanStatus(fmi2Component		c,
								const fmi2StatusKind s,
								fmi2Boolean*		value) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetBooleanStatus", modelInstantiated|modelInitialized))
		return fmi2Discard;

	if (s==fmi2Terminated) {
		if (comp->loggingOn) {
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"[fmi2GetBooleanStatus]: fmi2StatusKind = fmi2Terminated");
		}
		if (comp->state==modelTerminated)
			*value = fmi2True;
		else
			*value = fmi2False;
		return fmi2OK;
	}
	else
		return fmi2Discard;
}
/* END: fmi2GetBooleanStatus */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetStringStatus */
fmi2Status fmi2GetStringStatus(	fmi2Component		c,
								const fmi2StatusKind s,
								fmi2String*			value) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetStringStatus", modelInstantiated|modelInitialized))
		return fmi2Discard;

	if (s==fmi2PendingStatus) {
		if (comp->loggingOn) {
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"[fmi2GetStringStatus]: fmi2StatusKind = fmi2PendingStatus");
			compLog(NULL, comp->instanceName, fmi2Error, "error",
					"[fmi2GetStringStatus]: Can be called with fmi2PendingStatus when fmi2DoStep returned fmi2Pending."
					" This is not the case.");
		}
		return fmi2Discard;
	}
	else
		return fmi2Discard;
}
/* END: fmi2GetStringStatus */
/*****************************************************************************/

#else
/*****************************************************************************
 * FMI functions: only for Model Exchange 2.0
 *****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2EnterEventMode */
fmi2Status fmi2EnterEventMode(fmi2Component c) {
	ModelInstance* comp = (ModelInstance *)c;

	if (comp) {
		comp->lastEventTime = comp->S.w[0]-1.0;
		return fmi2OK;
	}
	else
		return fmi2Error;
}
/* END: fmi2EnterEventMode */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2NewDiscreteStates */
fmi2Status fmi2NewDiscreteStates(fmi2Component	c,
								fmi2EventInfo*	eventInfo) {
	ModelInstance* comp = (ModelInstance *)c;
	int i;
#if NEVT+NCON>0
	fmi2Real save[NEQ],val;
#endif
	if (invalidState(comp, "fmi2NewDiscreteStates", modelInitialized))
		return fmi2Error;
	if (nullPointer (comp, "fmi2NewDiscreteStates", "eventInfo", eventInfo))
		return fmi2Error;

	eventInfo->newDiscreteStatesNeeded				= fmi2False;
	eventInfo->nominalsOfContinuousStatesChanged	= fmi2False;
	eventInfo->valuesOfContinuousStatesChanged		= fmi2False;
	eventInfo->terminateSimulation					= fmi2False;
	eventInfo->nextEventTimeDefined					= fmi2False;
	eventInfo->nextEventTime						= -0.0;

#if NEVT+NCON>0
	for(i=0;i<NEQ;i++) save[i]=comp->S.w[i+1];
#endif
	i=SolverProject(&(comp->S));
	if (i<0 || errorOccured==1) {
		setVidError(comp,NULL);
		if (comp->fptr) {
			writeErrorToFile(comp->fptr,NULL);
			comp->fptr = NULL;
		}
		eventInfo->terminateSimulation = fmi2True;
		comp->state = modelTerminated;
		logMessage(comp, "fmi2NewDiscreteStates", "error", fmi2Error);
		return fmi2Error;
	}
	else if (i>0 || errorOccured==2) {
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2NewDiscreteStates: model requested termination at t = %g",
				comp->S.w[0]);
		setVidError(comp,NULL);
		if (comp->fptr) {
			writeErrorToFile(comp->fptr,NULL);
			comp->fptr = NULL;
		}
		eventInfo->terminateSimulation = fmi2True;
		comp->state = modelTerminated;
		logMessage(comp, "fmi2NewDiscreteStates", "warning", fmi2Discard);
		return fmi2OK;
	}
	else if(errorOccured<0) {
		logMessage(comp, "fmi2NewDiscreteStates", "warning", fmi2Warning);
		errorOccured=0;
	}
#if NEVT>0
	if (comp->S.w[0]!=comp->lastEventTime) {
		i=RunEvents(comp->S.w, comp->S.iw, 0, -1, EVTITER, comp->S.psto);
		if (i<0 || errorOccured==1) {
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			eventInfo->terminateSimulation = fmi2True;
			comp->state = modelTerminated;
			logMessage(comp, "fmi2NewDiscreteStates", "error", fmi2Error);
			return fmi2Error;
		}
		else if (i>0 || errorOccured==2) {
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2NewDiscreteStates: model requested termination at t = %g",
					comp->S.w[0]);
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			eventInfo->terminateSimulation = fmi2True;
			comp->state = modelTerminated;
			logMessage(comp, "fmi2NewDiscreteStates", "warning", fmi2Discard);
			return fmi2OK;
		}
		else if(errorOccured<0) {
			logMessage(comp, "fmi2NewDiscreteStates", "warning", fmi2Warning);
			errorOccured=0;
		}
		comp->lastEventTime = comp->S.w[0];
	}
	i=RunEvents(comp->S.w, comp->S.iw, 1, -1, EVTITER, comp->S.psto);
	if (i<0 || errorOccured==1) {
		setVidError(comp,NULL);
		if (comp->fptr) {
			writeErrorToFile(comp->fptr,NULL);
			comp->fptr = NULL;
		}
		eventInfo->terminateSimulation = fmi2True;
		comp->state = modelTerminated;
		logMessage(comp, "fmi2NewDiscreteStates", "error", fmi2Error);
		return fmi2Error;
	}
	else if (i>0 || errorOccured==2) {
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2NewDiscreteStates: model requested termination at t = %g",
				comp->S.w[0]);
		setVidError(comp,NULL);
		if (comp->fptr) {
			writeErrorToFile(comp->fptr,NULL);
			comp->fptr = NULL;
		}
		eventInfo->terminateSimulation = fmi2True;
		comp->state = modelTerminated;
		logMessage(comp, "fmi2NewDiscreteStates", "warning", fmi2Discard);
		return fmi2OK;
	}
	else if(errorOccured<0) {
		logMessage(comp, "fmi2NewDiscreteStates", "warning", fmi2Warning);
		errorOccured=0;
	}
#endif
#if NEVT+NCON>0
	for(i=0;i<NEQ;i++) {
		val=1e-15;
		if(fabs(save[i])>val) val=fabs(save[i]);
		if(fabs(comp->S.w[i+1])>val) val=fabs(comp->S.w[i+1]);
		if( fabs(comp->S.w[i+1]-save[i])>1e-12*val )
			eventInfo->valuesOfContinuousStatesChanged = fmi2True;
	}
	if(eventInfo->valuesOfContinuousStatesChanged==fmi2True)
		SolverOutputs(&(comp->S));
#endif
	return fmi2OK;
}
/* END: fmi2NewDiscreteStates */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2EnterContinuousTimeMode */
fmi2Status fmi2EnterContinuousTimeMode(fmi2Component c) {
	if (c)	return fmi2OK;
	else	return fmi2Error;
}
/* END: fmi2EnterContinuousTimeMode */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2CompletedIntegratorStep */
fmi2Status fmi2CompletedIntegratorStep(	fmi2Component	c,
										fmi2Boolean		noSetFMUStatePriorToCurrentPoint,
										fmi2Boolean*	enterEventMode,
										fmi2Boolean*	terminateSimulation) {
	ModelInstance* comp = (ModelInstance *)c;
	int i;
#if NCON>0 && defined(CONDSTEPEVENT)
	fmi2Real save[NEQ],val,drift;
#endif

	UNUSED(noSetFMUStatePriorToCurrentPoint);
	if (invalidState(comp, "fmi2CompletedIntegratorStep", modelInitialized))
		return fmi2Error;
	if (nullPointer (comp, "fmi2CompletedIntegratorStep", "enterEventMode", enterEventMode))
		return fmi2Error;
	if (nullPointer (comp, "fmi2CompletedIntegratorStep", "terminateSimulation", terminateSimulation))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2CompletedIntegratorStep");

	*terminateSimulation = fmi2False;

	if (comp->synced)
		SolverUpdate(&(comp->S),1,1);
	else {
		SolverUpdate(&(comp->S),0,1);
		if (errorOccured>0) {
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			errorOccured = 0;
			comp->state = modelTerminated;
			logMessage(comp, "fmi2CompletedIntegratorStep", "error", fmi2Discard);
			return fmi2Discard;
		}
		else if(errorOccured<0) {
			logMessage(comp, "fmi2CompletedIntegratorStep", "warning", fmi2Warning);
			errorOccured=0;
		}
		comp->synced = fmi2True;
		comp->jsynced = fmi2False;
	}
	if(comp->fmuType==fmi2ModelExchange && comp->S.wset)
		for(i=NDIFF+1;i<=NDIFF+NIX1-NINP;i++)
			comp->S.wset[i]=comp->S.w[i];
	SolverOutputs(&(comp->S));
	if( comp->S.w[0]>=(comp->vidlasttime+comp->minSampleStep)*(1-1e-15) ) {
		comp->vidsts=2;
		comp->vidlasttime=comp->S.w[0];
	}
 	if (comp->fptr)
		if ( comp->S.w[0]>=(comp->lastsampletime+comp->minSampleStep)*(1-1e-15) ) {
			fwrite(comp->S.w,sizeof(fmi2Real),NEQ+1,comp->fptr);
			comp->lastsampletime=comp->S.w[0];
			if ( comp->numpts++ == WARNNUMDATPTS )
				compLog(compEnv, comp->instanceName, fmi2Warning, "warning",
						"[fmi2CompletedIntegratorStep]: At time t=%.16g, %d data points were written into file %s; consider increasing the minimum sample step, %.16g, to limit file size.",
						comp->S.w[0], WARNNUMDATPTS, comp->fstr, comp->minSampleStep);
		}

#if !defined(WMI_PROJECTION) && NCON>0
#   if defined(CONDSTEPEVENT)
	for(i=0;i<NEQ;i++) save[i]=comp->S.w[i+1];
	i=SolverProject(&(comp->S));
	if (i<0 || errorOccured>=1) {
		errorOccured=0;
		*enterEventMode = fmi2True;
	}
	else if (i>0) {
		setVidError(comp,NULL);
		if (comp->fptr) {
			writeErrorToFile(comp->fptr,NULL);
			comp->fptr = NULL;
		}
		comp->state = modelTerminated;
		*terminateSimulation = fmi2True;
		logMessage(comp, "fmi2CompletedIntegratorStep", "error", fmi2Discard);
		return fmi2OK;
	}
	else {
		drift=0.0;
		for(i=0;i<NEQ;i++) {
			val=1e-15;
			if(fabs(save[i])>val) val=fabs(save[i]);
			if(fabs(comp->S.w[i+1])>val) val=fabs(comp->S.w[i+1]);
			val=fabs(comp->S.w[i+1]-save[i])/val;
			if(val>drift) drift=val;
		}
		val=(CONTOL<1e-8) ? 1e-10 : 0.01*CONTOL;
		if(drift>val)
			*enterEventMode = fmi2True;
		else
			*enterEventMode = fmi2False;
	}
	for(i=0;i<NEQ;i++) comp->S.w[i+1]=save[i];
#   else
	*enterEventMode = fmi2True;
#   endif
#else
	*enterEventMode = fmi2False;
#endif

	return fmi2OK;
}
/* END: fmi2CompletedIntegratorStep */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetTime */
fmi2Status fmi2SetTime(	fmi2Component	c,
						fmi2Real		time) {
	ModelInstance* comp = (ModelInstance *)c;
	if (invalidState(comp, "fmi2SetTime", modelInstantiated|modelInitialized))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2SetTime: time = %.16g", time);
	if (comp->S.w[0] != time) {
		comp->S.w[0] = time;
		comp->synced = fmi2False;
		comp->jsynced = fmi2False;
	}
	return fmi2OK;
}
/* END: fmi2SetTime */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetContinuousStates */
fmi2Status fmi2SetContinuousStates(	fmi2Component	c,
									const fmi2Real	x[],
									size_t			nx){
	ModelInstance* comp = (ModelInstance *)c;
#if NDIFF>0
	double scalev;
	int i;
	fmi2ValueReference vr;
#endif

	if (invalidState (comp, "fmi2SetContinuousStates", modelInitialized))
		return fmi2Error;
	if (invalidNumber(comp, "fmi2SetContinuousStates", "nx", nx, NDIFF))
		return fmi2Error;
#if NDIFF>0
	if (nullPointer  (comp, "fmi2SetContinuousStates", "x[]", x))
		return fmi2Error;

	for (i=0; i<(int)nx; i++) {
		vr = vrStates[i];
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2SetContinuousStates: #r%d# = %.16g", vr, x[i]);
		/*assert(vr>=0 && vr<NUMBER_OF_REALS);*/
		if( nomfac )
			scalev = nomfac[i]*x[i];
		else
			scalev = x[i];
		if (comp->S.w[vr] != scalev) {
			comp->S.w[vr] = scalev;
			comp->synced = fmi2False;
			comp->jsynced = fmi2False;
		}
	}
#endif
	return fmi2OK;
}
/* END: fmi2SetContinuousStates */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetDerivatives */
fmi2Status fmi2GetDerivatives(	fmi2Component	c,
								fmi2Real		derivatives[],
								size_t			nx) {
#if NDIFF>0
	int i;
#endif
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState (comp, "fmi2GetDerivatives", validGet))
		return fmi2Error;
	if (invalidNumber(comp, "fmi2GetDerivatives", "nx", nx, NDIFF))
		return fmi2Error;
	if (nullPointer  (comp, "fmi2GetDerivatives", "derivatives[]", derivatives))
		return fmi2Error;

#if NDIFF>0
	if (comp->state==modelInitialized && !comp->synced) {
		SolverUpdate(&(comp->S),0,0);
		if(errorOccured>0) {
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			errorOccured=0;
			logMessage(comp, "fmi2GetDerivatives", "error", fmi2Discard);
			return fmi2Discard;
		}
		else if(errorOccured<0) {
			logMessage(comp, "fmi2GetDerivatives", "warning", fmi2Warning);
			errorOccured=0;
		}
		comp->synced = fmi2True;
		comp->jsynced = fmi2False;
	}
	for (i=0; i<(int)nx; i++) {
		if( nomfac )
			derivatives[i] = comp->S.w[vrDers[i]]/nomfac[i];
		else
			derivatives[i] = comp->S.w[vrDers[i]];
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2GetDerivatives: #r%d# = %.16g",	vrDers[i], derivatives[i]);
	}
#endif
	return fmi2OK;
}
/* END: fmi2GetDerivatives */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetEventIndicators */
fmi2Status fmi2GetEventIndicators(	fmi2Component	c,
									fmi2Real		eventIndicators[],
									size_t			ni) {
#if NEVT>0
	int i;
	M_INT *modes;
	fmi2Status sts;
#endif
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState (comp, "fmi2GetEventIndicators", validGet))
		return fmi2Error;
	if (invalidNumber(comp, "fmi2GetEventIndicators", "ni", ni, NEVT))
		return fmi2Error;

#if NEVT>0
	sts = syncModel(c,"fmi2GetEventIndicators");
	if ( sts!=fmi2OK ) return(sts);
	eev(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[1]),eventIndicators);
	modes=comp->S.iw;
	ComputeEventIndicators(eventIndicators,&(comp->S.w[1]),modes,
		&modes[3*NEVT],&modes[2*NEVT],&modes[4*NEVT]);
	for (i=0; i<(int)ni; i++) {
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2GetEventIndicators: z%d = %.16g",
					i, eventIndicators[i]);
	}
#else
	UNUSED(eventIndicators);
#endif
	return fmi2OK;
}
/* END: fmi2GetEventIndicators */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetContinuousStates */
fmi2Status fmi2GetContinuousStates(	fmi2Component	c,
									fmi2Real		states[],
									size_t			nx) {
#if NDIFF>0
	int i;
	fmi2Status sts;
#endif
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState (comp, "fmi2GetContinuousStates", validGet))
		return fmi2Error;
	if (invalidNumber(comp, "fmi2GetContinuousStates", "nx", nx, NDIFF))
		return fmi2Error;
#if NDIFF>0
	if (nullPointer  (comp, "fmi2GetContinuousStates", "states[]", states))
		return fmi2Error;

	sts = syncModel(c,"fmi2GetContinuousStates");
	if ( sts!=fmi2OK ) return(sts);
	for (i=0; i<(int)nx; i++) {
		if( nomfac )
			states[i] = comp->S.w[vrStates[i]]/nomfac[i];
		else
			states[i] = comp->S.w[vrStates[i]];
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2GetContinuousStates: #r%u# = %.16g", vrStates[i], states[i]);
	}
#endif
	return fmi2OK;
}
/* END: fmi2GetContinuousStates */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetNominalsOfContinuousStates */
fmi2Status fmi2GetNominalsOfContinuousStates(fmi2Component	c,
											fmi2Real		x_nominal[],
											size_t			nx) {
	ModelInstance* comp = (ModelInstance *)c;
	int i;

	if (invalidState (comp, "fmi2GetNominalsOfContinuousStates", validGet))
		return fmi2Error;
	if (invalidNumber(comp, "fmi2GetNominalsOfContinuousStates", "nx", nx, NDIFF))
		return fmi2Error;
	if (nullPointer  (comp, "fmi2GetNominalsOfContinuousStates", "x_nominal[]", x_nominal))
		return fmi2Error;

	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2GetNominalsOfContinuousStates: x_nominal[0..%d] = 1.0", nx-1);
	if( nomfac )
		for (i=0; i<(int)nx; i++) x_nominal[i] = 1.0/nomfac[i-1];
	else
		for (i=0; i<(int)nx; i++) x_nominal[i] = 1.0;

	return fmi2OK;
}
/* END: fmi2GetNominalsOfContinuousStates */
/*****************************************************************************/

#endif

/*****************************************************************************/
/* Special purpose data communication functions */

typedef fmi2Status getMapleSimVideoDataLengthTYPE(fmi2Component, fmi2Integer *);
#define getMapleSimVideoDataLength fmi2FullName(getMapleSimVideoDataLength)
FMI2_Export getMapleSimVideoDataLengthTYPE getMapleSimVideoDataLength;

fmi2Status getMapleSimVideoDataLength(fmi2Component c, fmi2Integer *len)
{
	ModelInstance* comp = (ModelInstance *)c;

	if(comp->vidsts==0) {
		*len=0;
		return(fmi2Warning);
	}
	else if(comp->vidsts==1)
		*len=2+NPAR;
	else if(comp->vidsts==2)
		*len=NEQ+1;
	else if(comp->vidsts==-1)
		*len=2+strlen(comp->viderror)/8;
	else {
		*len=0;
		return(fmi2Error);
	}
	return(fmi2OK);
}

typedef fmi2Status getMapleSimVideoDataTYPE(fmi2Component, fmi2Real *);
#define getMapleSimVideoData fmi2FullName(getMapleSimVideoData)
FMI2_Export getMapleSimVideoDataTYPE getMapleSimVideoData;

fmi2Status getMapleSimVideoData(fmi2Component c, fmi2Real *data)
{
	ModelInstance* comp = (ModelInstance *)c;

	if(comp->vidsts==0)
		return(fmi2Error);
	else if(comp->vidsts==1) {
		data[0]=nData[0];
		data[1]=nData[1];
		memcpy(&data[2],&comp->S.w[NEQ+1],NPAR*sizeof(fmi2Real));
	}
	else if(comp->vidsts==2)
		memcpy(data,comp->S.w,(NEQ+1)*sizeof(fmi2Real));
	else if(comp->vidsts==-1) {
		data[0]=-1e10;
		memcpy(&data[1],comp->viderror,strlen(comp->viderror)+1);
	}
	else
		return(fmi2Error);
	comp->vidsts=0;
	return(fmi2OK);
}

typedef fmi2Status getMapleSimAuxiliaryDataTYPE(fmi2Component, fmi2Real *);
#define getMapleSimAuxiliaryData fmi2FullName(getMapleSimAuxiliaryData)
FMI2_Export getMapleSimAuxiliaryDataTYPE getMapleSimAuxiliaryData;

fmi2Status getMapleSimAuxiliaryData(fmi2Component c, fmi2Real *data)
{
	ModelInstance* comp = (ModelInstance *)c;

	if(!comp->synced) {
		auxp(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[NEQ+NPAR+1]),data);
		return(fmi2Discard);
	}
	else if(comp->state==modelInitialized) {
		auxp(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[NEQ+NPAR+1]),data);
		return(fmi2OK);
	}
	else return(fmi2Error);
}
